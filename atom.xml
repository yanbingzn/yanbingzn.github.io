<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>严冰的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-01-29T08:56:20.211Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>yanbing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>上机刷题</title>
    <link href="http://yoursite.com/2020/12/29/%E4%B8%8A%E6%9C%BA%E5%88%B7%E9%A2%98/"/>
    <id>http://yoursite.com/2020/12/29/%E4%B8%8A%E6%9C%BA%E5%88%B7%E9%A2%98/</id>
    <published>2020-12-29T11:33:02.606Z</published>
    <updated>2021-01-29T08:56:20.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="输入单词个数统计"><a href="#输入单词个数统计" class="headerlink" title="-输入单词个数统计"></a>-输入单词个数统计</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>从键盘输入一行字符，长度小于1000，统计其中单词的个数，个单词以空格分隔，且空格数可以是多个。。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; s;</span><br><span class="line"><span class="built_in">string</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;temp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="built_in">find</span>(<span class="string">','</span>)!=<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">s.push_back(temp);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cin</span>.<span class="built_in">get</span>()==<span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>笔记：while(cin&gt;&gt;temp)：输入多个字符，用空格分隔开<br>s.find(i)!=string::npos:find函数在找不到指定值得情况下会返回string::npos,确认字符串含有某个字符</p><p>笔记：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> r[<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">定义数组</span><br></pre></td></tr></table></figure><p>int r[2]={1,2};</p><h2 id="棒球比赛"><a href="#棒球比赛" class="headerlink" title="-棒球比赛"></a>-棒球比赛</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串列表，每个字符串可以是以下四种类型之一：</p><ol><li><p>整数（一轮的得分）：直接表示您在本轮中获得的积分数。</p></li><li><p>“+”（一轮的得分）：表示本轮获得的得分是前两轮有效 回合得分的总和。</p></li><li><p>“D”（一轮的得分）：表示本轮获得的得分是前一轮有效 回合得分的两倍。</p></li><li><p>“C”（一个操作，这不是一个回合的分数）：表示您获得的最后一个有效 回合的分数是无效的，应该被移除。</p></li></ol><p>每一轮的操作都是永久性的，可能会对前一轮和后一轮产生影响。<br>你需要返回你在所有回合中得分的总和。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> op;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;op)&#123;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">'+'</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> a=st.top();</span><br><span class="line">st.pop();</span><br><span class="line"><span class="keyword">int</span> b=st.top();</span><br><span class="line">st.push(a);</span><br><span class="line">st.push(a+b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">'D'</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> a=st.top();</span><br><span class="line">st.push(<span class="number">2</span>*a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">'C'</span>)&#123;</span><br><span class="line">st.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=op<span class="number">-48</span>; <span class="comment">//字符转为整数类型</span></span><br><span class="line">st.push(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cin</span>.<span class="built_in">get</span>()==<span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">sum+=st.top();</span><br><span class="line">st.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-1"><a href="#-1" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-2"><a href="#-2" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-3"><a href="#-3" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-4"><a href="#-4" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-5"><a href="#-5" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-6"><a href="#-6" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-7"><a href="#-7" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-8"><a href="#-8" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-9"><a href="#-9" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-10"><a href="#-10" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-11"><a href="#-11" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-12"><a href="#-12" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-13"><a href="#-13" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-14"><a href="#-14" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-15"><a href="#-15" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-16"><a href="#-16" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-17"><a href="#-17" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-19"><a href="#解题思路-19" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-18"><a href="#-18" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-20"><a href="#解题思路-20" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-19"><a href="#-19" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-21"><a href="#解题思路-21" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-20"><a href="#-20" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-22"><a href="#解题思路-22" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-21"><a href="#-21" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-23"><a href="#解题思路-23" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-22"><a href="#-22" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-24"><a href="#解题思路-24" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-23"><a href="#-23" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-25"><a href="#解题思路-25" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-24"><a href="#-24" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-26"><a href="#解题思路-26" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-25"><a href="#-25" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-27"><a href="#解题思路-27" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-26"><a href="#-26" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-28"><a href="#解题思路-28" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-27"><a href="#-27" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-29"><a href="#解题思路-29" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-28"><a href="#-28" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-30"><a href="#解题思路-30" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-29"><a href="#-29" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-31"><a href="#解题思路-31" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-30"><a href="#-30" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-32"><a href="#解题思路-32" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-31"><a href="#-31" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-33"><a href="#解题思路-33" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-32"><a href="#-32" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-34"><a href="#题目描述-34" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-34"><a href="#解题思路-34" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-33"><a href="#-33" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-35"><a href="#题目描述-35" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-35"><a href="#解题思路-35" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-34"><a href="#-34" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-36"><a href="#题目描述-36" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-36"><a href="#解题思路-36" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-35"><a href="#-35" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-37"><a href="#题目描述-37" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-37"><a href="#解题思路-37" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-36"><a href="#-36" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-38"><a href="#题目描述-38" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-38"><a href="#解题思路-38" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-37"><a href="#-37" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-39"><a href="#题目描述-39" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-39"><a href="#解题思路-39" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-38"><a href="#-38" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-40"><a href="#题目描述-40" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-40"><a href="#解题思路-40" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-39"><a href="#-39" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-41"><a href="#题目描述-41" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-41"><a href="#解题思路-41" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-40"><a href="#-40" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-42"><a href="#题目描述-42" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-42"><a href="#解题思路-42" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-41"><a href="#-41" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-43"><a href="#题目描述-43" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-43"><a href="#解题思路-43" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-42"><a href="#-42" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-44"><a href="#题目描述-44" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-44"><a href="#解题思路-44" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-43"><a href="#-43" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-45"><a href="#题目描述-45" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-45"><a href="#解题思路-45" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-44"><a href="#-44" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-46"><a href="#题目描述-46" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-46"><a href="#解题思路-46" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-45"><a href="#-45" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-47"><a href="#题目描述-47" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-47"><a href="#解题思路-47" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-46"><a href="#-46" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-48"><a href="#题目描述-48" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-48"><a href="#解题思路-48" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-47"><a href="#-47" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-49"><a href="#题目描述-49" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-49"><a href="#解题思路-49" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-48"><a href="#-48" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-50"><a href="#题目描述-50" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-50"><a href="#解题思路-50" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-49"><a href="#-49" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-51"><a href="#题目描述-51" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-51"><a href="#解题思路-51" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-50"><a href="#-50" class="headerlink" title="-"></a>-</h2><h3 id="题目描述-52"><a href="#题目描述-52" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-52"><a href="#解题思路-52" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;输入单词个数统计&quot;&gt;&lt;a href=&quot;#输入单词个数统计&quot; class=&quot;headerlink&quot; title=&quot;-输入单词个数统计&quot;&gt;&lt;/a&gt;-输入单词个数统计&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>刷题/力扣简单题</title>
    <link href="http://yoursite.com/2020/07/31/%E5%88%B7%E9%A2%98/%E5%8A%9B%E6%89%A3%E7%AE%80%E5%8D%95%E9%A2%98/"/>
    <id>http://yoursite.com/2020/07/31/%E5%88%B7%E9%A2%98/%E5%8A%9B%E6%89%A3%E7%AE%80%E5%8D%95%E9%A2%98/</id>
    <published>2020-07-31T14:50:10.744Z</published>
    <updated>2020-07-31T16:00:04.173Z</updated>
    
    <content type="html"><![CDATA[<h2 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a>7. 整数反转</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>long类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span>=<span class="number">0x7fffffff</span>, <span class="built_in">min</span>=<span class="number">0x80000000</span>; <span class="comment">//int的最大值和最小值</span></span><br><span class="line">        <span class="keyword">long</span> n=<span class="number">0</span>; <span class="comment">//long类型，且初始化为0</span></span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            n=n*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n&gt;<span class="built_in">max</span> || n&lt;<span class="built_in">min</span> ? <span class="number">0</span>:n;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a>9. 回文数</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>判断反转数字求是否相等即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp=x;</span><br><span class="line">        <span class="keyword">long</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">            num=num*<span class="number">10</span>+temp%<span class="number">10</span>;</span><br><span class="line">            temp/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num==x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-5"><a href="#-5" class="headerlink" title=""></a></h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-6"><a href="#-6" class="headerlink" title=""></a></h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-7"><a href="#-7" class="headerlink" title=""></a></h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-8"><a href="#-8" class="headerlink" title=""></a></h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-9"><a href="#-9" class="headerlink" title=""></a></h2><h3 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-10"><a href="#-10" class="headerlink" title=""></a></h2><h3 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-11"><a href="#-11" class="headerlink" title=""></a></h2><h3 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-12"><a href="#-12" class="headerlink" title=""></a></h2><h3 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-13"><a href="#-13" class="headerlink" title=""></a></h2><h3 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-14"><a href="#-14" class="headerlink" title=""></a></h2><h3 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-15"><a href="#-15" class="headerlink" title=""></a></h2><h3 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-16"><a href="#-16" class="headerlink" title=""></a></h2><h3 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-17"><a href="#-17" class="headerlink" title=""></a></h2><h3 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-19"><a href="#解题思路-19" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-18"><a href="#-18" class="headerlink" title=""></a></h2><h3 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-20"><a href="#解题思路-20" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-19"><a href="#-19" class="headerlink" title=""></a></h2><h3 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-21"><a href="#解题思路-21" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;7-整数反转&quot;&gt;&lt;a href=&quot;#7-整数反转&quot; class=&quot;headerlink&quot; title=&quot;7. 整数反转&quot;&gt;&lt;/a&gt;7. 整数反转&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>刷题/蓝桥杯C++</title>
    <link href="http://yoursite.com/2020/07/09/%E5%88%B7%E9%A2%98/%E8%93%9D%E6%A1%A5%E6%9D%AFC++/"/>
    <id>http://yoursite.com/2020/07/09/%E5%88%B7%E9%A2%98/%E8%93%9D%E6%A1%A5%E6%9D%AFC++/</id>
    <published>2020-07-09T14:17:15.933Z</published>
    <updated>2020-07-10T11:06:12.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a><strong>基础知识</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">定义大数：</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line">精确小数点位数</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">7</span>)&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">调用pi</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;M_PI&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="小计算器"><a href="#小计算器" class="headerlink" title="小计算器"></a>小计算器</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入指令模拟计算器操作</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>模拟题，进制转换问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//蓝桥杯的在线评测不支持C++11</span></span><br><span class="line"><span class="comment">//比如 using uLL = unsigned long long;</span></span><br><span class="line"><span class="comment">//比如 to_string() </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uLL unsigned long long</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//10进制转为K进制存储 </span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">toKbit</span><span class="params">(uLL num, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>( num == <span class="number">0</span> )</span><br><span class="line"><span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line"><span class="comment">//if( k == 10 )</span></span><br><span class="line"><span class="comment">//return to_string(num);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">66</span>];</span><br><span class="line"><span class="keyword">while</span>( num != <span class="number">0</span> )&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">bit</span> = num % k;</span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">bit</span> &gt;= <span class="number">10</span> )&#123;</span><br><span class="line"><span class="built_in">buffer</span>[i++] = <span class="string">'A'</span> + <span class="built_in">bit</span> - <span class="number">10</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">buffer</span>[i++] = <span class="string">'0'</span> + <span class="built_in">bit</span>;</span><br><span class="line">&#125;</span><br><span class="line">num /= k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">buffer</span>[i] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">res</span><span class="params">(<span class="built_in">buffer</span>)</span></span>;</span><br><span class="line">reverse(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//K进制转10进制 </span></span><br><span class="line"><span class="function">uLL <span class="title">kBit_to_10</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; num, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uLL res = <span class="number">0</span>, p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = num.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i, p*=k)&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">bit</span>;</span><br><span class="line"><span class="keyword">if</span>( num[i]&gt;=<span class="string">'A'</span> &amp;&amp; num[i]&lt;=<span class="string">'Z'</span> )&#123;</span><br><span class="line"><span class="built_in">bit</span> = num[i] - <span class="string">'A'</span> + <span class="number">10</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">bit</span> = num[i] - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line">res += (p*<span class="built_in">bit</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">uLL <span class="title">newNum</span><span class="params">(uLL num1, uLL num2, <span class="keyword">const</span> <span class="built_in">string</span>&amp; oop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uLL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>( oop == <span class="string">"ADD"</span> )&#123;</span><br><span class="line">res = num1 + num2;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>( oop == <span class="string">"SUB"</span> )&#123;</span><br><span class="line">res = num1 - num2;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>( oop == <span class="string">"MUL"</span> )&#123;</span><br><span class="line">res = num1 * num2;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>( oop == <span class="string">"DIV"</span> )&#123;</span><br><span class="line">res = num1 / num2;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>( oop == <span class="string">"MOD"</span> )&#123;</span><br><span class="line">res = num1 % num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  k = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">bool</span> isNum1 = <span class="literal">true</span>, isNum2 = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//isNum1记录现在是输入哪个数</span></span><br><span class="line"><span class="comment">//isNum2记录num2是否输入过了，因为运算指令和num2顺序不一定 </span></span><br><span class="line">uLL num1, num2;<span class="comment">//</span></span><br><span class="line"><span class="built_in">string</span> op, num;<span class="comment">//op操作指令，num为输入的操作数 </span></span><br><span class="line"><span class="built_in">string</span> oop = <span class="string">""</span>;<span class="comment">//oop运算指令 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">while</span>( n-- )&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line"><span class="keyword">if</span>( op == <span class="string">"CLEAR"</span> )&#123;</span><br><span class="line">isNum1 = <span class="literal">true</span>;</span><br><span class="line">isNum2 = <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>( op == <span class="string">"CHANGE"</span> )&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>( op == <span class="string">"EQUAL"</span> )&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; toKbit(num1, k) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>( op == <span class="string">"NUM"</span> )&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line"><span class="keyword">if</span>( isNum1 )&#123;</span><br><span class="line">isNum1 = <span class="literal">false</span>;</span><br><span class="line">num1 = kBit_to_10(num, k);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">isNum2 = <span class="literal">true</span>;</span><br><span class="line">num2 = kBit_to_10(num, k);</span><br><span class="line"><span class="keyword">if</span>( oop != <span class="string">""</span> )&#123;</span><br><span class="line">num1 = newNum(num1, num2, oop);</span><br><span class="line">oop = <span class="string">""</span>;</span><br><span class="line">isNum2 = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">oop = op;</span><br><span class="line"><span class="keyword">if</span>( isNum2 )&#123;</span><br><span class="line">num1 = newNum(num1, num2, oop);</span><br><span class="line">oop = <span class="string">""</span>;</span><br><span class="line">isNum2 = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;&lt;strong&gt;基础知识&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SpringBoot基础</title>
    <link href="http://yoursite.com/2020/06/23/Java%E6%A1%86%E6%9E%B6/SpringBoot/"/>
    <id>http://yoursite.com/2020/06/23/Java%E6%A1%86%E6%9E%B6/SpringBoot/</id>
    <published>2020-06-23T12:50:49.000Z</published>
    <updated>2020-07-01T10:56:40.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h2><h3 id="JavaConfig"><a href="#JavaConfig" class="headerlink" title="JavaConfig"></a>JavaConfig</h3><p>Spring JavaConfig 是 Spring 社区的产品，它提供了配置 Spring IoC 容器的纯 Java 方法，因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于：</p><ul><li><p>面向对象的配置。</p><p>由于配置被定义为 JavaConfig 中的类，因此用户可以充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean 方法等。</p></li><li><p>减少或消除 XML 配置。</p><p>许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。</p></li><li><p>类型安全和重构友好。</p><p>JavaConfig 提供了一种类型安全的方法来配置 Spring容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。</p><a id="more"></a><h3 id="配置加载顺序"><a href="#配置加载顺序" class="headerlink" title="配置加载顺序"></a>配置加载顺序</h3></li></ul><p>在 Spring Boot 里面，可以使用以下几种方式来加载配置。</p><ol><li><p>properties文件</p></li><li><p>YAML文件</p></li><li><p>系统环境变量</p></li><li><p>命令行参数</p></li></ol><h3 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h3><ul><li>bootstrap (. yml 或者 . properties)：boostrap 由 ApplicationContext 加载，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它，且 boostrap 里面的属性不能被覆盖</li><li>application (. yml 或者 . properties)：由ApplicatonContext 加载，用于 spring boot 项目的自动化配置</li></ul><h3 id="YAML-配置文件"><a href="#YAML-配置文件" class="headerlink" title="YAML 配置文件"></a>YAML 配置文件</h3><p>YAML 是一种人类可读的数据序列化语言，它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。 YAML 具有分层配置数据。YAML 配置和传统的 properties 配置相比有如下优势：</p><ol><li>配置有序，在一些特殊的场景下，配置有序很关键</li><li>支持数组，数组中的元素可以是基本数据类型也可以是对象</li><li>简洁</li></ol><p>相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。</p><h3 id="XML配置文件"><a href="#XML配置文件" class="headerlink" title="XML配置文件"></a>XML配置文件</h3><p>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。</p><h3 id="Spring-Profiles"><a href="#Spring-Profiles" class="headerlink" title="Spring Profiles"></a>Spring Profiles</h3><p>Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。因此，当应用程序在开发中运行时，只有某些 bean 可以加载，而在 PRODUCTION中，某些其他 bean 可以加载。</p><h2 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h2><h3 id="实现安全性"><a href="#实现安全性" class="headerlink" title="实现安全性"></a>实现安全性</h3><p>为了实现 Spring Boot 的安全性，使用 spring-boot-starter-security 依赖项，并且必须添加安全配置，它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter 并覆盖其方法。</p><h3 id="Spring-Security-和-Shiro-的优缺点"><a href="#Spring-Security-和-Shiro-的优缺点" class="headerlink" title="Spring Security 和 Shiro 的优缺点"></a>Spring Security 和 Shiro 的优缺点</h3><p>如果是 Spring Boot 项目，一般选择 Spring Security ，当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。</p><ol><li>Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架</li><li>Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单</li><li>Spring Security 功能强大；Shiro 功能简单</li></ol><h2 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h2><h3 id="什么是监视器"><a href="#什么是监视器" class="headerlink" title="什么是监视器"></a>什么是监视器</h3><p>Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问的REST 端点来检查状态。</p><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><h3 id="1-启动相关"><a href="#1-启动相关" class="headerlink" title="1.启动相关"></a>1.启动相关</h3><h4 id="1-1-SpringBootApplication"><a href="#1-1-SpringBootApplication" class="headerlink" title="1.1 @SpringBootApplication"></a>1.1 <code>@SpringBootApplication</code></h4><p>这个注解是 Spring Boot 项目的基石，创建 SpringBoot 项目之后会默认在主类加上。</p><p>我们可以把 <code>@SpringBootApplication</code>看作是 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。</p><p>根据 SpringBoot 官网，这三个注解的作用分别是：</p><ul><li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li><li><code>@ComponentScan</code>：扫描被<code>@Component</code> (<code>@Service</code>, <code>@Controller</code> ,<code>@Repository</code>)注解的 bean，注解默认会扫描==该类所在的包下所有的类==。</li><li><code>@Configuration</code>：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类</li></ul><h3 id="2-Spring-Bean-相关"><a href="#2-Spring-Bean-相关" class="headerlink" title="2. Spring Bean 相关"></a>2. Spring Bean 相关</h3><h4 id="2-1-Autowired"><a href="#2-1-Autowired" class="headerlink" title="2.1. @Autowired"></a>2.1. <code>@Autowired</code></h4><p>自动导入对象到类中，被注入进的类同样要被 Spring 容器管理。</p><p>例如：将Service 类注入到 Controller 类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/users"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> UserService userService;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-Component-Repository-Service-Controller"><a href="#2-2-Component-Repository-Service-Controller" class="headerlink" title="2.2. @Component, @Repository, @Service,  @Controller"></a>2.2. <code>@Component</code>, <code>@Repository</code>, <code>@Service</code>,  <code>@Controller</code></h4><p>我们一般使用 <code>@Autowired</code> 注解让 Spring 容器帮我们自动装配 bean，要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类，可以采用以下注解实现：</p><ul><li><code>@Component</code> ：通用的注解，可标注==任意类==为 <code>Spring</code> 组件。如果一个 bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li><li><code>@Repository</code> : 对应==持久层==即 Dao 层，主要用于数据库相关操作。</li><li><code>@Service</code> : 对应==服务层==，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li><code>@Controller</code> : 对应 Spring MVC ==控制层==，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li></ul><h4 id="2-3-RestController-Controller-ResponseBody"><a href="#2-3-RestController-Controller-ResponseBody" class="headerlink" title="2.3. @RestController,  @Controller + @ResponseBody"></a>2.3. <code>@RestController</code>,  <code>@Controller</code> + <code>@ResponseBody</code></h4><p><code>@RestController</code>注解是<code>@Controller和</code>@<code>ResponseBody</code>的合集,表示这是个控制器 bean,并且是==将函数的返回值直接填入 HTTP 响应体中==,是 REST 风格的控制器。</p><p>单独使用 <code>@Controller</code> 不加 <code>@ResponseBody</code>的话一般使用在要==返回一个视图==的情况，这种情况属于比较传统的 Spring MVC 的应用，对应于前后端不分离的情况。</p><p><code>@Controller</code> + <code>@ResponseBody</code> 返回 JSON 或 XML 形式数据，即==只返回对象==，对象数据直接以 JSON 或 XML 形式写入 HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是目前日常开发所接触的最常用的情况（前后端分离）。</p><blockquote><p>  如果在Spring4之前开发 RESTful Web服务的话，则需要使用<code>@Controller</code> 并结合<code>@ResponseBody</code>注解，也就是说<code>@Controller</code> +<code>@ResponseBody</code>= <code>@RestController</code>，<code>@RestController</code>是Spring 4 之后新加的注解</p></blockquote><p><code>@ResponseBody</code> 注解的作用是将 <code>Controller</code> 的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到HTTP 响应(Response)对象的 body 中，通常用来返回 JSON 或者 XML 数据，返回 JSON 数据的情况比较多。</p><h5 id="示例1-Controller-返回一个页面"><a href="#示例1-Controller-返回一个页面" class="headerlink" title="示例1: @Controller 返回一个页面"></a>示例1: @Controller 返回一个页面</h5><p>当我们需要直接在后端返回一个页面的时候，Spring 推荐使用 Thymeleaf 模板引擎。Spring MVC中<code>@Controller</code>中的方法可以直接返回模板名称，接下来 Thymeleaf 模板引擎会自动进行渲染,模板中的表达式支持Spring表达式语言（Spring EL)。如果需要用到 Thymeleaf 模板引擎，需要添加依赖。</p><p><strong>Maven:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>src/main/java/com/example/demo/controller/HelloController.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">greeting</span><span class="params">(@RequestParam(name = <span class="string">"name"</span>, required = <span class="keyword">false</span>, defaultValue = <span class="string">"World"</span>)</span> String name, Model model) </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"name"</span>, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>src/main/resources/templates/hello.html</code></p><p>Spring 默认会去 resources 目录下 templates 目录下找，所以建议把页面放在 resources/templates 目录下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Getting Started: Serving Web Content<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"'Hello, ' + $&#123;name&#125; + '!'"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>访问：<a href="http://localhost:8999/hello?name=team-c" target="_blank" rel="noopener">http://localhost:8999/hello?name=team-c</a> ，将看到下面的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, team-c!</span><br></pre></td></tr></table></figure><p>如果要对页面在templates目录下的hello文件夹中的页面话，返回页面的时候像下面这样写就可以了：</p><p><code>src/main/resources/templates/hello/hello.html</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">greeting</span><span class="params">(@RequestParam(name = <span class="string">"name"</span>, required = <span class="keyword">false</span>, defaultValue = <span class="string">"World"</span>)</span> String name, Model model) </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"name"</span>, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello/hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="示例2-Controller-ResponseBody-返回-JSON-格式数据"><a href="#示例2-Controller-ResponseBody-返回-JSON-格式数据" class="headerlink" title="示例2: @Controller+@ResponseBody 返回 JSON 格式数据"></a>示例2: @Controller+@ResponseBody 返回 JSON 格式数据</h5><p>SpringBoot 默认集成了 jackson ,因此不需要添加任何相关依赖。</p><p><code>src/main/java/com/example/demo/controller/Person.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//省略getter/setter ，有参和无参的construtor方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>src/main/java/com/example/demo/controller/HelloController.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">greeting</span><span class="params">(@RequestBody Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 post 请求访问 <a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a> ，body 中附带以下参数,后端会以json 格式将 person 对象返回。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"teamc"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="示例3-RestController-返回-JSON-格式数据"><a href="#示例3-RestController-返回-JSON-格式数据" class="headerlink" title="示例3: @RestController 返回 JSON 格式数据"></a>示例3: @RestController 返回 JSON 格式数据</h5><p>只需要将<code>HelloController</code>改为如下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">greeting</span><span class="params">(@RequestBody Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-Scope"><a href="#2-4-Scope" class="headerlink" title="2.4. @Scope"></a>2.4. <code>@Scope</code></h4><p>声明 Spring Bean 的作用域，使用方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"singleton"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">personSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>四种常见的 Spring Bean 的作用域：</strong></p><ul><li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li><li>prototype : 每次请求都会创建一个新的 bean 实例。</li><li>request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li><li>session : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li></ul><h4 id="2-5-Configuration"><a href="#2-5-Configuration" class="headerlink" title="2.5. Configuration"></a>2.5. <code>Configuration</code></h4><p>一般用来声明配置类，可以使用 <code>@Component</code>注解替代，不过使用<code>Configuration</code>注解声明配置类更加语义化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-处理常见的-HTTP-请求"><a href="#3-处理常见的-HTTP-请求" class="headerlink" title="3. 处理常见的 HTTP 请求"></a>3. 处理常见的 HTTP 请求</h3><p><strong>5 种常见的请求类型:</strong></p><ul><li><strong>GET</strong> ：请求从服务器获取特定资源。举个例子：<code>GET /users</code>（获取所有学生）</li><li><strong>POST</strong> ：在服务器上创建一个新的资源。举个例子：<code>POST /users</code>（创建学生）</li><li><strong>PUT</strong> ：更新服务器上的资源（客户端提供更新后的整个资源）。举个例子：<code>PUT /users/12</code>（更新编号为 12 的学生）</li><li><strong>DELETE</strong> ：从服务器删除特定的资源。举个例子：<code>DELETE /users/12</code>（删除编号为 12 的学生）</li><li><strong>PATCH</strong> ：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新），使用的比较少。</li></ul><h4 id="3-1-GET-请求"><a href="#3-1-GET-请求" class="headerlink" title="3.1. GET 请求"></a>3.1. GET 请求</h4><p><code>@GetMapping(&quot;users&quot;)</code> 等价于 <code>@RequestMapping(value=&quot;/users&quot;,method=RequestMethod.GET)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/users"</span>)</span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;List&lt;User&gt;&gt; getAllUsers() &#123;</span><br><span class="line"><span class="keyword">return</span> userRepository.findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-POST-请求"><a href="#3-2-POST-请求" class="headerlink" title="3.2. POST 请求"></a>3.2. POST 请求</h4><p><code>@PostMapping(&quot;users&quot;)</code> 等价于<code>@RequestMapping(value=&quot;/users&quot;,method=RequestMethod.POST)</code></p><p>关于<code>@RequestBody</code>注解的使用，在下面的“前后端传值”这块会讲到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/users"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title">createUser</span><span class="params">(@Valid @RequestBody UserCreateRequest userCreateRequest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userRespository.save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-PUT-请求"><a href="#3-3-PUT-请求" class="headerlink" title="3.3. PUT 请求"></a>3.3. PUT 请求</h4><p><code>@PutMapping(&quot;/users/{userId}&quot;)</code> 等价于<code>@RequestMapping(value=&quot;/users/{userId}&quot;,method=RequestMethod.PUT)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping</span>(<span class="string">"/users/&#123;userId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title">updateUser</span><span class="params">(@PathVariable(value = <span class="string">"userId"</span>)</span> Long userId, @Valid @RequestBody UserUpdateRequest userUpdateRequest) </span>&#123;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-DELETE-请求"><a href="#3-4-DELETE-请求" class="headerlink" title="3.4. DELETE 请求"></a>3.4. <strong>DELETE 请求</strong></h4><p><code>@DeleteMapping(&quot;/users/{userId}&quot;)</code>等价于<code>@RequestMapping(value=&quot;/users/{userId}&quot;,method=RequestMethod.DELETE)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping</span>(<span class="string">"/users/&#123;userId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity <span class="title">deleteUser</span><span class="params">(@PathVariable(value = <span class="string">"userId"</span>)</span> Long userId)</span>&#123;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-PATCH-请求"><a href="#3-5-PATCH-请求" class="headerlink" title="3.5. PATCH 请求"></a>3.5. <strong>PATCH 请求</strong></h4><p>一般实际项目中，我们都是 PUT 不够用了之后才用 PATCH 请求去更新数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PatchMapping</span>(<span class="string">"/profile"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity <span class="title">updateStudent</span><span class="params">(@RequestBody StudentUpdateRequest studentUpdateRequest)</span> </span>&#123;</span><br><span class="line">studentRepository.updateDetail(studentUpdateRequest);</span><br><span class="line"><span class="keyword">return</span> ResponseEntity.ok().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-前后端传值"><a href="#4-前后端传值" class="headerlink" title="4. 前后端传值"></a>4. 前后端传值</h3><p>掌握前后端传值的正确姿势，是开始 CRUD 的第一步！</p><h4 id="4-1-PathVariable-和-RequestParam"><a href="#4-1-PathVariable-和-RequestParam" class="headerlink" title="4.1. @PathVariable 和 @RequestParam"></a>4.1. <code>@PathVariable</code> 和 <code>@RequestParam</code></h4><p><code>@PathVariable</code>用于获取路径中的参数，<code>@RequestParam</code>用于获取查询中的参数（<code>?</code>后面的参数）。</p><p>举个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/klasses/&#123;klassId&#125;/teachers"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Teacher&gt; <span class="title">getKlassRelatedTeachers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         @PathVariable(<span class="string">"klassId"</span>)</span> Long klassId,</span></span><br><span class="line"><span class="function">         @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"type"</span>, required = <span class="keyword">false</span>)</span> String type ) </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们请求的 url 是：<code>/klasses/{123456}/teachers?type=web</code></p><p>那么我们服务获取到的数据就是：<code>klassId=123456,type=web</code>。</p><h4 id="4-2-RequestBody"><a href="#4-2-RequestBody" class="headerlink" title="4.2. @RequestBody"></a>4.2. <code>@RequestBody</code></h4><p>用于读取 Request 请求（可能是 POST,PUT,DELETE,GET 请求）的 body 部分并且<strong>Content-Type 为 application/json</strong> 格式的数据，接收到数据之后会自动将数据绑定到 Java 对象上去。系统会使用<code>HttpMessageConverter</code>或者自定义的<code>HttpMessageConverter</code>将请求的 body 中的 json 字符串转换为 java对象。</p><p>例如：我们有一个注册的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/sign-up"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity <span class="title">signUp</span><span class="params">(@RequestBody @Valid UserRegisterRequest userRegisterRequest)</span> </span>&#123;</span><br><span class="line">userService.save(userRegisterRequest);</span><br><span class="line"><span class="keyword">return</span> ResponseEntity.ok().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UserRegisterRequest</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRegisterRequest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@FullName</span></span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String fullName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发送 post 请求到这个接口，并且 body 携带 JSON 数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"userName"</span>:<span class="string">"coder"</span>,</span><br><span class="line">    <span class="attr">"fullName"</span>:<span class="string">"shuangkou"</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">"123456"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们的后端就可以直接把 json 格式的数据映射到我们的 <code>UserRegisterRequest</code> 类上。</p><blockquote><p>  需要注意的是：<strong>一个请求方法只可以有一个<code>@RequestBody</code>，但是可以有多个<code>@RequestParam</code>和<code>@PathVariable</code></strong>。如果你的方法必须要用两个 <code>@RequestBody</code>来接受数据的话，大概率是你的数据库设计或者系统设计出问题了</p></blockquote><h3 id="5-读取配置信息"><a href="#5-读取配置信息" class="headerlink" title="5. 读取配置信息"></a>5. 读取配置信息</h3><p>很多时候我们需要将一些常用的配置信息比如阿里云 oss、发送短信、微信认证的相关配置信息等等放到配置文件中，下面我们来看一下 Spring 为我们提供了哪些方式帮助我们从配置文件中读取这些配置信息。</p><p>数据源<code>application.yml</code>内容如下：：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wuhan2020:</span> <span class="number">2020</span><span class="string">年初武汉爆发了新型冠状病毒，疫情严重，但是，我相信一切都会过去！武汉加油！中国加油！</span></span><br><span class="line"></span><br><span class="line"><span class="attr">my-profile:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">Guide哥</span></span><br><span class="line">  <span class="attr">email:</span> <span class="string">koushuangbwcx@163.com</span></span><br><span class="line"></span><br><span class="line"><span class="attr">library:</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">湖北武汉加油中国加油</span></span><br><span class="line">  <span class="attr">books:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">天才基本法</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">二十二岁的林朝夕在父亲确诊阿尔茨海默病这天，得知自己暗恋多年的校园男神裴之即将出国深造的消息——对方考取的学校，恰是父亲当年为她放弃的那所。</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">时间的秩序</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">为什么我们记得过去，而非未来？时间“流逝”意味着什么？是我们存在于时间之内，还是时间存在于我们之中？卡洛·罗韦利用诗意的文字，邀请我们思考这一亘古难题——时间的本质。</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">了不起的我</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">如何养成一个新习惯？如何让心智变得更成熟？如何拥有高质量的关系？</span> <span class="string">如何走出人生的艰难时刻？</span></span><br></pre></td></tr></table></figure><h4 id="5-1-value-常用"><a href="#5-1-value-常用" class="headerlink" title="5.1. @value(常用)"></a>5.1. <code>@value</code>(常用)</h4><p>使用 <code>@Value(&quot;${property}&quot;)</code> 读取比较简单的配置信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;wuhan2020&#125;"</span>)</span><br><span class="line">String wuhan2020;</span><br></pre></td></tr></table></figure><blockquote><p>  需要注意的是<code>@value</code>这种方式是不被推荐的，Spring 比较建议的是下面几种读取配置信息的方式。</p></blockquote><h4 id="5-2-ConfigurationProperties-常用"><a href="#5-2-ConfigurationProperties-常用" class="headerlink" title="5.2. @ConfigurationProperties(常用)"></a>5.2. <code>@ConfigurationProperties</code>(常用)</h4><p>通过<code>@ConfigurationProperties</code>读取配置信息并与 bean 绑定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"library"</span>)</span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LibraryProperties</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotEmpty</span></span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Book&gt; books;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@ToString</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        String description;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//省略getter/setter</span></span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  <code>LibraryProperties</code>类上加了<code>@Component</code>注解，我们可以像使用普通 bean 一样将其注入到类中使用。</p></blockquote><h4 id="5-3-PropertySource（不常用）"><a href="#5-3-PropertySource（不常用）" class="headerlink" title="5.3. PropertySource（不常用）"></a>5.3. <code>PropertySource</code>（不常用）</h4><p><code>@PropertySource</code>读取指定 properties 文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:website.properties"</span>)</span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebSite</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;url&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//省略getter/setter</span></span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> WebSite webSite;</span><br><span class="line">System.out.println(webSite.getUrl());<span class="comment">//https://javaguide.cn/</span></span><br></pre></td></tr></table></figure><h3 id="6-JSR参数校验"><a href="#6-JSR参数校验" class="headerlink" title="6. JSR参数校验"></a>6. JSR参数校验</h3><p>数据的校验的重要性就不用说了，即使在前端对数据进行校验的情况下，我们还是要对传入后端的数据再进行一遍校验，避免用户绕过浏览器直接通过一些 HTTP 工具直接向后端请求一些违法数据。</p><p><strong>JSR(Java Specification Requests）</strong> 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在我们 JavaBean 的属性上面，这样就可以在需要校验的时候进行校验了。校验的时候我们实际用的是 <strong>Hibernate Validator</strong> 框架。SpringBoot 项目的 spring-boot-starter-web 依赖中已经有 hibernate-validator 包，不需要引用相关依赖。</p><blockquote><p>  需要注意的是：<strong>所有的注解，推荐使用 JSR 注解，即<code>javax.validation.constraints</code>，而不是<code>org.hibernate.validator.constraints</code></strong></p></blockquote><h4 id="6-1-一些常用的字段验证的注解"><a href="#6-1-一些常用的字段验证的注解" class="headerlink" title="6.1. 一些常用的字段验证的注解"></a>6.1. 一些常用的字段验证的注解</h4><ul><li><code>@NotEmpty</code> 被注释的字符串的不能为 null 也不能为空</li><li><code>@NotBlank</code> 被注释的字符串非 null，并且必须包含一个非空白字符</li><li><code>@Null</code> 被注释的元素必须为 null</li><li><code>@NotNull</code> 被注释的元素必须不为 null</li><li><code>@AssertTrue</code> 被注释的元素必须为 true</li><li><code>@AssertFalse</code> 被注释的元素必须为 false</li><li><code>@Pattern(regex=,flag=)</code>被注释的元素必须符合指定的正则表达式</li><li><code>@Email</code> 被注释的元素必须是 Email 格式。</li><li><code>@Min(value)</code>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li><li><code>@Max(value)</code>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li><li><code>@DecimalMin(value)</code>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li><li><code>@DecimalMax(value)</code> 被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li><li><code>@Size(max=, min=)</code>被注释的元素的大小必须在指定的范围内</li><li><code>@Digits (integer, fraction)</code>被注释的元素必须是一个数字，其值必须在可接受的范围内</li><li><code>@Past</code>被注释的元素必须是一个过去的日期</li><li><code>@Future</code> 被注释的元素必须是一个将来的日期</li></ul><h4 id="6-2-验证请求体-RequestBody"><a href="#6-2-验证请求体-RequestBody" class="headerlink" title="6.2. 验证请求体(RequestBody)"></a>6.2. 验证请求体(RequestBody)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"classId 不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String classId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Size</span>(max = <span class="number">33</span>)</span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"name 不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pattern</span>(regexp = <span class="string">"((^Man$|^Woman$|^UGM$))"</span>, message = <span class="string">"sex 值不在可选范围"</span>)</span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"sex 不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email</span>(message = <span class="string">"email 格式不正确"</span>)</span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"email 不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在需要验证的参数上加上了<code>@Valid</code>注解，如果验证失败，它将抛出<code>MethodArgumentNotValidException</code>。默认情况下，Spring会将此异常转换为HTTP Status 400（错误请求）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/api"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/person"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Person&gt; <span class="title">getPerson</span><span class="params">(@RequestBody @Valid Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().body(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-3-验证请求参数-Path-Variables-和-Request-Parameters"><a href="#6-3-验证请求参数-Path-Variables-和-Request-Parameters" class="headerlink" title="6.3. 验证请求参数(Path Variables 和 Request Parameters)"></a>6.3. 验证请求参数(Path Variables 和 Request Parameters)</h4><p>一定不要忘记在类上加上 <code>Validated</code> 注解了，这个参数可以告诉 Spring 去校验方法参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/api"</span>)</span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/person/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Integer&gt; <span class="title">getPersonByID</span><span class="params">(@Valid @PathVariable(<span class="string">"id"</span>)</span> @<span class="title">Max</span><span class="params">(value = <span class="number">5</span>,message = <span class="string">"超过 id 的范围了"</span>)</span> Integer id) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().body(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-全局处理-Controller-层异常"><a href="#7-全局处理-Controller-层异常" class="headerlink" title="7. 全局处理 Controller 层异常"></a>7. 全局处理 Controller 层异常</h3><p><strong>相关注解：</strong></p><ol><li><code>@ControllerAdvice</code> :注解定义全局异常处理类</li><li><code>@ExceptionHandler</code> :注解声明异常处理方法</li></ol><h3 id="8-JPA-相关"><a href="#8-JPA-相关" class="headerlink" title="8. JPA 相关"></a>8. JPA 相关</h3><h4 id="8-1-创建表"><a href="#8-1-创建表" class="headerlink" title="8.1. 创建表"></a>8.1. 创建表</h4><p><code>@Entity</code>声明一个类对应一个数据库实体。</p><p><code>@Table</code> 设置表名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"role"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="comment">//省略getter/setter......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-创建主键"><a href="#8-2-创建主键" class="headerlink" title="8.2. 创建主键"></a>8.2. 创建主键</h4><p><code>@Id</code> ：声明一个字段为主键。</p><p>使用<code>@Id</code>声明之后，我们还需要定义主键的生成策略。我们可以使用 <code>@GeneratedValue</code> 指定主键生成策略。</p><p><strong>1.通过 <code>@GeneratedValue</code>直接使用 JPA 内置提供的四种主键生成策略来指定主键生成策略。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure><p>JPA 使用枚举定义了 4 中常见的主键生成策略，<code>@GeneratedValue</code>注解默认使用的策略是<code>GenerationType.AUTO</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> GenerationType &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用一个特定的数据库表格来保存主键</span></span><br><span class="line"><span class="comment">     * 持久化引擎通过关系数据库的一张特定的表格来生成主键,</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *在某些数据库中,不支持主键自增长,比如Oracle、PostgreSQL其提供了一种叫做"序列(sequence)"的机制生成主键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SEQUENCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主键自增长</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IDENTITY,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *把主键生成策略交给持久化引擎(persistence engine),</span></span><br><span class="line"><span class="comment">     *持久化引擎会根据数据库在以上三种主键生成 策略中选择其中一种</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AUTO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  一般使用 MySQL 数据库的话，使用<code>GenerationType.IDENTITY</code>策略比较普遍一点（分布式系统的话需要另外考虑使用分布式 ID）。</p></blockquote><p><strong>2.我们可以通过 <code>@GenericGenerator</code>自己声明一个主键策略，然后 <code>@GeneratedValue</code>使用这个策略</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator = <span class="string">"IdentityIdGenerator"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name = <span class="string">"IdentityIdGenerator"</span>, strategy = <span class="string">"identity"</span>)</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure><p>jpa 提供的主键生成策略有如下几种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultIdentifierGeneratorFactory</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">MutableIdentifierGeneratorFactory</span>, <span class="title">Serializable</span>, <span class="title">ServiceRegistryAwareService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultIdentifierGeneratorFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        register( <span class="string">"uuid2"</span>, UUIDGenerator<span class="class">.<span class="keyword">class</span> )</span>;</span><br><span class="line">        register( <span class="string">"guid"</span>, GUIDGenerator<span class="class">.<span class="keyword">class</span> )</span>;   <span class="comment">// can be done with UUIDGenerator + strategy</span></span><br><span class="line">        register( <span class="string">"uuid"</span>, UUIDHexGenerator<span class="class">.<span class="keyword">class</span> )</span>;   <span class="comment">// "deprecated" for new use</span></span><br><span class="line">        register( <span class="string">"uuid.hex"</span>, UUIDHexGenerator<span class="class">.<span class="keyword">class</span> )</span>;  <span class="comment">// uuid.hex is deprecated</span></span><br><span class="line">        register( <span class="string">"assigned"</span>, Assigned<span class="class">.<span class="keyword">class</span> )</span>;</span><br><span class="line">        register( <span class="string">"identity"</span>, IdentityGenerator<span class="class">.<span class="keyword">class</span> )</span>;</span><br><span class="line">        register( <span class="string">"select"</span>, SelectGenerator<span class="class">.<span class="keyword">class</span> )</span>;</span><br><span class="line">        register( <span class="string">"sequence"</span>, SequenceStyleGenerator<span class="class">.<span class="keyword">class</span> )</span>;</span><br><span class="line">        register( <span class="string">"seqhilo"</span>, SequenceHiLoGenerator<span class="class">.<span class="keyword">class</span> )</span>;</span><br><span class="line">        register( <span class="string">"increment"</span>, IncrementGenerator<span class="class">.<span class="keyword">class</span> )</span>;</span><br><span class="line">        register( <span class="string">"foreign"</span>, ForeignGenerator<span class="class">.<span class="keyword">class</span> )</span>;</span><br><span class="line">        register( <span class="string">"sequence-identity"</span>, SequenceIdentityGenerator<span class="class">.<span class="keyword">class</span> )</span>;</span><br><span class="line">        register( <span class="string">"enhanced-sequence"</span>, SequenceStyleGenerator<span class="class">.<span class="keyword">class</span> )</span>;</span><br><span class="line">        register( <span class="string">"enhanced-table"</span>, TableGenerator<span class="class">.<span class="keyword">class</span> )</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String strategy, Class generatorClass)</span> </span>&#123;</span><br><span class="line">        LOG.debugf( <span class="string">"Registering IdentifierGenerator strategy [%s] -&gt; [%s]"</span>, strategy, generatorClass.getName() );</span><br><span class="line">        <span class="keyword">final</span> Class previous = generatorStrategyToClassNameMap.put( strategy, generatorClass );</span><br><span class="line">        <span class="keyword">if</span> ( previous != <span class="keyword">null</span> ) &#123;</span><br><span class="line">        LOG.debugf( <span class="string">"    - overriding [%s]"</span>, previous.getName() );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-设置字段类型"><a href="#8-3-设置字段类型" class="headerlink" title="8.3. 设置字段类型"></a>8.3. 设置字段类型</h4><p><code>@Column</code> 声明字段。</p><p>示例：</p><p>设置属性 userName 对应的数据库字段名为 user_name，长度为 32，非空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Column</span>(name = <span class="string">"user_name"</span>, nullable = <span class="keyword">false</span>, length=<span class="number">32</span>)</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br></pre></td></tr></table></figure><p>设置字段类型并且加默认值，这个还是挺常用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Column</span>(columnDefinition = <span class="string">"tinyint(1) default 1"</span>)</span><br><span class="line"><span class="keyword">private</span> Boolean enabled;</span><br></pre></td></tr></table></figure><h4 id="8-4-指定不持久化特定字段"><a href="#8-4-指定不持久化特定字段" class="headerlink" title="8.4. 指定不持久化特定字段"></a>8.4. 指定不持久化特定字段</h4><p><code>@Transient</code> ：声明不需要与数据库映射的字段，在保存的时候不需要保存进数据库 。</p><p>如果我们想让<code>secrect</code> 这个字段不被持久化，可以使用 <code>@Transient</code>关键字声明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Entity(name=<span class="string">"USER"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> String secrect; <span class="comment">// not persistent because of @Transient</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 <code>@Transient</code>关键字声明， 还可以采用下面几种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String secrect; <span class="comment">// not persistent because of static</span></span><br><span class="line"><span class="keyword">final</span> String secrect = “Satish”; <span class="comment">// not persistent because of final</span></span><br><span class="line"><span class="keyword">transient</span> String secrect; <span class="comment">// not persistent because of transient</span></span><br></pre></td></tr></table></figure><p>一般使用注解的方式比较多。</p><h4 id="8-5-声明大字段"><a href="#8-5-声明大字段" class="headerlink" title="8.5. 声明大字段"></a>8.5. 声明大字段</h4><p><code>@Lob</code>:声明某个字段为大字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Lob</span></span><br><span class="line"><span class="keyword">private</span> String content;</span><br></pre></td></tr></table></figure><p>更详细的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Lob</span></span><br><span class="line"><span class="comment">//指定 Lob 类型数据的获取策略， FetchType.EAGER 表示非延迟 加载，而 FetchType. LAZY 表示延迟加载 ；</span></span><br><span class="line"><span class="meta">@Basic</span>(fetch = FetchType.EAGER)</span><br><span class="line"><span class="comment">//columnDefinition 属性指定数据表对应的 Lob 字段类型</span></span><br><span class="line"><span class="meta">@Column</span>(name = <span class="string">"content"</span>, columnDefinition = <span class="string">"LONGTEXT NOT NULL"</span>)</span><br><span class="line"><span class="keyword">private</span> String content;</span><br></pre></td></tr></table></figure><h4 id="8-6-创建枚举类型的字段"><a href="#8-6-创建枚举类型的字段" class="headerlink" title="8.6. 创建枚举类型的字段"></a>8.6. 创建枚举类型的字段</h4><p>可以使用枚举类型的字段，不过枚举字段要用<code>@Enumerated</code>注解修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Gender &#123;</span><br><span class="line">    MALE(<span class="string">"男性"</span>),</span><br><span class="line">    FEMALE(<span class="string">"女性"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    Gender(String str)&#123;</span><br><span class="line">        value=str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"role"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="meta">@Enumerated</span>(EnumType.STRING)</span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line">    省略getter/setter......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据库里面对应存储的是 MAIL/FEMAIL。</p><h3 id="9-事务-Transactional"><a href="#9-事务-Transactional" class="headerlink" title="9. 事务 @Transactional"></a>9. 事务 <code>@Transactional</code></h3><p>在要开启事务的方法上使用<code>@Transactional</code>注解即可!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">save</span>() </span>&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道 Exception 分为运行时异常和非运行时异常。在<code>@Transactional</code>注解中如果不配置<code>rollbackFor</code>属性,那么事物只会在遇到<code>RuntimeException</code>的时候才会回滚,加上<code>rollbackFor=Exception.class</code>,可以让事物在遇到非运行时异常时也回滚。</p><p><code>@Transactional</code> 注解一般用在可以作用在类或者方法上。</p><ul><li><strong>作用于类</strong>：当把<code>@Transactional</code> 注解放在类上时，表示所有该类的<code>public</code> 方法都配置相同的事务属性信息。</li><li><strong>作用于方法</strong>：当类配置了<code>@Transactional</code>，方法也配置了<code>@Transactional</code>，方法的事务会覆盖类的事务配置信息。</li></ul><h3 id="10-json-数据处理"><a href="#10-json-数据处理" class="headerlink" title="10. json 数据处理"></a>10. json 数据处理</h3><h4 id="10-1-过滤-json-数据"><a href="#10-1-过滤-json-数据" class="headerlink" title="10.1. 过滤 json 数据"></a>10.1. 过滤 json 数据</h4><p><code>@JsonIgnoreProperties</code> 作用在类上用于过滤掉特定字段不返回或者不解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成json时将userRoles属性过滤</span></span><br><span class="line"><span class="meta">@JsonIgnoreProperties</span>(&#123;<span class="string">"userRoles"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String fullName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;UserRole&gt; userRoles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@JsonIgnore</code>一般用于类的属性上，作用和上面的<code>@JsonIgnoreProperties</code> 一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String fullName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">   <span class="comment">//生成json时将userRoles属性过滤</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;UserRole&gt; userRoles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-2-格式化-json-数据"><a href="#10-2-格式化-json-数据" class="headerlink" title="10.2. 格式化 json 数据"></a>10.2. 格式化 json 数据</h4><p><code>@JsonFormat</code>一般用来格式化 json 数据。：</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat</span>(shape=JsonFormat.Shape.STRING, pattern=<span class="string">"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"</span>, timezone=<span class="string">"GMT"</span>)</span><br><span class="line"><span class="keyword">private</span> Date date;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;配置相关&quot;&gt;&lt;a href=&quot;#配置相关&quot; class=&quot;headerlink&quot; title=&quot;配置相关&quot;&gt;&lt;/a&gt;配置相关&lt;/h2&gt;&lt;h3 id=&quot;JavaConfig&quot;&gt;&lt;a href=&quot;#JavaConfig&quot; class=&quot;headerlink&quot; title=&quot;JavaConfig&quot;&gt;&lt;/a&gt;JavaConfig&lt;/h3&gt;&lt;p&gt;Spring JavaConfig 是 Spring 社区的产品，它提供了配置 Spring IoC 容器的纯 Java 方法，因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;面向对象的配置。&lt;/p&gt;
&lt;p&gt;由于配置被定义为 JavaConfig 中的类，因此用户可以充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean 方法等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;减少或消除 XML 配置。&lt;/p&gt;
&lt;p&gt;许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;类型安全和重构友好。&lt;/p&gt;
&lt;p&gt;JavaConfig 提供了一种类型安全的方法来配置 Spring容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java框架" scheme="http://yoursite.com/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Spring基础</title>
    <link href="http://yoursite.com/2020/06/23/Java%E6%A1%86%E6%9E%B6/Spring/"/>
    <id>http://yoursite.com/2020/06/23/Java%E6%A1%86%E6%9E%B6/Spring/</id>
    <published>2020-06-23T12:50:49.000Z</published>
    <updated>2020-07-01T10:56:42.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring框架的七大模块"><a href="#Spring框架的七大模块" class="headerlink" title="Spring框架的七大模块"></a>Spring框架的七大模块</h2><ul><li><strong>Spring Core</strong>：框架的最基础部分，提供 IoC 容器，对 bean 进行管理。</li><li><strong>Spring Context</strong>：继承BeanFactory，提供上下文信息，扩展出JNDI、EJB、电子邮件、国际化等功能。</li><li><strong>Spring DAO</strong>：提供了JDBC的抽象层，还提供了声明性事务管理方法。</li><li><strong>Spring ORM</strong>：提供了JPA、JDO、Hibernate、MyBatis 等ORM映射层.</li><li><strong>Spring AOP</strong>：集成了所有AOP功能</li><li><strong>Spring Web</strong>：提供了基础的 Web 开发的上下文信息，现有的Web框架，如JSF、Tapestry、Structs等，提供了集成</li><li><strong>Spring Web MVC</strong>：提供了 Web 应用的 Model-View-Controller 全功能实现。</li></ul><a id="more"></a><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><h3 id="概念梳理"><a href="#概念梳理" class="headerlink" title="概念梳理"></a>概念梳理</h3><h4 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h4><ol><li>AOP 是 ==Aspect Oriented Programming（面向切面编程）== 的简称，和OOP（面向对象编程）一样是一种编程思想，是对OOP的一种补充。</li><li>AOP旨在将横切关注点（crosscutting concern）从业务主体逻辑中进行剥离，实现关注点分离，以提高程序的模块化程度（及业务模块只需关注业务逻辑，无需关注日志、安全、事务等通用逻辑）</li></ol><h4 id="常见术语"><a href="#常见术语" class="headerlink" title="常见术语"></a>常见术语</h4><p>AOP有自己的一套术语，我们必须了解一下这些行话，才能更好地理解AOP。为了方便大家理解，下面将用电表抄表员作为例子。</p><ol><li>通知 (Advice)<ul><li>电表抄表员的工作是登记每家每户的电量并汇报给电力公司，记录电量是抄表员的主要工作，类似的，==切面需要完成的工作称为通知==。</li><li>定义了切面在切点附近的操作 （什么时候做什么事）。</li><li>常见的通知类型有：before、after、after-returning、around等</li></ul></li><li>连接点 (JoinPoint)<ul><li>电力公司为整个城市提供供电，每家都有一个电表，每一家都是抄表员的潜在目标。同样的，我们的==程序也有千万的时间点可以执行通知，这些时间点被称为连接点==。</li><li>连接点指程序运行时允许插入切面的一个点，可以是一个函数、一个包路径、一个类、或者抛出的异常</li></ul></li><li>切点（PointCut）<ul><li>如果让一位抄表员访问所有电力公司的住户是不现实的，一般每一个抄表员仅负责某一个区域的住户，同样的，==切点用于指定连接点的范围==。</li><li>切点用于定义切面的位置，也就是捕获哪些连接点的调用然后执行”通知”的操作（什么地点）。</li></ul></li><li>切面（Aspect）<ul><li>当抄表员开始一天的工作时，他知道自己要做的事情（记录电量）以及去哪里收集信息（去哪些地点），这个==聚合信息称为切面==。</li><li>切面是切点和通知的聚合，一般是一个横跨多各类的通用逻辑抽象而成的类，切面类会定义在什么时间、什么地点、做什么事</li></ul></li><li>目标对象( Target )<ul><li>指被切面织入的对象</li></ul></li><li>引入（Introduction）<ul><li>引入允许我们向现有的类添加新方法或属性。</li></ul></li><li>织入（Weaving）<ul><li>织入是把切面应用到切点对应的连接点的过程。切面在指定连接点被织入到目标对象中。</li></ul></li></ol><h2 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h2><blockquote><p>  IoC - Inversion of Control, 控制反转。</p></blockquote><h3 id="初识IoC"><a href="#初识IoC" class="headerlink" title="初识IoC"></a>初识IoC</h3><h4 id="什么是控制反转？"><a href="#什么是控制反转？" class="headerlink" title="什么是控制反转？"></a>什么是控制反转？</h4><p>控制反转就是把创建和管理 bean 的过程转移给了第三方。而这个第三方，就是 Spring IoC Container，对于 IoC 来说，最重要的就是<strong>容器</strong>。</p><p>容器负责创建、配置和管理 bean，也就是它管理着 bean 的生命，控制着 bean 的依赖注入。通俗点讲，因为项目中每次创建对象是很麻烦的，所以使用 Spring IoC 容器来管理这些对象，需要的时候就直接用，不用管它是怎么来的、什么时候要销毁，只管用就好了。</p><p>举个例子，就好像父母没时间管孩子，就把小朋友交给托管所，就安心的去上班而不用管孩子了。托儿所，就是第三方容器，负责管理小朋友的吃喝玩乐；父母，相当于程序员，只管接送孩子，不用管他们吃喝。</p><h4 id="bean-是什么？"><a href="#bean-是什么？" class="headerlink" title="bean 是什么？"></a><code>bean</code> 是什么？</h4><p>Bean 其实就是包装了的 Object，无论是控制反转还是依赖注入，它们的主语都是 Object，而 bean 就是由第三方包装好了的 Object。（想一下别人送礼物给你的时候都是要包装一下的，自己造的就免了。</p><p>Bean 是 Spring 的主角，有种说法叫 Spring 就是面向 bean 的编程（Bean Oriented Programming, BOP）。</p><h4 id="几个关键问题："><a href="#几个关键问题：" class="headerlink" title="几个关键问题："></a>几个关键问题：</h4><h5 id="何为控制，控制的是什么？"><a href="#何为控制，控制的是什么？" class="headerlink" title="何为控制，控制的是什么？"></a>何为控制，控制的是什么？</h5><p>答：是 bean 的创建、管理的权利，控制 bean 的整个生命周期。</p><h5 id="何为反转，反转了什么？"><a href="#何为反转，反转了什么？" class="headerlink" title="何为反转，反转了什么？"></a>何为反转，反转了什么？</h5><p>答：把这个权利交给了 Spring 容器，而不是自己去控制，就是反转。由之前的自己主动创建对象，变成现在被动接收别人给我们的对象的过程，这就是反转。</p><p>举个生活中的例子，主动投资和被动投资。</p><p>自己炒股、选股票的人就是主动投资，主动权掌握在自己的手中；而买基金的人就是被动投资，把主动权交给了基金经理，除非你把这个基金卖了，否则具体选哪些投资产品都是基金经理决定的。</p><h3 id="IoC-容器"><a href="#IoC-容器" class="headerlink" title="IoC 容器"></a>IoC 容器</h3><h4 id="IoC容器的设计"><a href="#IoC容器的设计" class="headerlink" title="IoC容器的设计"></a>IoC容器的设计</h4><p>使用 <code>ApplicationContext</code>，它是 <code>BeanFactory</code> 的子类，更好的补充并实现了 <code>BeanFactory</code> 。</p><p><code>BeanFactory</code> 简单粗暴，可以理解为 HashMap：</p><ul><li>Key - bean name</li><li>Value - bean object</li></ul><p>但它一般只有 get, put 两个功能，所以称之为“低级容器”。而 <code>ApplicationContext</code> 多了很多功能，因为它继承了多个接口，可称之为“高级容器”。</p><p><code>ApplicationContext</code> 的里面有两个具体的实现子类，用来读取配置配件的：</p><ul><li><code>ClassPathXmlApplicationContext</code> - 从 class path 中加载配置文件，更常用一些；</li><li><code>FileSystemXmlApplicationContext</code> - 从本地文件中加载配置文件，不是很常用，如果再到 Linux 环境中，还要改路径，不是很方便。</li></ul><p>当我们点开 <code>ClassPathXmlApplicationContext</code> 时，发现它并不是直接继承 <code>ApplicationContext</code> 的，它有很多层的依赖关系，每层的子类都是对父类的补充实现。而再往上找，发现最上层的 class 回到了 <code>BeanFactory</code>，所以它非常重要。</p><blockquote><p>  要注意，Spring 中还有个 <code>FactoryBean</code>，两者并没有特别的关系，只是名字比较接近，所以不要弄混了顺序。</p></blockquote><h4 id="IoC容器的初始化"><a href="#IoC容器的初始化" class="headerlink" title="IoC容器的初始化"></a>IoC容器的初始化</h4><p>Spring IOC容器初始化的核心过程可以简单的如下图表示，主要有四个步骤（还有一些如：后置加载器，国际化，事件广播器等一些过程不展开）：</p><ol><li>Bean定义的定位，Bean 可能定义在XML中，或者一个注解，或者其他形式。这些都被用Resource来定位，读取Resource获取BeanDefinition 注册到 Bean定义注册表中。</li><li>第一次向容器getBean操作会触发Bean的创建过程,实列化一个Bean时 ,根据BeanDefinition中类信息等实列化Bean。</li><li>将实列化的Bean放到单列Bean缓存内。</li><li>此后再次获取向容器getBean就会从缓存中获取。</li></ol><h3 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h3><h4 id="Bean的注入方式"><a href="#Bean的注入方式" class="headerlink" title="Bean的注入方式"></a>Bean的注入方式</h4><p>目前主要有五种注入方式：SET注入，构造器注入，静态工厂，实例工厂，注解方式</p><h4 id="Bean解析注册过程"><a href="#Bean解析注册过程" class="headerlink" title="Bean解析注册过程"></a>Bean解析注册过程</h4><p>这个过程完成Bean的从配置文件到解析注册成bean工厂的过程（对应代码在AbstactApplicationContext.obtainFreshBeanFactory）</p><ol><li>通过读取XML配置文件获取 Resource 资源，获取这个资源包含了路径config/spring/local/appcontext-client.xml 文件下定义的BeanDefinition信息。</li><li>创建一个 BeanFactory，这里使用 DefaultListableBeanFactory。</li><li>创建一个载入 BeanDefinition 的解读器，这里使用 XmlBeanDefinitionReader 来载入 XML 文件形式 BeanDefinition，通过一个回调配置给 factory。</li><li>从定义好的资源位置读入配置信息，具体的解析过程由 XmlBeanDefinitionReader 的 loadBeanDefinitions() 方法来完成。完成整个载入和注册 Bean 定义之后，需要的 IoC 容器就建立起来可以直接使用了。</li></ol><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><blockquote><p>  DI - dependency injection, 依赖注入</p></blockquote><h4 id="何为依赖，依赖什么？"><a href="#何为依赖，依赖什么？" class="headerlink" title="何为依赖，依赖什么？"></a>何为依赖，依赖什么？</h4><p>程序运行需要依赖外部的资源，提供程序内对象的所需要的数据、资源。</p><h4 id="何为注入，注入什么？"><a href="#何为注入，注入什么？" class="headerlink" title="何为注入，注入什么？"></a>何为注入，注入什么？</h4><p>配置文件把资源从外部注入到内部，容器加载了外部的文件、对象、数据，然后把这些资源注入给程序内的对象，维护了程序内外对象之间的依赖关系。</p><p>所以说，==控制反转是通过依赖注入实现的==。但是它们是有差别的，像是<strong>从不同角度描述的同一件事</strong>：</p><ul><li>IoC 是设计思想，DI 是具体的实现方式</li><li>IoC 是理论，DI 是实践</li></ul><p>从而实现对象之间的解藕。</p><p><strong>当然，IoC 也可以通过其他的方式来实现，而 DI 只是 Spring 的选择。</strong></p><p>IoC 和 DI 也并非 Spring 框架提出来的，Spring 只是应用了这个设计思想和理念到自己的框架里去。</p><h3 id="使用-IoC-的好处"><a href="#使用-IoC-的好处" class="headerlink" title="使用 IoC 的好处"></a>使用 IoC 的好处</h3><p>==解藕==。</p><p>它把对象之间的依赖关系转成用配置文件来管理，由 Spring IoC Container 来管理。</p><p>在项目中，底层的实现都是由很多个对象组成的，对象之间彼此合作实现项目的业务逻辑。但是，很多很多对象紧密结合在一起，一旦有一方出问题了，必然会对其他对象有所影响，所以才有了解藕的这种设计思想。</p><h2 id="Spring-创建对象的过程"><a href="#Spring-创建对象的过程" class="headerlink" title="Spring 创建对象的过程"></a>Spring 创建对象的过程</h2><p>通过 <code>ApplicationContext</code> 这个 IoC 容器的入口，用它的两个具体的实现子类，从 class path 或者 file path 中读取数据，用 <code>getBean()</code> 获取具体的 bean instance。</p><p>那使用 Spring 到底省略了我们什么工作？</p><p>答：<code>new 的过程</code>。把 new 的过程交给第三方来创建、管理，这就是「解藕」。Spring 也是用的 <code>set()</code> 方法，它只不过提供了一套更加完善的实现机制而已。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Spring框架的七大模块&quot;&gt;&lt;a href=&quot;#Spring框架的七大模块&quot; class=&quot;headerlink&quot; title=&quot;Spring框架的七大模块&quot;&gt;&lt;/a&gt;Spring框架的七大模块&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Spring Core&lt;/strong&gt;：框架的最基础部分，提供 IoC 容器，对 bean 进行管理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spring Context&lt;/strong&gt;：继承BeanFactory，提供上下文信息，扩展出JNDI、EJB、电子邮件、国际化等功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spring DAO&lt;/strong&gt;：提供了JDBC的抽象层，还提供了声明性事务管理方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spring ORM&lt;/strong&gt;：提供了JPA、JDO、Hibernate、MyBatis 等ORM映射层.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spring AOP&lt;/strong&gt;：集成了所有AOP功能&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spring Web&lt;/strong&gt;：提供了基础的 Web 开发的上下文信息，现有的Web框架，如JSF、Tapestry、Structs等，提供了集成&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spring Web MVC&lt;/strong&gt;：提供了 Web 应用的 Model-View-Controller 全功能实现。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java框架" scheme="http://yoursite.com/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Mabatis基础</title>
    <link href="http://yoursite.com/2020/06/23/Java%E6%A1%86%E6%9E%B6/Mybatis/"/>
    <id>http://yoursite.com/2020/06/23/Java%E6%A1%86%E6%9E%B6/Mybatis/</id>
    <published>2020-06-23T12:50:49.000Z</published>
    <updated>2020-07-01T11:26:28.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Mybatis 最初配置信息是基于 XML ,映射语句(SQL)也是定义在 XML 中的。而到了 MyBatis 3提供了新的基于注解的配置。mybatis提供的注解有很多，大致可以分为以下几类： </p><ul><li><p><strong>增删改查：</strong>@Insert、@Update、@Delete、@Select、@MapKey、@Options、@SelelctKey、@Param、@InsertProvider、@UpdateProvider、@DeleteProvider、@SelectProvider </p></li><li><p><strong>结果集映射：</strong>@Results、@Result、@ResultMap、@ResultType、@ConstructorArgs、@Arg、@One、@Many、@TypeDiscriminator、@Case </p></li><li><p><strong>缓存：</strong>@CacheNamespace、@Property、@CacheNamespaceRef、@Flush </p></li></ul><p>绝大部分注解，在xml映射文件中都有元素与之对应，但不是所有。此外在mybatis-spring中提供了@Mapper注解和@MapperScan注解，用于和spring进行整合。 </p><a id="more"></a><h2 id="增删改查相关注解"><a href="#增删改查相关注解" class="headerlink" title="增删改查相关注解"></a>增删改查相关注解</h2><table><thead><tr><th><strong>注解</strong></th><th><strong>使用对象</strong></th><th><strong>相对应的 XML</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>@Insert @Update @Delete @Select</td><td>方法</td><td>&lt;insert&gt; &lt;update&gt; &lt;delete&gt; &lt;select&gt;</td><td>这四个注解分别代表将会被执行的 SQL 语句。它们用字符串数组（或单个字符串）作为参数。如果传递的是字符串数组，字符串之间先会被填充一个空格再连接成单个完整的字符串。这有效避免了以 Java 代码构建 SQL 语句时的“丢失空格”的问题。然而，你也可以提前手动连接好字符串。属性有：value，填入的值是用来组成单个 SQL 语句的字符串数组。</td></tr><tr><td>@Options</td><td>方法</td><td>映射语句的属性</td><td>这个注解提供访问大范围的交换和配置选项的入口，它们通常在映射语句上作为属性出现。Options 注解提供了通俗易懂的方式来访问它们，而不是让每条语句注解变复杂。属性有：useCache=true, flushCache=FlushCachePolicy.DEFAULT, resultSetType=FORWARD_ONLY, statementType=PREPARED, fetchSize=-1, timeout=-1, useGeneratedKeys=false, keyProperty=”id”, keyColumn=””, resultSets=””。值得一提的是， Java 注解无法指定 null 值。因此，一旦你使用了 Options 注解，你的语句就会被上述属性的默认值所影响。要注意避免默认值带来的预期以外的行为。     注意： keyColumn 属性只在某些数据库中有效（如 Oracle、PostgreSQL等）。请在插入语句一节查看更多关于 keyColumn 和 keyProperty 两者的有效值详情。</td></tr><tr><td>@MapKey</td><td>方法</td><td></td><td>这是一个用在返回值为 Map 的方法上的注解。它能够将存放对象的 List 转化为 key 值为对象的某一属性的 Map。属性有： value，填入的是对象的属性名，作为 Map 的 key 值。</td></tr><tr><td>@SelectKey</td><td>方法</td><td>&lt;selectKey&gt;</td><td>这个注解的功能与 <selectKey> 标签完全一致，用在已经被 @Insert 或 @InsertProvider 或 @Update 或 @UpdateProvider 注解了的方法上。若在未被上述四个注解的方法上作 @SelectKey 注解则视为无效。如果你指定了 @SelectKey 注解，那么 MyBatis 就会忽略掉由 @Options 注解所设置的生成主键或设置（configuration）属性。属性有：statement 填入将会被执行的 SQL 字符串数组，keyProperty 填入将会被更新的参数对象的属性的值，before 填入 true 或 false 以指明 SQL 语句应被在插入语句的之前还是之后执行。resultType 填入 keyProperty 的 Java 类型和用 Statement、 PreparedStatement 和 CallableStatement 中的 STATEMENT、 PREPARED 或 CALLABLE 中任一值填入 statementType。默认值是 PREPARED。</td></tr><tr><td>@Param</td><td>参数</td><td>N/A</td><td>如果你的映射方法的形参有多个，这个注解使用在映射方法的参数上就能为它们取自定义名字。若不给出自定义名字，多参数（不包括 RowBounds 参数）则先以 “param” 作前缀，再加上它们的参数位置作为参数别名。例如 #{param1}, #{param2}，这个是默认值。如果注解是 @Param(“person”)，那么参数就会被命名为 #{person}。</td></tr><tr><td>@InsertProvider @UpdateProvider @DeleteProvider @SelectProvider</td><td>方法</td><td>&lt;insert&gt; &lt;update&gt; &lt;delete&gt; &lt;select&gt;</td><td>允许构建动态 SQL。这些备选的 SQL 注解允许你指定类名和返回在运行时执行的 SQL 语句的方法。（自从MyBatis 3.4.6开始，你可以用 CharSequence 代替 String 来返回类型返回值了。）当执行映射语句的时候，MyBatis 会实例化类并执行方法，类和方法就是填入了注解的值。你可以把已经传递给映射方法了的对象作为参数，”Mapper interface type” 和 “Mapper method” 会经过 ProviderContext （仅在MyBatis 3.4.5及以上支持）作为参数值。（MyBatis 3.4及以上的版本，支持多参数传入）属性有： type, method。type 属性需填入类。method 需填入该类定义了的方法名。注意 接下来的小节将会讨论类，能帮助你更轻松地构建动态 SQL。</td></tr></tbody></table><h3 id="Insert、-Update、-Delete、-Options、-SelectKey"><a href="#Insert、-Update、-Delete、-Options、-SelectKey" class="headerlink" title="@Insert、@Update、@Delete、@Options、@SelectKey"></a>@Insert、@Update、@Delete、@Options、@SelectKey</h3><p>mybatis会根据接口方法上的@Insert、@Update、@Delete注解，分别去调用SqlSession的insert、update、delete方法。这个几个方法返回的都是一个int，表示影响的记录行数。 </p><p>特别的，在UserMapper接口的insert方法上，除了添加了@Insert注解，还添加了@Options注解。在上面的案例中，@Options注解用于获取自动生成主键，并设置到User实体中。此外，@SelectKey注解也可以用于获取自动生成的主键，使用方式如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert</span>(<span class="string">"INSERT INTO user(id,name) VALUES (#&#123;id&#125;,#&#123;name&#125;)"</span>)</span><br><span class="line"><span class="meta">@SelectKey</span>(statement = <span class="string">"SELECT LAST_INSERT_ID()"</span>, keyProperty = <span class="string">"id"</span>, before = <span class="keyword">false</span>, resultType = Integer<span class="class">.<span class="keyword">class</span>) </span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">int</span> <span class="title">insert</span>(<span class="title">User</span> <span class="title">user</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="Select"><a href="#Select" class="headerlink" title="@Select"></a>@Select</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"SELECT id,name FROM user WHERE id= #&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Select</span>(<span class="string">"SELECT id,name FROM user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Select</span>(<span class="string">"SELECT id,name FROM user"</span>)</span><br><span class="line"><span class="meta">@MapKey</span>(<span class="string">"id"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;Integer,User&gt; <span class="title">selectMap</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Select</span>(<span class="string">"SELECT id,name FROM user LIMIT #&#123;offset&#125;,#&#123;limit&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectPage</span><span class="params">(@Param(<span class="string">"offset"</span>)</span> <span class="keyword">int</span> offset, @<span class="title">Param</span><span class="params">(<span class="string">"limit"</span>)</span> <span class="keyword">int</span> limit)</span>;</span><br></pre></td></tr></table></figure><p>在上面的案例中，UserMapper的selectById、selectAll、selectMap、selectPage方法都添加了@Select注解。mybatis会根据方法的返回值类型User、List<User>、Map&lt;Integer,User&gt;判断是调用SqlSession的selectOne、selectList还是selectMap方法。 </p><h3 id="MapKey"><a href="#MapKey" class="headerlink" title="@MapKey"></a>@MapKey</h3><p>特别的，对于返回值是Map的情况，UserMapper的selectMap方法上额外添加了一个@MapKey(“id”)注解，表示将User实例的id属性当做Map的key。</p><h3 id="动态sql与标签"><a href="#动态sql与标签" class="headerlink" title="动态sql与标签"></a>动态sql与标签</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select</span>(&#123; <span class="string">"&lt;script&gt;"</span>,</span><br><span class="line">         <span class="string">"SELECT id,name "</span> + <span class="string">"FROM user "</span> + <span class="string">"WHERE id IN "</span></span><br><span class="line">             + <span class="string">"&lt;foreach </span></span><br><span class="line"><span class="string">                 item='id' </span></span><br><span class="line"><span class="string">                 index='index' </span></span><br><span class="line"><span class="string">                 collection=‘array' </span></span><br><span class="line"><span class="string">                 open='(' separator=',' close=')'&gt; "</span> </span><br><span class="line">             + <span class="string">"#&#123;id&#125;"</span></span><br><span class="line">             + <span class="string">"&lt;/foreach&gt; "</span>,</span><br><span class="line">         <span class="string">"&lt;/script&gt;"</span> &#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectByIds</span><span class="params">(<span class="keyword">int</span>... ids)</span></span>;</span><br></pre></td></tr></table></figure><p>在UserMapper的selectByIds方法中，可以看到@Select注解里填写的SQL前后分别添加了&lt;script&gt;、&lt;/script&gt;，这是因为SQL中使用了动态sql标签&lt;foreach&gt;。不管是@Insert、@Update、@Delete、@Select注解，只要SQL里使用了mybatis的动态sql标签(包括：if、choose …when …otherwise、trim 、where、 set、foreach、bind)等，都建议在sql前后分别加上&lt;script&gt;、&lt;/script&gt;，否则可能会出现一些参数找不到的情况。 </p><h3 id="Param"><a href="#Param" class="headerlink" title="@Param"></a>@Param</h3><p>@Param注解用于给方法参数起一个名字。以下是笔者总结的使用原则：</p><ul><li>在方法只接受一个参数的情况下，可以不使用@Param。</li><li>在方法接受多个参数的情况下，建议一定要使用@Param注解给参数命名。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"SELECT id,name FROM user LIMIT #&#123;offset&#125;,#&#123;limit&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectPage</span><span class="params">(@Param(<span class="string">"offset"</span>)</span> <span class="keyword">int</span> offset, @<span class="title">Param</span><span class="params">(<span class="string">"limit"</span>)</span> <span class="keyword">int</span> limit)</span>;</span><br></pre></td></tr></table></figure><p>例如上述案例的selectPage方法接受2个参数，所以其两个参数都使用了@Param注解。</p><h3 id="InsertProvider、-UpdateProvider、-DeleteProvider、-SelectProvider"><a href="#InsertProvider、-UpdateProvider、-DeleteProvider、-SelectProvider" class="headerlink" title="@InsertProvider、@UpdateProvider、@DeleteProvider、@SelectProvider"></a>@InsertProvider、@UpdateProvider、@DeleteProvider、@SelectProvider</h3><p>这几个注解主要用于动态sql构建。</p><h2 id="结果集映射相关注解"><a href="#结果集映射相关注解" class="headerlink" title="结果集映射相关注解"></a>结果集映射相关注解</h2><table><thead><tr><th><strong>注解</strong></th><th><strong>使用对象</strong></th><th><strong>相对应的 XML</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>@Results</td><td>方法</td><td>&lt;resultMap&gt;</td><td>结果映射的列表，包含了一个特别结果列如何被映射到属性或字段的详情。属性有：value, id。value 属性是 Result 注解的数组。这个 id 的属性是结果映射的名称。</td></tr><tr><td>@Result</td><td>方法</td><td>&lt;result&gt; &lt;id&gt;</td><td>在列和属性或字段之间的单独结果映射。属性有：id, column, javaType, jdbcType, typeHandler, one, many。id 属性是一个布尔值，来标识应该被用于比较（和在 XML 映射中的<id>相似）的属性。one 属性是单独的联系，和 <association> 相似，而 many 属性是对集合而言的，和<collection>相似。它们这样命名是为了避免名称冲突。</td></tr><tr><td>@ResultMap</td><td>方法</td><td>N/A</td><td>这个注解给 @Select 或者 @SelectProvider 提供在 XML 映射中的 <resultMap> 的id。这使得注解的 select 可以复用那些定义在 XML 中的 ResultMap。如果同一 select 注解中还存在 @Results 或者 @ConstructorArgs，那么这两个注解将被此注解覆盖。</td></tr><tr><td>@ResultType</td><td>方法</td><td>N/A</td><td>此注解在使用了结果处理器的情况下使用。在这种情况下，返回类型为 void，所以 Mybatis 必须有一种方式决定对象的类型，用于构造每行数据。如果有 XML 的结果映射，请使用 @ResultMap 注解。如果结果类型在 XML 的 <select> 节点中指定了，就不需要其他的注解了。其他情况下则使用此注解。比如，如果 @Select 注解在一个将使用结果处理器的方法上，那么返回类型必须是 void 并且这个注解（或者@ResultMap）必选。这个注解仅在方法返回类型是 void 的情况下生效。</td></tr><tr><td>@ConstructorArgs</td><td>方法</td><td>&lt;constructor&gt;</td><td>收集一组结果传递给一个结果对象的构造方法。属性有：value，它是形式参数数组。</td></tr><tr><td>@Arg</td><td>N/A</td><td>&lt;arg&gt; &lt;idArg&gt;</td><td>单参数构造方法，是 ConstructorArgs 集合的一部分。属性有：id, column, javaType, jdbcType, typeHandler, select和 resultMap。id 属性是布尔值，来标识用于比较的属性，和<idArg> XML 元素相似。</td></tr><tr><td>@One</td><td>N/A</td><td>&lt;association&gt;</td><td>复杂类型的单独属性值映射。属性有：select，已映射语句（也就是映射器方法）的全限定名，它可以加载合适类型的实例。fetchType会覆盖全局的配置参数 lazyLoadingEnabled。<strong>注意</strong> 联合映射在注解 API中是不支持的。这是因为 Java 注解的限制,不允许循环引用。</td></tr><tr><td>@Many</td><td>N/A</td><td>&lt;collection&gt;</td><td>映射到复杂类型的集合属性。属性有：select，已映射语句（也就是映射器方法）的全限定名，它可以加载合适类型的实例的集合，fetchType 会覆盖全局的配置参数 lazyLoadingEnabled。<strong>注意</strong> 联合映射在注解 API中是不支持的。这是因为 Java 注解的限制，不允许循环引用</td></tr><tr><td>@TypeDiscriminator</td><td>方法</td><td>&lt;discriminator&gt;</td><td>一组实例值被用来决定结果映射的表现。属性有：column, javaType, jdbcType, typeHandler 和 cases。cases 属性是实例数组。</td></tr><tr><td>@Case</td><td>N/A</td><td>&lt;case&gt;</td><td>单独实例的值和它对应的映射。属性有：value, type, results。results 属性是结果数组，因此这个注解和实际的 ResultMap 很相似，由下面的 Results 注解指定。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Mybatis 最初配置信息是基于 XML ,映射语句(SQL)也是定义在 XML 中的。而到了 MyBatis 3提供了新的基于注解的配置。mybatis提供的注解有很多，大致可以分为以下几类： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;增删改查：&lt;/strong&gt;@Insert、@Update、@Delete、@Select、@MapKey、@Options、@SelelctKey、@Param、@InsertProvider、@UpdateProvider、@DeleteProvider、@SelectProvider &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;结果集映射：&lt;/strong&gt;@Results、@Result、@ResultMap、@ResultType、@ConstructorArgs、@Arg、@One、@Many、@TypeDiscriminator、@Case &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;缓存：&lt;/strong&gt;@CacheNamespace、@Property、@CacheNamespaceRef、@Flush &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;绝大部分注解，在xml映射文件中都有元素与之对应，但不是所有。此外在mybatis-spring中提供了@Mapper注解和@MapperScan注解，用于和spring进行整合。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="Java框架" scheme="http://yoursite.com/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Mybatis" scheme="http://yoursite.com/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>力扣</title>
    <link href="http://yoursite.com/2020/06/14/%E5%88%B7%E9%A2%98/LeetCode%E5%88%B7%E9%A2%98/"/>
    <id>http://yoursite.com/2020/06/14/%E5%88%B7%E9%A2%98/LeetCode%E5%88%B7%E9%A2%98/</id>
    <published>2020-06-14T14:01:00.000Z</published>
    <updated>2020-07-05T16:31:40.928Z</updated>
    
    <content type="html"><![CDATA[<p>求职在即，把自己在LeetCode上的刷题做一个笔记。</p><p>下面为本人在LeetCode上面刷的题目笔记，给出所有代码为本人提交Accepted后记录。</p><a id="more"></a><h2 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题中说了要转换为一棵高度平衡的二叉搜索树，并且数组又是排过序的，这就好办了，我们可以使用递归的方式，每次取数组中间的值比如m作为当前节点，m前面的值作为他左子树的结点值，m后面的值作为他右子树的节点值。所得结果不唯一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sortedArrayToBST(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span> nums[],<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid=(start+end)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left=sortedArrayToBST(nums,start,mid-<span class="number">1</span>);</span><br><span class="line">        root.right=sortedArrayToBST(nums,mid+<span class="number">1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图解<br><img src="https://pic.leetcode-cn.com/8a549e664d787eb23f35b3e6571fc40b200d1958fb0d91ca1392e8961ce85f15-image.png" alt="Java递归遍历"></p><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>暴力解法时间复杂度为n平方，使用哈希表我们可以一次完成。在进行迭代并将元素插入到表中的同时，并检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并将其返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=target-nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(temp))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(temp),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>); <span class="comment">//抛出不合法的参数异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a><a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">通配符匹配</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>动态规划，注意细节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lens=s.length(),lenp=p.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[lenp+<span class="number">1</span>][lens+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="keyword">true</span>; <span class="comment">//表示空串是匹配的。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lenp;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(i-<span class="number">1</span>)!=<span class="string">'*'</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;  处理一下匹配串 p 以若干个星号开头的情况。因为星号是可以匹配空串的：</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lenp;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lens;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.charAt(i-<span class="number">1</span>)==s.charAt(j-<span class="number">1</span>)||p.charAt(i-<span class="number">1</span>)==<span class="string">'?'</span>)&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(i-<span class="number">1</span>)==<span class="string">'*'</span>)&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j] | dp[i][j-<span class="number">1</span>];  <span class="comment">//需要匹配‘*’ | 不需要匹配‘*’</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[lenp][lens];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-5"><a href="#-5" class="headerlink" title=""></a></h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-6"><a href="#-6" class="headerlink" title=""></a></h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-7"><a href="#-7" class="headerlink" title=""></a></h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-8"><a href="#-8" class="headerlink" title=""></a></h2><h3 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-9"><a href="#-9" class="headerlink" title=""></a></h2><h3 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-10"><a href="#-10" class="headerlink" title=""></a></h2><h3 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-11"><a href="#-11" class="headerlink" title=""></a></h2><h3 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-12"><a href="#-12" class="headerlink" title=""></a></h2><h3 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-13"><a href="#-13" class="headerlink" title=""></a></h2><h3 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-14"><a href="#-14" class="headerlink" title=""></a></h2><h3 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-15"><a href="#-15" class="headerlink" title=""></a></h2><h3 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-16"><a href="#-16" class="headerlink" title=""></a></h2><h3 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-19"><a href="#解题思路-19" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-17"><a href="#-17" class="headerlink" title=""></a></h2><h3 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-20"><a href="#解题思路-20" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;求职在即，把自己在LeetCode上的刷题做一个笔记。&lt;/p&gt;
&lt;p&gt;下面为本人在LeetCode上面刷的题目笔记，给出所有代码为本人提交Accepted后记录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer</title>
    <link href="http://yoursite.com/2020/06/14/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/"/>
    <id>http://yoursite.com/2020/06/14/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/</id>
    <published>2020-06-14T14:01:00.000Z</published>
    <updated>2020-07-31T14:01:13.486Z</updated>
    
    <content type="html"><![CDATA[<p>求职在即，《剑指offer》作为大家都推荐的一本应试宝典算法相关资料，确实也有刷一刷的必要。很多题目都比较经典，也涵盖了大多数的算法和数据结构。把自己刷题的过程做一个总结，权当是一个笔记。</p><p>下面为本人在LeetCode上面刷的题目笔记，给出所有代码为本人提交Accepted后记录。</p><a id="more"></a><h2 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>运用HashMap，将数组中的数一一存入，同时比较是否map中存在，已存在的话就输出，不存在则存入map中并赋给初始值1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">int</span> n=nums.length;</span><br><span class="line">              <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (map.containsKey(nums[i])) &#123;</span><br><span class="line">result=nums[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">map.put(nums[i], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他解法：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/hua-jie-suan-fa-mian-shi-ti-3-shu-zu-zhong-zhong-f/" target="_blank" rel="noopener">HashSet</a></p><h2 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>要求只出现一次的第一个字符，就需要去计数每一个字符出现了几次。一般都是用哈希表，但是字符往多了数按照扩展的ASCII码也就256个，就可以使用int[] count来代替哈希表：键就是字符对应的数，值就是该字符出现的次数。</li><li>第一次遍历计数每个字符出现的次数for(char c : chars) count[c]++;。第二次遍历按顺序去查看该字符出现了几次，如果该字符出现了1次，它就是第一个仅出现一次的字符，直接返回。</li><li>如果第二次遍历没有返回，就说明没有仅出现一次的字符，返回’ ‘。<br>时间复杂度为O(n)，空间复杂度为O(n)（因为使用了辅助的字符数组）.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] count=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">char</span>[] chars=s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:chars)&#123;</span><br><span class="line">            count[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:chars)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count[c]==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>其他解法：<a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/solution/mian-shi-ti-50-di-yi-ge-zhi-chu-xian-yi-ci-de-zi-3/" target="_blank" rel="noopener">HashMap</a></li></ul><h2 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>排序 或者不断记录出现次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//记录每个数字的出现次数</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            count[nums[i]]++;</span><br><span class="line">            <span class="keyword">if</span>(count[nums[i]] &gt; nums.length/<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">不能有负数，不能有大数，否则数组越界，简单方法就排序</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他方法：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/solution/qiao-miao-jie-ti-bi-pai-xu-shi-xian-geng-gao-xiao-/" target="_blank" rel="noopener">比排序高效的算法</a></p><h2 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>简单题，主要复习了java数组拷贝知识和排序算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span>[] result=<span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        result=Arrays.copyOf(arr,k);</span><br><span class="line">        <span class="keyword">return</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">if</span>(k&lt;= <span class="number">0</span> || k &gt; input.length)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="comment">//初次排序，完成k个元素的排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt; k; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = i-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> unFindElement = input[i];</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; input[j] &gt; unFindElement)&#123;</span><br><span class="line">            input[j+<span class="number">1</span>] = input[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        input[j+<span class="number">1</span>] = unFindElement;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历后面的元素 进行k个元素的更新和替换</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; input.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(input[i] &lt; input[k-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> newK = input[i];</span><br><span class="line">            <span class="keyword">int</span> j = k-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; input[j] &gt; newK)&#123;</span><br><span class="line">                input[j+<span class="number">1</span>] = input[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            input[j+<span class="number">1</span>] = newK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把前k个元素返回</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        result.add(input[i]);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他算法：<a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/3chong-jie-fa-miao-sha-topkkuai-pai-dui-er-cha-sou/" target="_blank" rel="noopener">TOPK问题解法</a></p><p>笔记记录：<a href="https://blog.csdn.net/i_silence/article/details/106457958" target="_blank" rel="noopener">java数组复制</a></p><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>求斐波那契数列，斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。<br>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] result= <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        result[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        result[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            result[i]=(result[i-<span class="number">2</span>]+result[i-<span class="number">1</span>])%<span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">递归算法</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>) + Fibonacci(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">        Set&lt;String&gt; ans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        f(ans, <span class="number">0</span>, arr);</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> String[ans.size()]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与其说是递归，不如说是树形遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Set ans, <span class="keyword">int</span> position, <span class="keyword">char</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(position == arr.length)</span><br><span class="line">            ans.add(String.valueOf(arr));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = position; i&lt;arr.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 对数组swap的过程就是排列的过程，</span></span><br><span class="line">            <span class="comment">// 在for循环中swap，每次swap后，就会有新的元素排在第一位</span></span><br><span class="line">            swap(arr, position, i);</span><br><span class="line">            f(ans, position+<span class="number">1</span>, arr);</span><br><span class="line">            swap(arr, position, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他算法：<a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/solution/mian-shi-ti-38-zi-fu-chuan-de-pai-lie-hui-su-fa-by/" target="_blank" rel="noopener">回溯法</a></p><p>字典序相关:<a href="https://blog.csdn.net/i_silence/article/details/80616452?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159092775719724839200634%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=159092775719724839200634&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_blog_default-2-80616452.pc_v2_rank_blog_default&utm_term=%E5%AD%97%E5%85%B8%E5%BA%8F" target="_blank" rel="noopener">我的博客记录</a></p><p>求幂<br>(int)Math.pow(10,n);</p><h2 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><p>递归调用（分治思想），要注意的一点是，虽然题目中告诉我们不需要考虑大数问题，但是给出的 n 可以取到 -2147483648−2147483648（整型负数的最小值），因此，在编码的时候，需要将 n 转换成 long 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N=n;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> myPow(x,N);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/myPow(x,-N);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">double</span> square=myPow(x,n/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> square*square;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">double</span> square=myPow(x,(n-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">             <span class="keyword">return</span> square*square*x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><p>此类求 <strong>多少种可能性</strong> 的题目一般都有 递推性质 ，即f(n) 和 f(n-1)…f(1) 之间是有联系的。</p><p>设跳上 n 级台阶有 f(n) 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上 1 级或 2 级台阶。<br>当为 1 级台阶： 剩 n-1 个台阶，此情况共有 f(n−1) 种跳法；<br>当为 2 级台阶： 剩 n−2 个台阶，此情况共有 f(n-2) 种跳法。<br>f(n) 为以上两种情况之和，即 f(n)=f(n-1)+f(n-2)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=(dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>])%<span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意直接存储会时间超限，所以使用数组记录计算出来的值</p><h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。</p><h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><p>把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p><p>也可以使用java自带的Bitcount直接得到结果： return Integer.bitCount(n);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            n=n&amp;(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除链表的节点"><a href="#删除链表的节点" class="headerlink" title="删除链表的节点"></a>删除链表的节点</h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。<br>返回删除后的链表的头节点。</p><h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><p>简单实现链表的删除操作，即改变指针指向。<br>注意不能使用java不能使用p-&gt;next，只能p.next</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.val == val) <span class="keyword">return</span> head.next;</span><br><span class="line"></span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span>(p.next.val != val) p = p.next;</span><br><span class="line"></span><br><span class="line">        p.next = p.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><p>链表特点： 只能从前至后访问每个节点。</p><p>题目要求： 倒序输出节点值。</p><p>这种 先入后出 的需求可以借助 栈 来实现。</p><p>算法流程：</p><p>入栈： 遍历链表，将各节点值 push 入栈。（​Java​借助 LinkedList 的addLast()方法）。</p><p>出栈： 将各节点值 pop 出栈，存储于数组并返回。（Java ​新建一个数组，通过 popLast() 方法将各元素存入数组，实现倒序输出）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.addLast(head.val);</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[stack.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.length;i++)&#123;</span><br><span class="line">            res[i]=stack.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从尾到头打印链表-1"><a href="#从尾到头打印链表-1" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><h3 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3><p>输入：</p><p>[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br>这一行表示输入的操作</p><p>[ [],[3],[],[] ]<br>这个表示每一行代码操作后对应的结果</p><p>举例：<br>CQueue 表示新建一个CQueue对象，对应的结果为[]。<br>appendTail 表示执行一个appendTail()操作，对应要被操作的元素为3，，对应的结果为[3]<br>deleteHead 表示执行一个deleteHead操作，对应的结果为[]<br>deleteHead 表示执行一个deleteHead操作，对应的结果为[]</p><p>以上的输入其实是一个代码执行的步骤描述与其对应结果或操作。<br>并不是说，上面的“输入”表示的输入程序验证的数据.</p><p>使用java的要注意，如果使用Stack的方式来做这道题，会造成速度较慢； 原因的话是Stack继承了Vector接口，而Vector底层是一个Object[]数组，那么就要考虑空间扩容和移位的问题了。 可以使用LinkedList来做Stack的容器，因为LinkedList实现了Deque接口，所以Stack能做的事LinkedList都能做，其本身结构是个双向链表，扩容消耗少。</p><p>两个栈，叫他兄弟栈好了，每次入队都是哥哥出，但要出队的时候，哥哥找弟弟帮忙把栈底的元素（也就是队头）出队。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Integer&gt; stack1;</span><br><span class="line">    LinkedList&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        stack2=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        stack1.add(value);  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack1.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.add(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> stack2.pop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法说明：<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution/mian-shi-ti-09-yong-liang-ge-zhan-shi-xian-dui-l-3/" target="_blank" rel="noopener">官方解答</a></p><hr><h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h2><h3 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 </p><h3 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h3><p>二分法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int minArray(int[] nums) &#123;</span></span><br><span class="line"><span class="comment">        int min=nums[0];</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;nums.length;i++)&#123;</span></span><br><span class="line"><span class="comment">            if(nums[i]&lt;min)&#123;</span></span><br><span class="line"><span class="comment">                return nums[i];</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return min;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[m] &gt; numbers[j]) i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (numbers[m] &lt; numbers[j]) j = m;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">二叉搜索树的最近公共祖先</a></h2><h3 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>示例见原题。</p><h3 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于二叉搜索树：</p><p>根据以上定义，若 root是 p,q 的 最近公共祖先 ，则只可能为以下情况之一：</p><ul><li>p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；</li><li>p = root，且 q 在 root 的左或右子树中；</li><li>q = root，且 p 在 root 的左或右子树中；</li></ul><ol><li>若 root.val &lt; p.val ，则 p 在 root 右子树 中；</li><li>若 root.val &gt; p.val ，则 p 在 root 左子树 中；</li><li>若 root.val = p.val ，则 p 和 root 指向 同一节点 。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val&gt;p.val&amp;&amp;root.val&gt;q.val)&#123;</span><br><span class="line">            root=root.left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;p.val&amp;&amp;root.val&lt;q.val)&#123;</span><br><span class="line">            root=root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h2><h3 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个链表，找出它们的第一个公共节点。示例：</p><ul><li>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</li><li>输出：Reference of the node with value = 2</li></ul><h3 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode h1 = headA, h2 = headB;</span><br><span class="line">        <span class="keyword">while</span> (h1 != h2) &#123;</span><br><span class="line"></span><br><span class="line">            h1 = h1 == <span class="keyword">null</span> ? headB : h1.next;</span><br><span class="line">            h2 = h2 == <span class="keyword">null</span> ? headA : h2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> h1;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此题太浪漫了！两个结点去对方的轨迹中寻找对方的身影，只要二人有交集，就终会相遇❤</p><h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h2><h3 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。</p><h3 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h3><p>使用HashMap存储子链表的值，然后根据存储的map get存储指针指向关系。只学了第一种解题方案，但效率挺高的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希表</span></span><br><span class="line"><span class="comment">     * 空间复杂度 O（N)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;Node, Node&gt;();</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="comment">//map中存的是(原节点，拷贝节点)的一个映射</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.put(cur, <span class="keyword">new</span> Node(cur.val));</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="comment">//将拷贝的新的节点组织成一个链表</span></span><br><span class="line">        <span class="comment">//由原链表的关系，生成新链表的关系</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.get(cur).next = map.get(cur.next);</span><br><span class="line">            map.get(cur).random = map.get(cur.random);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原地修改，空间复杂度为O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空间复杂度O(1)</span></span><br><span class="line"><span class="comment">     * 1.将复制的节点放在原节点之后</span></span><br><span class="line"><span class="comment">     * 2.将复制节点的random节点放在原节点的random节点之后</span></span><br><span class="line"><span class="comment">     * 3.将二者分开</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将拷贝节点放到原节点后面，例如1-&gt;2-&gt;3这样的链表就变成了这样1-&gt;1'-&gt;2'-&gt;3-&gt;3'</span></span><br><span class="line">        <span class="keyword">for</span> (Node node = head, copy = <span class="keyword">null</span>; node != <span class="keyword">null</span>; node = node.next.next) &#123;</span><br><span class="line">            copy = <span class="keyword">new</span> Node(node.val);</span><br><span class="line">            copy.next = node.next;</span><br><span class="line">            node.next = copy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拷贝节点的random信息</span></span><br><span class="line">        <span class="keyword">for</span> (Node node = head; node != <span class="keyword">null</span>; node = node.next.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.next.random = node.random.next;</span><br><span class="line">        <span class="comment">//node.next 是 node 复制出来的节点 ，node.random.next 是 node.random 复制出来的节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分离拷贝节点和原节点，变成1-&gt;2-&gt;3和1'-&gt;2'-&gt;3'两个链表，后者就是答案</span></span><br><span class="line">        Node newHead = head.next;</span><br><span class="line">        <span class="keyword">for</span> (Node node = head, temp = <span class="keyword">null</span>; node != <span class="keyword">null</span> &amp;&amp; node.next != <span class="keyword">null</span>;) &#123;</span><br><span class="line">            temp = node.next;</span><br><span class="line">            node.next = temp.next;</span><br><span class="line">            node = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试题讲解：<a href="https://www.bilibili.com/video/BV1XE411L7CK?from=search&seid=9278996534222741920" target="_blank" rel="noopener">up主讲解</a></p><h2 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a>翻转单词顺序</h2><h3 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p><h3 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h3><p>trim()函数删除首位空格；</p><p>split函数为java字符串分隔符：<a href="https://www.cnblogs.com/xiaoxiaohui2015/p/5838674.html" target="_blank" rel="noopener">详细用法</a></p><p>如果字符串前面有空格 split() 会产生一个””，如果中间有连续的三个空格 会产生两个””。</p><p>使用equals而不用==，因为==比较的是内存地址即是否为同一个对象，equals比较的是内存空间里的内容是否相同。所以String类型要用”==”无效 要使用equals() 方法判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String[] strs = s.trim().split(<span class="string">" "</span>); <span class="comment">// 删除首尾空格，分割字符串</span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = strs.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 倒序遍历单词列表</span></span><br><span class="line">            <span class="keyword">if</span>(strs[i].equals(<span class="string">""</span>)) <span class="keyword">continue</span>; <span class="comment">// 遇到空单词则跳过</span></span><br><span class="line">            res.append(strs[i] + <span class="string">" "</span>); <span class="comment">// 将单词拼接至 StringBuilder</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim(); <span class="comment">// 转化为字符串，删除尾部空格，并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题解：<a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/solution/mian-shi-ti-58-i-fan-zhuan-dan-ci-shun-xu-shuang-z/" target="_blank" rel="noopener">题目讲解</a></p><h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><h3 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h3><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><h3 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h3><p>直接使用切片函数return s.subString(n,s.length())+s.subString(0,n);</p><p>使用StringBulider保存变化长度字符串，注意原string字符串s[i]不能使用要用s.charAt[i]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder str=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;s.length();i++)&#123;</span><br><span class="line">            str.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            str.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效率不高QAQ，就这样吧</p><h2 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h2><h3 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h3><p>这题麻烦点就在于边界问题，最开始的空格要处理，然后负号要标记，遇到正负号index++后，还要判断int数组边界问题。int的范围[-2147483648,2147483647]。</p><h3 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h3><p>判断好边界情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        str=str.trim();</span><br><span class="line">        <span class="keyword">if</span>(str.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> c=str.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(c!=<span class="string">'-'</span>&amp;&amp;c!=<span class="string">'+'</span>&amp;&amp;(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len=str.length();</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>,tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sign=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i)==<span class="string">'-'</span>)&#123;</span><br><span class="line">            sign=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i)==<span class="string">'-'</span>||str.charAt(i)==<span class="string">'+'</span>)&#123;</span><br><span class="line">            ++i;       </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;len&amp;&amp;str.charAt(i)&gt;=<span class="string">'0'</span>&amp;&amp;str.charAt(i)&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">            tmp=str.charAt(i)-<span class="number">48</span>;</span><br><span class="line">            <span class="keyword">if</span>(sign==<span class="number">1</span> &amp;&amp; (ans&gt;<span class="number">214748364</span> ||ans==<span class="number">214748364</span> &amp;&amp; tmp&gt;=<span class="number">7</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2147483647</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sign==<span class="number">0</span> &amp;&amp; (ans&gt;<span class="number">214748364</span> ||ans==<span class="number">214748364</span> &amp;&amp; tmp&gt;=<span class="number">8</span>))&#123;</span><br><span class="line">            <span class="comment">//注意符号是符数但ans不是负数</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">2147483648</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=ans*<span class="number">10</span>+tmp;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sign==<span class="number">0</span>) <span class="keyword">return</span> -ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h2><h3 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h3><p>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><h3 id="解题思路-19"><a href="#解题思路-19" class="headerlink" title="解题思路"></a>解题思路</h3><p>递归或者与或运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n==<span class="number">0</span> ? <span class="number">0</span>:n+sumNums(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int sumNums(int n) &#123;</span></span><br><span class="line"><span class="comment">        boolean flag = n &gt; 0 &amp;&amp; (n += sumNums(n - 1)) &gt; 0;</span></span><br><span class="line"><span class="comment">        return n;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="股票的最大利润"><a href="#股票的最大利润" class="headerlink" title="股票的最大利润"></a>股票的最大利润</h2><h3 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p>示例：输入: [7,1,5,3,6,4]<br>输出: 5</p><h3 id="解题思路-20"><a href="#解题思路-20" class="headerlink" title="解题思路"></a>解题思路</h3><p>动态规划，dp[0]=0,cost不断更新最低价格</p><p>dp[i]=max(dp[i−1],prices[i]−min(cost,prices[i])。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cost=Integer.MAX_VALUE,profit=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price:prices)&#123;</span><br><span class="line">            cost=Math.min(cost,price);</span><br><span class="line">            profit=Math.max(profit,price-cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h2><h3 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。<br>要求时间复杂度为O(n)。</p><h3 id="解题思路-21"><a href="#解题思路-21" class="headerlink" title="解题思路"></a>解题思路</h3><p>动态规划：由于 dp[i] 只与 dp[i-1] 和 nums[i] 有关系，因此可以将原数组 nums 用作 dp 列表，即直接在 nums 上修改即可。减少了O(n)的空间复杂度。<br>由于省去 dp 列表使用的额外空间，因此空间复杂度从 O(N) 降至 O(1) 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            nums[i]+=Math.max(nums[i-<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">            result=Math.max(nums[i],result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><h3 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><h3 id="解题思路-22"><a href="#解题思路-22" class="headerlink" title="解题思路"></a>解题思路</h3><p>二叉树本身就是递归定义的一种数据结构，使用递归解答本题还是很容易的。</p><p>解析：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-ii-er-cha-shu-de-zui-jin-gong-gon-7/" target="_blank" rel="noopener">后序遍历DFS</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>||root == p||root==q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 后续遍历，二叉树数的套路</span></span><br><span class="line">        TreeNode l = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode r = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">//边界条件</span></span><br><span class="line">        <span class="keyword">if</span>(l==<span class="keyword">null</span>&amp;&amp;r==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(l!=<span class="keyword">null</span>&amp;&amp;r!=<span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(l!=<span class="keyword">null</span>&amp;&amp;r==<span class="keyword">null</span>) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从上到下打印二叉树"><a href="#从上到下打印二叉树" class="headerlink" title="从上到下打印二叉树"></a>从上到下打印二叉树</h2><h3 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h3><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><h3 id="解题思路-23"><a href="#解题思路-23" class="headerlink" title="解题思路"></a>解题思路</h3><p>此题树刚好获取上一层，才打印下一层，层序遍历使用队列先进先出</p><table><thead><tr><th></th><th></th><th></th><th>1</th></tr></thead><tbody><tr><td></td><td></td><td>1.2</td><td>1.1</td></tr><tr><td>第一层队列——————1</td><td></td><td></td><td></td></tr></tbody></table><p>第二层队列———1.2，1.1，1（已经出队列）</p><p>队列存储一层一层的节点信息，然后使用list数组保存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;<span class="comment">//不判断会出错</span></span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//queue取出一个元素，还要把左右孩子加入队列</span></span><br><span class="line">            TreeNode node=queue.remove();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.length;i++)&#123;</span><br><span class="line">            res[i]=list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从上到下打印二叉树-II"><a href="#从上到下打印二叉树-II" class="headerlink" title="从上到下打印二叉树 II"></a>从上到下打印二叉树 II</h2><h3 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h3><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p>算法流程：</p><ol><li>特例处理： 当根节点为空，则返回空列表 [] ；</li><li>初始化： 打印结果列表 res = [] ，包含根节点的队列 queue = [root] ；</li><li>BFS 循环： 当队列 queue 为空时跳出；<ul><li>新建一个临时列表 tmp ，用于存储当前层打印结果；</li><li>当前层打印循环： 循环次数为当前层节点数（即队列 queue 长度）；<ul><li>出队： 队首元素出队，记为 node；</li><li>打印： 将 node.val 添加至 tmp 尾部；</li><li>添加子节点： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；</li></ul></li><li>将当前层结果 tmp 添加入 res 。</li></ul></li><li>返回值： 返回打印结果列表 res 即可。</li></ol><h3 id="解题思路-24"><a href="#解题思路-24" class="headerlink" title="解题思路"></a>解题思路</h3><p>大部分tree的题目<br>ProOrder先序遍历和postOrder后序遍历-&gt;DFS</p><p>少部分1：inOrder中序遍历-&gt;二叉搜索树</p><p>少部分2：leverOrder层序遍历-&gt;利用数据结构：队列实现</p><p>队列 先进先出 适合层序遍历，父节点在队列中，然后下一层子节点才能进队列</p><p>解决方案：从queue出去一个节点的时候，把左右节点加入queue，出来的节点数值使用一个Arraylist保存，最后转为int[]返回；</p><p>当每层单独输出一行，只需最开始记录每层的queue.size大小，然后每层输出即可</p><p>当交叉输出，把原来的Arraylist的尾部追加插入改为尾部插入/头部插入交叉即可，使用Linkedlist</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两种数据结构: Queue +  ArrayList</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心方案: queue中取出一个元素, 再把其左右孩子加入queue</span></span><br><span class="line">    queue.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> size = queue.size(); <span class="comment">//一定要先获得, 防止fast fail</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            TreeNode node = queue.remove(); <span class="comment">//queue中取出一个节点</span></span><br><span class="line"></span><br><span class="line">            temp.add(node.val); <span class="comment">//把节点值加入list</span></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)   queue.add(node.left); <span class="comment">//左孩子不空, 加入queue</span></span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)  queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲解视频:<a href="https://www.bilibili.com/video/BV1vQ4y1M7wv/" target="_blank" rel="noopener"> Queue + ArrayList</a></p><h2 id="从上到下打印二叉树-III"><a href="#从上到下打印二叉树-III" class="headerlink" title="从上到下打印二叉树 III"></a>从上到下打印二叉树 III</h2><h3 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><h3 id="解题思路-25"><a href="#解题思路-25" class="headerlink" title="解题思路"></a>解题思路</h3><p>和上一个差不多，多了个头插</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        List&lt;Integer&gt; temp=<span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//头插效率更高</span></span><br><span class="line">        <span class="keyword">int</span> size=queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            TreeNode node=queue.remove();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(flag) temp.add(node.val);</span><br><span class="line">            <span class="keyword">else</span> temp.add(<span class="number">0</span>,node.val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        flag=!flag;</span><br><span class="line">        res.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树的第k大节点"><a href="#二叉搜索树的第k大节点" class="headerlink" title="二叉搜索树的第k大节点"></a>二叉搜索树的第k大节点</h2><h3 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><h3 id="解题思路-26"><a href="#解题思路-26" class="headerlink" title="解题思路"></a>解题思路</h3><p>二叉搜索树：</p><ul><li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li><li>没有键值相等的节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ans=<span class="number">0</span>,count=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        dfs(root,k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        dfs(root.right,k);</span><br><span class="line">        <span class="keyword">if</span>(++count==k)&#123;</span><br><span class="line">            ans=root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><h3 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉树的根节点，求该树的深度。</p><h3 id="解题思路-27"><a href="#解题思路-27" class="headerlink" title="解题思路"></a>解题思路</h3><p>此树的深度和其左（右）子树的深度之间的关系。显然，此树的深度 等于左子树的深度与右子树的深度 中的 最大值 +1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><h3 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><h3 id="解题思路-28"><a href="#解题思路-28" class="headerlink" title="解题思路"></a>解题思路</h3><p>先写二叉树的深度函数，对于本题，使用DFS,不断判断左右子树是否满足条件，最后返回根节点的左右节点是否满足深度条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> leftHeight=getHeight(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightHeight=getHeight(root.right);</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(rightHeight-leftHeight)&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isBalanced(root.left)&amp;&amp;isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftHeight=getHeight(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightHeight=getHeight(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftHeight,rightHeight)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><h3 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><h3 id="解题思路-29"><a href="#解题思路-29" class="headerlink" title="解题思路"></a>解题思路</h3><p>解析：<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/" target="_blank" rel="noopener">题目解析</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = matrix[<span class="number">0</span>].length - <span class="number">1</span>, t = <span class="number">0</span>, b = matrix.length - <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[(r + <span class="number">1</span>) * (b + <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++) res[x++] = matrix[t][i]; <span class="comment">// left to right.</span></span><br><span class="line">            <span class="keyword">if</span>(++t &gt; b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i &lt;= b; i++) res[x++] = matrix[i][r]; <span class="comment">// top to bottom.</span></span><br><span class="line">            <span class="keyword">if</span>(l &gt; --r) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i &gt;= l; i--) res[x++] = matrix[b][i]; <span class="comment">// right to left.</span></span><br><span class="line">            <span class="keyword">if</span>(t &gt; --b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = b; i &gt;= t; i--) res[x++] = matrix[i][l]; <span class="comment">// bottom to top.</span></span><br><span class="line">            <span class="keyword">if</span>(++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">import java.util.ArrayList;</span></span><br><span class="line"><span class="comment">public class Solution &#123;</span></span><br><span class="line"><span class="comment">    public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123;</span></span><br><span class="line"><span class="comment">        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span></span><br><span class="line"><span class="comment">        //定义四个边界</span></span><br><span class="line"><span class="comment">        int low = 0;</span></span><br><span class="line"><span class="comment">        int high = matrix.length -1;</span></span><br><span class="line"><span class="comment">        int left = 0;</span></span><br><span class="line"><span class="comment">        int right = matrix[0].length -1;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        while(low &lt;= high &amp;&amp; left &lt;= right)&#123;</span></span><br><span class="line"><span class="comment">            for(int i = left; i &lt;= right; i++)&#123;</span></span><br><span class="line"><span class="comment">                list.add(matrix[low][i]);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            for(int i = low+1; i &lt;= high; i++)&#123;</span></span><br><span class="line"><span class="comment">                list.add(matrix[i][right]);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(low &lt; high)&#123;</span></span><br><span class="line"><span class="comment">               for(int i = right-1; i &gt;= left; i--)&#123;</span></span><br><span class="line"><span class="comment">                    list.add(matrix[high][i]);</span></span><br><span class="line"><span class="comment">                &#125; </span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(left &lt; right)&#123;</span></span><br><span class="line"><span class="comment">                for(int i = high-1; i &gt;= low+1; i--)&#123;</span></span><br><span class="line"><span class="comment">                    list.add(matrix[i][left]);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            low++;</span></span><br><span class="line"><span class="comment">            high--;</span></span><br><span class="line"><span class="comment">            left++;</span></span><br><span class="line"><span class="comment">            right--;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return list;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h2><h3 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><h3 id="解题思路-30"><a href="#解题思路-30" class="headerlink" title="解题思路"></a>解题思路</h3><p>java 递归解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"null,"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String res = root.val + <span class="string">","</span>;</span><br><span class="line">    res += serialize(root.left);</span><br><span class="line">    res += serialize(root.right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    String[] arr = data.split(<span class="string">","</span>);</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        queue.offer(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> help(queue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">help</span><span class="params">(Queue&lt;String&gt; queue)</span></span>&#123;</span><br><span class="line">    String val = queue.poll();</span><br><span class="line">    <span class="keyword">if</span>(val.equals(<span class="string">"null"</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(Integer.valueOf(val));</span><br><span class="line">    root.left = help(queue);</span><br><span class="line">    root.right = help(queue);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他解法：<a href="https://www.bilibili.com/video/BV1HE411J7xm?from=search&seid=1024036032281247729" target="_blank" rel="noopener">b站解析</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder(<span class="string">"["</span>);</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>; <span class="comment">// 用来记录当前节点及其后面非空节点的个数</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                ans.append(<span class="string">"null"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.append(node.val);</span><br><span class="line">                sum--;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum != <span class="number">0</span>) &#123;</span><br><span class="line">                ans.append(<span class="string">","</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.append(<span class="string">"]"</span>);</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        String s = data.substring(<span class="number">1</span>, data.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">""</span>.equals(s)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// data = "[]"</span></span><br><span class="line">        &#125;</span><br><span class="line">        String[] a = s.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(change(a[index++]));</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; index &lt; a.length) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">"null"</span>.equals(a[index])) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> TreeNode(change(a[index++]));</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; a.length &amp;&amp; !<span class="string">"null"</span>.equals(a[index])) &#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> TreeNode(change(a[index++]));</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(<span class="number">0</span>) == <span class="string">'-'</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            flag = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; s.length(); i++) &#123;</span><br><span class="line">            res = res * <span class="number">10</span> + s.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res * flag;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h2><h3 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><h3 id="解题思路-31"><a href="#解题思路-31" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实就是维护两个栈，首先第一个栈是普通的数据栈，跟我们平常的栈一样，存储入栈数据；第二个栈就是建立在第一个栈的基础之上，他是维护第一个栈，就是去维护第一个栈中元素的最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; datastack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minstack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        datastack.push(x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(minstack.isEmpty()||minstack.peek()&gt;x)&#123;</span><br><span class="line">            minstack.push(datastack.peek());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            minstack.push(minstack.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//栈的获取栈顶元素pop函数为peek()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!datastack.isEmpty())&#123;</span><br><span class="line">            datastack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!minstack.isEmpty())&#123;</span><br><span class="line">            minstack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> datastack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minstack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他解法：<a href="https://www.bilibili.com/video/BV1Ga4y1t7nG?from=search&seid=2204680535616609379" target="_blank" rel="noopener">b站up主解析</a></p><h2 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a>最长不含重复字符的子字符串</h2><h3 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h3><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><h3 id="解题思路-32"><a href="#解题思路-32" class="headerlink" title="解题思路"></a>解题思路</h3><p>双指针+哈希表</p><ul><li>哈希表 dis 统计： 指针 j 遍历字符 s ，哈希表统计字符 s[j] 最后一次出现的索引 。</li><li>更新左指针 i ： 根据上轮左指针 i 和 dic[s[j]] ，每轮更新左边界 i ，保证区间 [i + 1, j] 内无重复字符且最大。<br>i=max(dic[s[j]],i)</li><li>更新结果 res ： 取上轮 res 和本轮双指针区间 [i + 1,j] 的宽度（即 j - i ）中的最大值。<br>res=max(res,j−i)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i=-<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(j)))</span><br><span class="line">                i=Math.max(map.get(s.charAt(j)),i);<span class="comment">//map里的内容与即将放入的j对比，更新i的值</span></span><br><span class="line">            map.put(s.charAt(j),j);</span><br><span class="line">            res=Math.max(res,j-i);<span class="comment">//放入j，更新结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="把数字翻译成字符串"><a href="#把数字翻译成字符串" class="headerlink" title="把数字翻译成字符串"></a>把数字翻译成字符串</h2><h3 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><h3 id="解题思路-33"><a href="#解题思路-33" class="headerlink" title="解题思路"></a>解题思路</h3><p>动态规划问题，考虑bp[i]=bp[i-1]还是bp[i]=bp[i-1]+bp[i-2],<br>如果新加入的数字和前一个数字可以组合，就加上bp[i-2]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String s=String.valueOf(num);</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">int</span>[] bp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        bp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        bp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            bp[i]=bp[i-<span class="number">1</span>];</span><br><span class="line">            String tmp=s.substring(i-<span class="number">2</span>,i);</span><br><span class="line">            <span class="keyword">if</span>(tmp.compareTo(<span class="string">"10"</span>)&gt;=<span class="number">0</span>&amp;&amp;tmp.compareTo(<span class="string">"25"</span>)&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                bp[i]+=bp[i-<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><h3 id="题目描述-34"><a href="#题目描述-34" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p><h3 id="解题思路-34"><a href="#解题思路-34" class="headerlink" title="解题思路"></a>解题思路</h3><p>s:abc<br>p:.bc或者abc<br>s[i]=p[i]||p[i]=’.’</p><p>有：</p><p><em>表示出现零次<br>s:bc<br>p:a</em>bc<br>保持s不变，p前两个元素去除</p><p><em>表示出现一次或者多次<br>s:aabc<br>p:a</em>bc<br>保持p不变，s不断减去一个元素</p><p>有<em>的两个路要全试一遍<br>比如出现s:<br>s:abb<br>p:a</em>abb这种情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s.length()==<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> fristmatch=(s.length()!=<span class="number">0</span>)&amp;&amp;(s.charAt(<span class="number">0</span>)==p.charAt(<span class="number">0</span>)||p.charAt(<span class="number">0</span>)==<span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">if</span>(p.length()&gt;=<span class="number">2</span>&amp;&amp;p.charAt(<span class="number">1</span>)==<span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> isMatch(s,p.substring(<span class="number">2</span>))||(fristmatch&amp;&amp;isMatch(s.substring(<span class="number">1</span>),p));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fristmatch&amp;&amp;isMatch(s.substring(<span class="number">1</span>),p.substring(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他解法：<a href="https://blog.csdn.net/qq_28410301/article/details/100182901" target="_blank" rel="noopener">动态规划DP</a></p><p><a href="https://www.bilibili.com/video/BV13441117i4?p=1" target="_blank" rel="noopener">视频解析</a></p><h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><h3 id="题目描述-35"><a href="#题目描述-35" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><h3 id="解题思路-35"><a href="#解题思路-35" class="headerlink" title="解题思路"></a>解题思路</h3><p>前序遍历的第一个节点是根节点，只要找到根节点在中序遍历中的位置，在根节点之前被访问的节点都位于左子树，在根节点之后被访问的节点都位于右子树，由此可知左子树和右子树分别有多少个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder==<span class="keyword">null</span>||preorder.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> index=findIndex(preorder,inorder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建左子树，右子树</span></span><br><span class="line">        root.left=buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>,index+<span class="number">1</span>),</span><br><span class="line">        Arrays.copyOfRange(inorder,<span class="number">0</span>,index));</span><br><span class="line"></span><br><span class="line">        root.right=buildTree(Arrays.copyOfRange(preorder,index+<span class="number">1</span>,preorder.length),</span><br><span class="line">        Arrays.copyOfRange(inorder,index+<span class="number">1</span>,inorder.length));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findIndex</span><span class="params">(<span class="keyword">int</span>[] preorder,<span class="keyword">int</span>[] inorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]==preorder[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：<a href="https://www.bilibili.com/video/BV1f741197Rx?from=search&seid=16504896464128155223" target="_blank" rel="noopener">up主讲解</a></p><h2 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h2><h3 id="题目描述-36"><a href="#题目描述-36" class="headerlink" title="题目描述"></a>题目描述</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。</p><p>示例：</p><p>输入：board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCCED”</p><p>输出：true</p><h3 id="解题思路-36"><a href="#解题思路-36" class="headerlink" title="解题思路"></a>解题思路</h3><p>深搜+回溯，深搜的过程其实就是对四个方向的一个递归调用的过程，回溯的话是为了消除某一次递归调用所产生的路径不能匹配模式串所产生的影响要被消除掉，消除的结果就是对这条路径上的每一个位置进行状态初始化，即标记为未被遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[i].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(solve(board,word,i,j,visit,<span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="comment">//找到一种情况即可</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board,String word,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">boolean</span>[][] vis,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;=board.length||y&lt;<span class="number">0</span>||y&gt;=board[<span class="number">0</span>].length||vis[x][y])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(word.charAt(index)!=board[x][y])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index==word.length()-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vis[x][y]=<span class="keyword">true</span>;<span class="comment">//位置标记</span></span><br><span class="line">        <span class="keyword">boolean</span> flag=solve(board,word,x+<span class="number">1</span>,y,vis,index+<span class="number">1</span>)||</span><br><span class="line">                     solve(board,word,x-<span class="number">1</span>,y,vis,index+<span class="number">1</span>)||</span><br><span class="line">                     solve(board,word,x,y+<span class="number">1</span>,vis,index+<span class="number">1</span>)||</span><br><span class="line">                     solve(board,word,x,y-<span class="number">1</span>,vis,index+<span class="number">1</span>);</span><br><span class="line">        vis[x][y]=<span class="keyword">false</span>; <span class="comment">//回溯，bfs关键步骤</span></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h2><h3 id="题目描述-37"><a href="#题目描述-37" class="headerlink" title="题目描述"></a>题目描述</h3><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><h3 id="解题思路-37"><a href="#解题思路-37" class="headerlink" title="解题思路"></a>解题思路</h3><p>可以剪枝，向左和向上的不用遍历，只用遍历向右和向下的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,m,n,k,visit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">            sum+=i%<span class="number">10</span>;</span><br><span class="line">            i/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j!=<span class="number">0</span>)&#123;</span><br><span class="line">            sum+=j%<span class="number">10</span>;</span><br><span class="line">            j/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">boolean</span>[][] vis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||i&gt;=m||j&gt;=n||sum(i,j)&gt;k||vis[i][j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[i][j]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+dfs(i+<span class="number">1</span>,j,m,n,k,vis)</span><br><span class="line">        <span class="comment">//+dfs(i-1,j,m,n,k,vis)</span></span><br><span class="line">        +dfs(i,j+<span class="number">1</span>,m,n,k,vis);</span><br><span class="line">        <span class="comment">//+dfs(i,j-1,m,n,k,vis);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h2><h3 id="题目描述-38"><a href="#题目描述-38" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><h3 id="解题思路-38"><a href="#解题思路-38" class="headerlink" title="解题思路"></a>解题思路</h3><p>不难发现，将长度为n的绳子剪成m段。满足每段都是n/m时，乘积最大。但n/m可能不是整数。把剩下的left长度分给num，left段，即有left段长度为num+1,有m-left段长度为num。然后遍历段数从2到n找到最大值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            ans=Math.max(ans,mylength(n,i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mylength</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num=n/m;</span><br><span class="line">        <span class="keyword">int</span> remain=n%m;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.pow(num,m-remain))*(<span class="keyword">int</span>)(Math.pow(num+<span class="number">1</span>,remain));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剪绳子-II"><a href="#剪绳子-II" class="headerlink" title="剪绳子 II"></a>剪绳子 II</h2><h3 id="题目描述-39"><a href="#题目描述-39" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m] 。请问 k[0]<em>k[1]</em>…*k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><h3 id="解题思路-39"><a href="#解题思路-39" class="headerlink" title="解题思路"></a>解题思路</h3><p>5：2+3  6：3+3 &gt;6的数可以切分为2或者3，优先考虑3（递推得出结论）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if(n==2) return 1;</span></span><br><span class="line">        <span class="comment">//if(n==3) return 2;</span></span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">3</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">4</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">long</span> ans=<span class="number">1</span>; <span class="comment">//一定是long类型</span></span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">4</span>)&#123;</span><br><span class="line">            ans*=<span class="number">3</span>;</span><br><span class="line">            ans%=<span class="number">1000000007</span>;</span><br><span class="line">            n-=<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(ans*n%<span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h2><h3 id="题目描述-40"><a href="#题目描述-40" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”、”-1E-16”及”12e+5.4”都不是。</p><h3 id="解题思路-40"><a href="#解题思路-40" class="headerlink" title="解题思路"></a>解题思路</h3><p>模拟题，练习意义不大，所以使用了库函数Double.parseDouble转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.endsWith(<span class="string">"f"</span>) || s.endsWith(<span class="string">"d"</span>) || s.endsWith(<span class="string">"F"</span>) || s.endsWith(<span class="string">"D"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Double.parseDouble(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class Solution &#123;</span></span><br><span class="line"><span class="comment">    public boolean isNumeric(char[] str) &#123;</span></span><br><span class="line"><span class="comment">        // 标志小数点和指数</span></span><br><span class="line"><span class="comment">        boolean point = false, exp = false;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; str.length; i++) &#123;</span></span><br><span class="line"><span class="comment">            if (str[i] == '+' || str[i] == '-') &#123;</span></span><br><span class="line"><span class="comment">                // +-号后面必定为数字 或 后面为.（-.123 = -0.123）</span></span><br><span class="line"><span class="comment">                //如果没有下一位或者下一位部位数字或者下一位为小数点，直接返回</span></span><br><span class="line"><span class="comment">                if (i + 1 == str.length </span></span><br><span class="line"><span class="comment">                    || !(str[i + 1] &gt;= '0' &amp;&amp; str[i + 1] &lt;= '9' </span></span><br><span class="line"><span class="comment">                         || str[i + 1] == '.')) &#123; </span></span><br><span class="line"><span class="comment">                    return false;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                // +-号只出现在第一位或eE的后一位</span></span><br><span class="line"><span class="comment">                if (!(i == 0 || str[i-1] == 'e' || str[i-1] == 'E')) &#123;</span></span><br><span class="line"><span class="comment">                    return false;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125; else if (str[i] == '.') &#123;</span></span><br><span class="line"><span class="comment">                // .后面必定为数字 或为最后一位（233. = 233.0）</span></span><br><span class="line"><span class="comment">                if (point || exp </span></span><br><span class="line"><span class="comment">                    || !(i+1 &lt; str.length &amp;&amp; str[i+1] &gt;= '0' &amp;&amp; str[i+1] &lt;= '9')) &#123; </span></span><br><span class="line"><span class="comment">                    return false;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                point = true;</span></span><br><span class="line"><span class="comment">            &#125; else if (str[i] == 'e' || str[i] == 'E') &#123;</span></span><br><span class="line"><span class="comment">                // eE后面必定为数字或+-号</span></span><br><span class="line"><span class="comment">                if (exp || i + 1 == str.length </span></span><br><span class="line"><span class="comment">                        || !(str[i + 1] &gt;= '0' &amp;&amp; str[i + 1] &lt;= '9' </span></span><br><span class="line"><span class="comment">                        || str[i + 1] == '+' </span></span><br><span class="line"><span class="comment">                        || str[i + 1] == '-')) &#123; </span></span><br><span class="line"><span class="comment">                    return false;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                exp = true;</span></span><br><span class="line"><span class="comment">            &#125; else if (str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') &#123;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">                return false;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return true;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="数组中数字出现的次数"><a href="#数组中数字出现的次数" class="headerlink" title="数组中数字出现的次数"></a>数组中数字出现的次数</h2><h3 id="题目描述-41"><a href="#题目描述-41" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><h3 id="解题思路-41"><a href="#解题思路-41" class="headerlink" title="解题思路"></a>解题思路</h3><p>所有值异或出来的结果会有某一位数字为1，根据这个1所在的位置把数组分为两部分，两个不相等的数字肯定被分为两个不同组，然后分别异或就可以得到这个数字。</p><p>1&lt;&lt;n相当于1*2^n</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            sum^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> y=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((y&amp;sum)==<span class="number">0</span>)&#123;</span><br><span class="line">            y=y&lt;&lt;<span class="number">1</span>; <span class="comment">//找到第y位异或为1的位置,y数字保存这个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((y&amp;nums[i])==<span class="number">0</span>)&#123;</span><br><span class="line">                res[<span class="number">0</span>]^=nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[<span class="number">1</span>]^=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组中数字出现的次数-II"><a href="#数组中数字出现的次数-II" class="headerlink" title="数组中数字出现的次数 II"></a>数组中数字出现的次数 II</h2><h3 id="题目描述-42"><a href="#题目描述-42" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><h3 id="解题思路-42"><a href="#解题思路-42" class="headerlink" title="解题思路"></a>解题思路</h3><p>排序，有点偷懒的做法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>||nums[<span class="number">0</span>]!=nums[<span class="number">1</span>])  <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums[len-<span class="number">2</span>]!=nums[len-<span class="number">1</span>])  <span class="keyword">return</span> nums[len-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(((nums[i]^nums[i-<span class="number">1</span>])!=<span class="number">0</span>)&amp;&amp;((nums[i]^nums[i+<span class="number">1</span>])!=<span class="number">0</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他解法：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/solution/mian-shi-ti-56-ii-shu-zu-zhong-shu-zi-chu-xian-d-4/" target="_blank" rel="noopener">自动机+位运算</a></p><h2 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a>和为s的两个数字</h2><h3 id="题目描述-43"><a href="#题目描述-43" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><h3 id="解题思路-43"><a href="#解题思路-43" class="headerlink" title="解题思路"></a>解题思路</h3><p>递增数组，所以使用双指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum=nums[left]+nums[right];</span><br><span class="line">            <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[left],nums[right]&#125;;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h2><h3 id="题目描述-44"><a href="#题目描述-44" class="headerlink" title="题目描述"></a>题目描述</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><h3 id="解题思路-44"><a href="#解题思路-44" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum; <span class="comment">// 用来去统计逆序对的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span> [] nums)</span> </span>&#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = nums.length - <span class="number">1</span>;</span><br><span class="line">        divide(l ,r, nums);</span><br><span class="line">        <span class="keyword">return</span>  sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            divide(l, mid, array);</span><br><span class="line">            divide(mid + <span class="number">1</span>, r, array);</span><br><span class="line">            merge(l, r, mid, array);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> mid, <span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = l; <span class="comment">// 左区间的起点</span></span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>; <span class="comment">// 右区间的起点</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; array[j]) &#123;</span><br><span class="line">                temp[index++] = array[j++];</span><br><span class="line">                sum += mid - i + <span class="number">1</span>; <span class="comment">// 这一行是核心，去统计逆序对个数</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[index++] = array[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            temp[index++] = array[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= r) &#123;</span><br><span class="line">            temp[index++] = array[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; k++) &#123;</span><br><span class="line">            array[k] = temp[index++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.arraycopy(temp,0,array,0,r-l+1); 将temp数组里从索引为0的元素开始, 复制到数组array里的索引为0的位置, 复制的元素个数为length个. </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法讲解：<a href="https://www.bilibili.com/video/BV1S7411G7Mg?from=search&seid=12482759876812943200" target="_blank" rel="noopener">b站up主解析</a></p><h2 id="队列的最大值"><a href="#队列的最大值" class="headerlink" title="队列的最大值"></a>队列的最大值</h2><h3 id="题目描述-45"><a href="#题目描述-45" class="headerlink" title="题目描述"></a>题目描述</h3><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。若队列为空，pop_front 和 max_value 需要返回 -1。</p><h3 id="解题思路-45"><a href="#解题思路-45" class="headerlink" title="解题思路"></a>解题思路</h3><p>使用Deque记录队列最大值，当一个元素加进队列中把之前比deque中比它小的最大记录值去除；当一个元素出队列判断该元素是否为最大值，是的话更新Queue中的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    Deque&lt;Integer&gt; deque;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        deque=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(deque.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> deque.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        queue.add(value);</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty()&amp;&amp;deque.getLast()&lt;value)&#123;</span><br><span class="line">            deque.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.add(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(queue.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(ans==deque.peek())&#123;</span><br><span class="line">            deque.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目解析: <a href="https://www.bilibili.com/video/BV1Zc411h7b5?from=search&seid=9506675113429161345" target="_blank" rel="noopener">up主xmmmm</a></p><h2 id="在排序数组中查找数字-I"><a href="#在排序数组中查找数字-I" class="headerlink" title="在排序数组中查找数字 I"></a>在排序数组中查找数字 I</h2><h3 id="题目描述-46"><a href="#题目描述-46" class="headerlink" title="题目描述"></a>题目描述</h3><p>统计一个数字在排序数组中出现的次数。</p><h3 id="解题思路-46"><a href="#解题思路-46" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于排序过的数组使用二分，水题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;nums.length&amp;&amp;nums[left++]==target)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0～n-1中缺失的数字"><a href="#0～n-1中缺失的数字" class="headerlink" title="0～n-1中缺失的数字"></a>0～n-1中缺失的数字</h2><h3 id="题目描述-47"><a href="#题目描述-47" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><h3 id="解题思路-47"><a href="#解题思路-47" class="headerlink" title="解题思路"></a>解题思路</h3><p>递增数组查找数字，二分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==mid)&#123; </span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a>和为s的连续正数序列</h2><h3 id="题目描述-48"><a href="#题目描述-48" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><h3 id="解题思路-48"><a href="#解题思路-48" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题当前可以用等差数列的求和公式来计算滑动窗口的和。不过我这里没有使用求和公式，是为了展示更通用的解题思路。实际上，把题目中的正整数序列换成任意的递增整数序列，这个方法都可以解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;<span class="comment">//双指针（滑动窗口）初始都为1</span></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=target/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;target)&#123;</span><br><span class="line">                sum+=j;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">                sum-=i;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[j-i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)&#123;</span><br><span class="line">                    arr[k-i]=k;</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(arr);</span><br><span class="line">                sum-=i;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h2><h3 id="题目描述-49"><a href="#题目描述-49" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><h3 id="解题思路-49"><a href="#解题思路-49" class="headerlink" title="解题思路"></a>解题思路</h3><p>双指针做法,实际思想是快排.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> left =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=nums[left];</span><br><span class="line">                nums[left]=nums[right];</span><br><span class="line">                nums[right]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><h3 id="题目描述-50"><a href="#题目描述-50" class="headerlink" title="题目描述"></a>题目描述</h3><p>我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p><h3 id="解题思路-50"><a href="#解题思路-50" class="headerlink" title="解题思路"></a>解题思路</h3><p>假设当前存在 3 个数组 nums2, nums3, nums5 分别代表丑数序列从 1 开始分别乘以 2, 3, 5 的序列， 即</p><p>nums2 = {1<em>2, 2</em>2, 3<em>2, 4</em>2, 5<em>2, 6</em>2,…}</p><p>nums3 = {1<em>3, 2</em>3, 3<em>3, 4</em>3, 5<em>3, 6</em>3,…}</p><p>nums5 = {1<em>5, 2</em>5, 3<em>5, 4</em>5, 5<em>5, 6</em>5,…}</p><p>那么， 最终的丑数序列实际上就是这 3 个有序序列对的合并结果， 计算丑数序列也就是相当于 合并 3 个有序序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>; <span class="comment">// 遍历丑数*2的队列</span></span><br><span class="line">        <span class="keyword">int</span> index2 = <span class="number">0</span>; <span class="comment">// 遍历丑数*3的队列</span></span><br><span class="line">        <span class="keyword">int</span> index3 = <span class="number">0</span>; <span class="comment">// 遍历丑数*5的队列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            a[i]=Math.min(a[index1]*<span class="number">2</span>,Math.min(a[index2]*<span class="number">3</span>,a[index3]*<span class="number">5</span>));</span><br><span class="line">            <span class="keyword">if</span>(a[i]==a[index1]*<span class="number">2</span>)&#123;</span><br><span class="line">                index1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==a[index2]*<span class="number">3</span>)&#123;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==a[index3]*<span class="number">5</span>)&#123;</span><br><span class="line">                index3++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a>礼物的最大价值</h2><h3 id="题目描述-51"><a href="#题目描述-51" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><h3 id="解题思路-51"><a href="#解题思路-51" class="headerlink" title="解题思路"></a>解题思路</h3><p>f(i, j) = max{f(i - 1, j), f(i, j - 1)} + grid[i][j].</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) grid[i][j] += grid[i][j - <span class="number">1</span>] ;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) grid[i][j] += grid[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> grid[i][j] += Math.max(grid[i][j - <span class="number">1</span>], grid[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) <span class="comment">// 初始化第一行</span></span><br><span class="line">            grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) <span class="comment">// 初始化第一列</span></span><br><span class="line">            grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) </span><br><span class="line">                grid[i][j] += Math.max(grid[i][j - <span class="number">1</span>], grid[i - <span class="number">1</span>][j]);</span><br><span class="line">        <span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">多开一行一列的空间能够让代码更简洁</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int maxValue(int[][] grid) &#123;</span></span><br><span class="line"><span class="comment">        int row=grid.length,col=grid[0].length;</span></span><br><span class="line"><span class="comment">        int[][] dp=new int[row+1][col+1];</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;=row;i++)&#123;</span></span><br><span class="line"><span class="comment">            for(int j=1;j&lt;=col;j++)&#123;</span></span><br><span class="line"><span class="comment">                dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1])+grid[i-1][j-1];</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return dp[row][col];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h2><h3 id="题目描述-52"><a href="#题目描述-52" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><h3 id="解题思路-52"><a href="#解题思路-52" class="headerlink" title="解题思路"></a>解题思路</h3><p>快慢指针，先让快指针走k步，然后两个指针同步走，当快指针走到头时，慢指针就是链表倒数第k个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode frontNode=head;</span><br><span class="line">        ListNode behindNode=head;</span><br><span class="line">        <span class="keyword">while</span>(frontNode!=<span class="keyword">null</span>&amp;&amp;k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            frontNode=frontNode.next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(frontNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            frontNode=frontNode.next;</span><br><span class="line">            behindNode=behindNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> behindNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><h3 id="题目描述-53"><a href="#题目描述-53" class="headerlink" title="题目描述"></a>题目描述</h3><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><h3 id="解题思路-53"><a href="#解题思路-53" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>定义两个指针： pre 和 cur ；pre 在前 cur 在后。</li><li>每次让 pre 的 next 指向 cur ，实现一次局部反转</li><li>局部反转完成之后， pre 和 cur 同时往前移动一个位置</li><li>循环上述过程，直至 pre 到达链表尾部.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode cur=<span class="keyword">null</span>;</span><br><span class="line">        ListNode pre=head;</span><br><span class="line">        ListNode tmp=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(pre!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            tmp=pre.next;</span><br><span class="line">            pre.next=cur;</span><br><span class="line">            cur=pre;</span><br><span class="line">            pre=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>其他解法:<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/fan-zhuan-lian-biao-yi-dong-de-shuang-zhi-zhen-jia/" target="_blank" rel="noopener">递归</a></li></ul><h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><h3 id="题目描述-54"><a href="#题目描述-54" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构).B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><h3 id="解题思路-54"><a href="#解题思路-54" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先在isSubStructure()函数中进行判断：</p><ul><li>（1）利用fun判断以根节点为开始的结构是否为真；</li><li>（2）若不为真，同样利用fun对其左子树判断；</li><li>（3）都不为真，再对其右子树判断。<br>只要三者有一个为真，则结果为真。</li></ul><p>以上是主体部分，接下来再对fun进行分析：<br>fun是一个工具函数，用来判断当前结构与B是否完全相同，所以必须满足三个条件：</p><ul><li>（1）首先当前节点值必须与B的节点值相同；</li><li>（2）当前节点的左子树结构必须与B的左子树结构完全相同（递归调用fun工具函数）；</li><li>（3）当前节点的右子树结构必须与B的右子树结构完全相同（递归调用fun工具函数）；</li></ul><p>接下来分析边界条件：</p><ul><li>对于isSubStructure（）函数中，如果刚开始传进来的A,B只要有一个为空，则结果为false；</li><li>对于fun（）函数，在比较过程中，如果B比完了，则说明存在该子结构，如果B还有节点，而A没有了，则说明A中不存在该子结构，返回false。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span>||B==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(A,B)||isSubStructure(A.left,B)||isSubStructure(A.right,B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode a,TreeNode b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//必须先判断b边界条件</span></span><br><span class="line">        <span class="keyword">if</span>(a==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> (a.val==b.val)&amp;&amp;dfs(a.left,b.left)&amp;&amp;dfs(a.right,b.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h2><h3 id="题目描述-55"><a href="#题目描述-55" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><h3 id="解题思路-55"><a href="#解题思路-55" class="headerlink" title="解题思路"></a>解题思路</h3><p>递归解法,非递归就按正常思路往cur指针加数然后往后更新cur指针,最后把其中一个剩下的非空加入cur就行.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">            l1.next=mergeTwoLists(l1.next,l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next=mergeTwoLists(l1,l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/solution/mian-shi-ti-25-he-bing-liang-ge-pai-xu-de-lian-b-2/" target="_blank" rel="noopener">解析</a></p><h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h2><h3 id="题目描述-56"><a href="#题目描述-56" class="headerlink" title="题目描述"></a>题目描述</h3><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><h3 id="解题思路-56"><a href="#解题思路-56" class="headerlink" title="解题思路"></a>解题思路</h3><p>左右子树调换,使用递归简单解答,边界条件为root为空.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode tmp=root.left;</span><br><span class="line">        root.left=mirrorTree(root.right);</span><br><span class="line">        root.right=mirrorTree(tmp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h2><h3 id="题目描述-57"><a href="#题目描述-57" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><h3 id="解题思路-57"><a href="#解题思路-57" class="headerlink" title="解题思路"></a>解题思路</h3><p>对称二叉树定义： 对于树中 任意两个对称节点 L 和 R ，一定有：</p><ul><li>L.val = R.val ：即此两对称节点值相等。</li><li>L.left.val = R.right.val ：即 L 的 左子节点 和 R 的 右子节点 对称；</li><li>L.right.val = R.left.val ：即 L 的 右子节点 和 R 的 左子节点 对称。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> help(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">help</span><span class="params">(TreeNode l,TreeNode r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="keyword">null</span>&amp;&amp;r==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="keyword">null</span>||r==<span class="keyword">null</span>||l.val!=r.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> help(l.left,r.right)&amp;&amp;help(l.right,r.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h2><h3 id="题目描述-58"><a href="#题目描述-58" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p><h3 id="解题思路-58"><a href="#解题思路-58" class="headerlink" title="解题思路"></a>解题思路</h3><p>队列尾部进头部出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[n-k+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//dq里面存的是数组的index, 不是数组的值</span></span><br><span class="line">        Deque&lt;Integer&gt; deque=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//移除头部,保证窗口长度</span></span><br><span class="line">            <span class="keyword">if</span>(!deque.isEmpty()&amp;&amp;deque.getFirst()&lt;(i-k+<span class="number">1</span>))&#123;</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//移除尾部比当前要加入的值小的元素(不可能答案)</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty()&amp;&amp;nums[i]&gt;=nums[deque.getLast()])&#123;</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//尾部加入,窗口滑动</span></span><br><span class="line">            deque.addLast(i);</span><br><span class="line">            <span class="comment">//保证滑动窗口长度,并记录最大值</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=k-<span class="number">1</span>)&#123;</span><br><span class="line">                res[i-k+<span class="number">1</span>]=nums[deque.getFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解题思路:<a href="https://www.bilibili.com/video/BV1YV411o7Gr?from=search&seid=9705276703749479461" target="_blank" rel="noopener">up主xmmmmmm</a></p><h2 id="n个骰子的点数"><a href="#n个骰子的点数" class="headerlink" title="n个骰子的点数"></a>n个骰子的点数</h2><h3 id="题目描述-59"><a href="#题目描述-59" class="headerlink" title="题目描述"></a>题目描述</h3><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p><h3 id="解题思路-59"><a href="#解题思路-59" class="headerlink" title="解题思路"></a>解题思路</h3><p>嗯这道题算是简单题我晕了,ac后以后再看吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] twoSum(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][n*<span class="number">6</span>+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//一个骰子能摇出点数的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)</span><br><span class="line">            dp[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//骰子个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=<span class="number">6</span>*i;j++)<span class="comment">//i个骰子能要出的点数</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">6</span>;k++)&#123;<span class="comment">//第i个骰子要出的点数</span></span><br><span class="line">                    <span class="keyword">if</span>(j&lt;k)<span class="keyword">break</span>;</span><br><span class="line">                    dp[i][j]+=dp[i-<span class="number">1</span>][j-k];<span class="comment">//前i-1个骰子摇出的点数加上本次摇出的点数</span></span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> total=Math.pow(<span class="number">6</span>,n);</span><br><span class="line">        <span class="keyword">double</span>[] res=<span class="keyword">new</span>  <span class="keyword">double</span>[<span class="number">5</span>*n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> ind=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;=n*<span class="number">6</span>;i++)&#123;</span><br><span class="line">            res[ind++]=dp[n][i]/total;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h2><h3 id="题目描述-60"><a href="#题目描述-60" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><h3 id="解题思路-60"><a href="#解题思路-60" class="headerlink" title="解题思路"></a>解题思路</h3><p>把压栈的元素按顺序压入，当栈顶元素和出栈的第一个元素相同，则将该元素弹出，出栈列表指针后移并继续判断。最后判断出栈列表指针是否指向出栈列表的末尾即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">      Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">      <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> num:pushed)&#123;</span><br><span class="line">          stack.push(num);</span><br><span class="line">          <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;stack.peek()==popped[i])&#123;</span><br><span class="line">              stack.pop();</span><br><span class="line">              i++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h2><h3 id="题目描述-61"><a href="#题目描述-61" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p><h3 id="解题思路-61"><a href="#解题思路-61" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于二叉搜索树,后序遍历</p><p>思路就是左节点-右节点-跟节点,然后找到左右子树边界判断根节点的右子树是否满足二叉搜索树.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postorder.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(postorder,<span class="number">0</span>,postorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] postorder,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 当前区域不合法的时候直接返回true就好</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> root=postorder[r]; <span class="comment">// 当前树的根节点的值</span></span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k&lt;r&amp;&amp;postorder[k]&lt;root)&#123;  <span class="comment">//找到右节点</span></span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;r;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(postorder[i]&lt;root)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(postorder,l,k-<span class="number">1</span>)&amp;&amp;dfs(postorder,k,r-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.bilibili.com/video/BV12p4y1C7ks?from=search&seid=18233201467498089376" target="_blank" rel="noopener">解析</a></p><h2 id="1～n整数中1出现的次数"><a href="#1～n整数中1出现的次数" class="headerlink" title="1～n整数中1出现的次数"></a>1～n整数中1出现的次数</h2><h3 id="题目描述-62"><a href="#题目描述-62" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p><h3 id="解题思路-62"><a href="#解题思路-62" class="headerlink" title="解题思路"></a>解题思路</h3><p>暴力解决,超时QAQ,不管了,先贴一个大佬的方案:</p><p>求高位以及不断乘10取当前位的i需要用long表示，因为取一些很大的int的高位就溢出了.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int countDigitOne(int n) &#123;</span></span><br><span class="line"><span class="comment">        int sum=0;</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">            int x=i;</span></span><br><span class="line"><span class="comment">            while(x!=0)&#123;</span></span><br><span class="line"><span class="comment">                if(x%10==1)&#123;</span></span><br><span class="line"><span class="comment">                    sum++;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                x/=10;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return sum;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> i = <span class="number">1</span>;        <span class="comment">// 从个位开始遍历到最高位</span></span><br><span class="line"><span class="keyword">while</span>(n / i != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">long</span> high = n / (<span class="number">10</span> * i);  <span class="comment">// 高位</span></span><br><span class="line"><span class="keyword">long</span> cur = (n / i) % <span class="number">10</span>;   <span class="comment">// 当前位</span></span><br><span class="line"><span class="keyword">long</span> low = n - (n / i) * i;</span><br><span class="line"><span class="keyword">if</span>(cur == <span class="number">0</span>) &#123;</span><br><span class="line">count += high * i;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur == <span class="number">1</span>) &#123;</span><br><span class="line">count += high * i + (low + <span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">count += (high + <span class="number">1</span>) * i;</span><br><span class="line">&#125;</span><br><span class="line">i = i * <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h2><h3 id="题目描述-63"><a href="#题目描述-63" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p><h3 id="解题思路-63"><a href="#解题思路-63" class="headerlink" title="解题思路"></a>解题思路</h3><p>根节点遍历每条路径,符合的加入,然后递归遍历左右子树.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;(); </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        recur(root, sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode root, <span class="keyword">int</span> tar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        tar -= root.val;</span><br><span class="line">        <span class="keyword">if</span>(tar == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList(path));</span><br><span class="line">        recur(root.left, tar);</span><br><span class="line">        recur(root.right, tar);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, sum, <span class="number">0</span>, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, <span class="keyword">int</span> count, LinkedList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count += root.val;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == sum) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(list));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left, sum, count, list);</span><br><span class="line">        dfs(root.right, sum, count, list);</span><br><span class="line">        list.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h2><h3 id="题目描述-64"><a href="#题目描述-64" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><h3 id="解题思路-64"><a href="#解题思路-64" class="headerlink" title="解题思路"></a>解题思路</h3><p>用一个全局变量来记录遍历过程的上一个节点。</p><p>还是利用二叉搜索树的特点遍历 中序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,Node _left,Node _right) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Node pre = <span class="keyword">null</span>, head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        helper(root);</span><br><span class="line">        head.left = pre;</span><br><span class="line">        pre.right = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        helper(root.left);</span><br><span class="line"></span><br><span class="line">        root.left = pre;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span>)</span><br><span class="line">            pre.right = root;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            head = root;</span><br><span class="line"></span><br><span class="line">        pre = root;</span><br><span class="line">        helper(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h2><h3 id="题目描述-65"><a href="#题目描述-65" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><h3 id="解题思路-65"><a href="#解题思路-65" class="headerlink" title="解题思路"></a>解题思路</h3><p>通过在排序时传入一个自定义的 Comparator 实现，重新定义 String 列表内的排序方法，若拼接 s1 + s2 &gt; s2 + s1，那么显然应该把 s2 在拼接时放在前面，以此类推，将整个 String 列表排序后再拼接起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转化为String类型数组,</span></span><br><span class="line">        String[] s=<span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            s[i]=String.valueOf(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对其排序,这里使用了java1.8新特性Lambda 表达式,指向性符号表示进入了方法体内部,这里直接返回了语句</span></span><br><span class="line">        Arrays.sort(s,(s1,s2) -&gt; ((s1+s2).compareTo(s2+s1)) );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于要求返回String类型,这里使用stringbuilder连接</span></span><br><span class="line">        StringBuilder ans=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String i:s)&#123;</span><br><span class="line">            ans.append(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.bilibili.com/video/BV1Nz41187Ai?from=search&seid=15663311342427270941" target="_blank" rel="noopener">解析</a></p><p><a href="https://www.runoob.com/java/java8-lambda-expressions.html" target="_blank" rel="noopener">Lambda 表达式介绍</a></p><h2 id="数字序列中某一位的数字"><a href="#数字序列中某一位的数字" class="headerlink" title="数字序列中某一位的数字"></a>数字序列中某一位的数字</h2><h3 id="题目描述-66"><a href="#题目描述-66" class="headerlink" title="题目描述"></a>题目描述</h3><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p><h3 id="解题思路-66"><a href="#解题思路-66" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先，我们要明确的是，n是下标，从0开始的！</p><p>我们可以注意到规律 0<del>9有10个数字，10</del>99有90个数字，100<del>999有900个数字，so</del></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;<span class="number">10</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n&gt;i*(Math.pow(<span class="number">10</span>,i-<span class="number">1</span>))*<span class="number">9</span>)&#123;   <span class="comment">//循环结束后,i-1就是位数,n-1为表示还要找多少个</span></span><br><span class="line">            n -= i*Math.pow(<span class="number">10</span>,i-<span class="number">1</span>)*<span class="number">9</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] result = String.valueOf((<span class="keyword">int</span>) Math.pow(<span class="number">10</span>,i-<span class="number">1</span>) + (n-<span class="number">1</span>) / i).toCharArray();<span class="comment">//我们用字符串来接收值，方便找位数 result结果为我们要的那个数的</span></span><br><span class="line">        <span class="keyword">int</span> value = result[(n-<span class="number">1</span>)%i]-<span class="string">'0'</span>;    <span class="comment">//(n-1)%位数 得出我们要的第x位的数</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.bilibili.com/video/BV1oT4y1377D?from=search&seid=15015123032764534701" target="_blank" rel="noopener">还没看的题解</a></p><h2 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h2><h3 id="题目描述-67"><a href="#题目描述-67" class="headerlink" title="题目描述"></a>题目描述</h3><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><h3 id="解题思路-67"><a href="#解题思路-67" class="headerlink" title="解题思路"></a>解题思路</h3><p>大顶堆 小顶堆 做的时候直接copy别人的代码,以后有时间再看QAQ</p><p>把数据分为两部分，让左半部分永远元素个数永远大于等于右半部分，这样左端大顶堆的堆顶就是左半部分最大值，右端小顶堆的堆顶就是右半部分最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; A, B;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A = <span class="keyword">new</span> PriorityQueue&lt;&gt;(); <span class="comment">// 小顶堆，保存较大的一半</span></span><br><span class="line">        B = <span class="keyword">new</span> PriorityQueue&lt;&gt;((x, y) -&gt; (y - x)); <span class="comment">// 大顶堆，保存较小的一半</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.size() != B.size()) &#123;</span><br><span class="line">            A.add(num);</span><br><span class="line">            B.add(A.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            B.add(num);</span><br><span class="line">            A.add(B.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/solution/mian-shi-ti-41-shu-ju-liu-zhong-de-zhong-wei-shu-y/" target="_blank" rel="noopener">题目解析</a></p><p><a href="https://www.bilibili.com/video/BV1hi4y1b7z5?from=search&seid=6501042434139008323" target="_blank" rel="noopener">视频讲解</a></p><h2 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h2><h3 id="题目描述-68"><a href="#题目描述-68" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p><h3 id="解题思路-68"><a href="#解题思路-68" class="headerlink" title="解题思路"></a>解题思路</h3><p>对称遍历</p><ul><li>从左往右遍历累乘，结果保存在数组 res 中，此时 res[i] 表示，A[i] 左边所有元素的乘积</li><li>然后从右往左遍历累乘，获取A[i] 右边所有元素的乘积</li><li>两边遍历之后得到的 res，就是最终结果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructArr(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        <span class="keyword">int</span> n=a.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,cur=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            ans[i]=cur;  <span class="comment">//先乘左边的数,不包括自己</span></span><br><span class="line">            cur*=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>,cur=<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            ans[i]*=cur;  <span class="comment">//再乘右边的数,不包括自己</span></span><br><span class="line">            cur*=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h2><h3 id="题目描述-69"><a href="#题目描述-69" class="headerlink" title="题目描述"></a>题目描述</h3><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p><h3 id="解题思路-69"><a href="#解题思路-69" class="headerlink" title="解题思路"></a>解题思路</h3><p>不用加减乘除做加法的方法是使用按位异或和按位与运算。计算a + b等价于计算(a ^ b) + ((a &amp; b) &lt;&lt; 1)，其中((a &amp; b) &lt;&lt; 1)表示进位。因此令a等于(a &amp; b) &lt;&lt; 1，令b等于a ^ b，直到a变成0，然后返回b。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(a!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=a^b;</span><br><span class="line">            a=(a&amp;b)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            b=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扑克牌中的顺子"><a href="#扑克牌中的顺子" class="headerlink" title="扑克牌中的顺子"></a>扑克牌中的顺子</h2><h3 id="题目描述-70"><a href="#题目描述-70" class="headerlink" title="题目描述"></a>题目描述</h3><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p><h3 id="解题思路-70"><a href="#解题思路-70" class="headerlink" title="解题思路"></a>解题思路</h3><p>根据题意，此 5 张牌是顺子的 充分条件 如下：</p><ul><li>除大小王外，所有牌 无重复 ；</li><li>设此 5 张牌中最大的牌为 max ，最小的牌为 min （大小王除外），则需满足：max - min &lt; 5<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStraight</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>,min=<span class="number">14</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            max=Math.max(max,num);</span><br><span class="line">            min=Math.min(min,num);</span><br><span class="line">            <span class="keyword">if</span>(set.contains(num))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max-min&lt;<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="圆圈中最后剩下的数字"><a href="#圆圈中最后剩下的数字" class="headerlink" title="圆圈中最后剩下的数字"></a>圆圈中最后剩下的数字</h2><h3 id="题目描述-71"><a href="#题目描述-71" class="headerlink" title="题目描述"></a>题目描述</h3><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><h3 id="解题思路-71"><a href="#解题思路-71" class="headerlink" title="解题思路"></a>解题思路</h3><p>假设当前删除的位置是 idx，下一个删除的数字的位置是 idx + m 。但是，由于把当前位置的数字删除了，后面的数字会前移一位，所以实际的下一个位置是 idx + m - 1。由于数到末尾会从头继续数，所以最后取模一下，就是 (idx + m - 1) (mod n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            index=(index+m-<span class="number">1</span>)%n;</span><br><span class="line">            list.remove(index);</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/javajie-jue-yue-se-fu-huan-wen-ti-gao-su-ni-wei-sh/" target="_blank" rel="noopener">解析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;求职在即，《剑指offer》作为大家都推荐的一本应试宝典算法相关资料，确实也有刷一刷的必要。很多题目都比较经典，也涵盖了大多数的算法和数据结构。把自己刷题的过程做一个总结，权当是一个笔记。&lt;/p&gt;
&lt;p&gt;下面为本人在LeetCode上面刷的题目笔记，给出所有代码为本人提交Accepted后记录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="刷题" scheme="http://yoursite.com/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>权限管理思路</title>
    <link href="http://yoursite.com/2020/06/12/%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2020/06/12/%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</id>
    <published>2020-06-12T12:50:49.000Z</published>
    <updated>2020-06-14T09:43:43.250Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring-Boot-Vue-前后端分离开发，权限管理的一点思路"><a href="#Spring-Boot-Vue-前后端分离开发，权限管理的一点思路" class="headerlink" title="Spring Boot + Vue 前后端分离开发，权限管理的一点思路"></a>Spring Boot + Vue 前后端分离开发，权限管理的一点思路</h3><p>在传统的前后端不分的开发中，权限管理主要通过过滤器或者拦截器来进行（权限管理框架本身也是通过过滤器来实现功能），如果用户不具备某一个角色或者某一个权限，则无法访问某一个页面。</p><p>但是在前后端分离中，页面的跳转统统交给前端去做，后端只提供数据，这种时候，权限管理不能再按照之前的思路来。</p><a id="more"></a><p>首先要明确一点，前端是展示给用户看的，所有的菜单显示或者隐藏目的不是为了实现权限管理，而是为了给用户一个良好的体验，不能依靠前端隐藏控件来实现权限管理，即数据安全不能依靠前端。</p><p>这点就像普通的表单提交一样，前端做数据校验是为了提高效率，提高用户体验，后端才是真正的确保数据完整性。</p><p>所以，真正的数据安全管理是在后端实现的，后端在接口设计的过程中，就要确保每一个接口都是在满足某种权限的基础上才能访问，也就是说，不怕将后端数据接口地址暴露出来，即使暴露出来，只要你没有相应的角色，也是访问不了的。</p><p>前端为了良好的用户体验，需要将用户不能访问的接口或者菜单隐藏起来。</p><p>有人说，如果用户直接在地址拦输入某一个页面的路径，怎么办？此时，如果没有做任何额外的处理的话，用户确实可以通过直接输入某一个路径进入到系统中的某一个页面中，但是，不用担心数据泄露问题，因为没有相关的角色，就无法访问相关的接口。</p><p>但是，如果用户非这样操作，进入到一个空白的页面，用户体验不好，此时，我们可以使用 Vue 中的前置路由导航守卫，来监听页面跳转，如果用户想要去一个未获授权的页面，则直接在前置路由导航守卫中将之拦截下来，重定向到登录页，或者直接就停留在当前页，不让用户跳转，也可以顺手再给用户一点点未获授权的提示信息。</p><p>总而言之一句话，<strong>前端的所有操作，都是为了提高用户体验，不是为了数据安全，真正的权限校验要在后端来做</strong>，后端如果是 SSM 架构，建议使用 Shiro ，如果是 Spring Boot + 微服务，建议使用 Spring Security 。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Spring-Boot-Vue-前后端分离开发，权限管理的一点思路&quot;&gt;&lt;a href=&quot;#Spring-Boot-Vue-前后端分离开发，权限管理的一点思路&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot + Vue 前后端分离开发，权限管理的一点思路&quot;&gt;&lt;/a&gt;Spring Boot + Vue 前后端分离开发，权限管理的一点思路&lt;/h3&gt;&lt;p&gt;在传统的前后端不分的开发中，权限管理主要通过过滤器或者拦截器来进行（权限管理框架本身也是通过过滤器来实现功能），如果用户不具备某一个角色或者某一个权限，则无法访问某一个页面。&lt;/p&gt;
&lt;p&gt;但是在前后端分离中，页面的跳转统统交给前端去做，后端只提供数据，这种时候，权限管理不能再按照之前的思路来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="项目笔记" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Spring Boot" scheme="http://yoursite.com/tags/Spring-Boot/"/>
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>JavaStream</title>
    <link href="http://yoursite.com/2020/05/30/Java%E5%9F%BA%E7%A1%80/JavaStream/"/>
    <id>http://yoursite.com/2020/05/30/Java%E5%9F%BA%E7%A1%80/JavaStream/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2020-06-08T00:53:20.127Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  参考文档：</p><p>  <a href="https://blog.csdn.net/ycj_xiyang/article/details/83624642" target="_blank" rel="noopener">Java8-Stream API 详解</a></p><p>  <a href="https://blog.csdn.net/zxl646801924/article/details/90374320?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">java8 stream常用方法</a></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Stream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。</p><p>Java 8 中的 <strong>Stream 是对集合（Collection）对象功能的增强</strong>，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。</p><p>Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。</p><p>通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。</p><p>所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。</p><a id="more"></a><h2 id="Stream的概念"><a href="#Stream的概念" class="headerlink" title="Stream的概念"></a>Stream的概念</h2><p>流（Stream）是数据通道，用于操作数据源（集合，数组等）所生成的元素序列。整个流操作就是一条流水线，将元素放在流水线上一个个地进行处理。</p><p><strong>集合讲的的是数据，流讲的是计算。</strong></p><p>其中数据源便是原始集合，然后将如 <code>List&lt;T&gt;</code> 的集合转换为 <code>Stream&lt;T&gt;</code> 类型的流，并对流进行一系列的中间操作，比如过滤保留部分元素、对元素进行排序、类型转换等；最后再进行一个终端操作，可以把 Stream 转换回集合类型，也可以直接对其中的各个元素进行处理，比如打印、比如计算总数、计算最大值等等。</p><p>很重要的一点是，很多流操作本身就会返回一个流，所以多个操作可以直接连接起来。如果是以前，进行这么一系列操作，你需要做个迭代器或者 foreach 循环，然后遍历，一步步地地去完成这些操作；但是如果使用流，你便可以直接声明式地下指令，流会帮你完成这些操作。</p><p>注意：</p><ol><li>Stream不会存储元素</li><li>Stream不会改变源对象，相反他们会返回一个持有结果的新的Stream</li><li>Stream操作是延迟执行的，这意味着他们等到需要结果的时候才会执行（惰性求值）</li></ol><h2 id="Stream操作的三个步骤"><a href="#Stream操作的三个步骤" class="headerlink" title="Stream操作的三个步骤"></a>Stream操作的三个步骤</h2><ol><li><p>创建</p><p>一个数据源（如：集合，数组）获取一个流</p></li><li><p>中间操作</p><p>一个中间操作链，对数据源的数据进行处理</p></li><li><p>终止操作（终端操作）</p><p>一个终止操作，执行中间操作链，并产生结果</p></li></ol><h2 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h2><ol><li><code>Collection</code>提供了两个方法<code>stream()</code>与<code>paralleStream()</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Stream&lt;Integer&gt; stream = list.stream();<span class="comment">//串行流</span></span><br><span class="line">Stream&lt;Integer&gt; integerStream = list.parallelStream();<span class="comment">//并行流</span></span><br></pre></td></tr></table></figure><ol start="2"><li>通过<code>Arrays</code>中的<code>Stream()</code>获取一个数组流。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] integers =&#123;&#125;;</span><br><span class="line">Stream&lt;Integer&gt; stream = Arrays.stream(integers);</span><br></pre></td></tr></table></figure><ol start="3"><li>通过<code>Stream</code>类中静态方法<code>of()</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"aaa"</span>, <span class="string">"bbb"</span>);</span><br></pre></td></tr></table></figure><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="filter-T-gt-boolean"><a href="#filter-T-gt-boolean" class="headerlink" title="filter(T -&gt; boolean)"></a>filter(T -&gt; boolean)</h3><p>保留 boolean 为 true 的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保留年龄为 20 的 person 元素</span></span><br><span class="line">list = list.stream()</span><br><span class="line">            .filter(person -&gt; person.getAge() == <span class="number">20</span>)</span><br><span class="line">            .collect(toList());<span class="comment">//collect(toList()) 可以把流转换为 List 类型</span></span><br><span class="line"><span class="comment">//打印输出 [Person&#123;name='jack', age=20&#125;]</span></span><br></pre></td></tr></table></figure><h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct()"></a>distinct()</h3><p>去除重复元素，这个方法是通过类的 <code>equals</code> 方法来判断两个元素是否相等的。</p><p>如例子中的 Person 类，需要先定义好 equals 方法，不然类似<code>[Person{name=&#39;jack&#39;, age=20}, Person{name=&#39;jack&#39;, age=20}]</code>这样的情况是不会处理的。</p><h3 id="sorted-sorted-T-T-gt-int"><a href="#sorted-sorted-T-T-gt-int" class="headerlink" title="sorted() / sorted((T, T) -&gt; int)"></a>sorted() / sorted((T, T) -&gt; int)</h3><p>如果流中的元素的类实现了 <code>Comparable</code> 接口，即有自己的排序规则，那么可以直接调用 <code>sorted()</code> 方法对元素进行排序。</p><p>反之, 需要调用 <code>sorted((T, T) -&gt; int)</code> 实现 <code>Comparator</code> 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据年龄大小来比较：</span></span><br><span class="line">list = list.stream()</span><br><span class="line">           .sorted((p1, p2) -&gt; p1.getAge() - p2.getAge())</span><br><span class="line">           .collect(toList());</span><br></pre></td></tr></table></figure><p>简化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list = list.stream()</span><br><span class="line">           .sorted(Comparator.comparingInt(Person::getAge))</span><br><span class="line">           .collect(toList());</span><br></pre></td></tr></table></figure><h3 id="limit-long-n"><a href="#limit-long-n" class="headerlink" title="limit(long n)"></a>limit(long n)</h3><p>返回前 n 个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list = list.stream()</span><br><span class="line">            .limit(<span class="number">2</span>)</span><br><span class="line">            .collect(toList());</span><br><span class="line"> </span><br><span class="line"><span class="comment">//打印输出 [Person&#123;name='jack', age=20&#125;, Person&#123;name='mike', age=25&#125;]</span></span><br></pre></td></tr></table></figure><h3 id="skip-long-n"><a href="#skip-long-n" class="headerlink" title="skip(long n)"></a>skip(long n)</h3><p>去除前 n 个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list = list.stream()</span><br><span class="line">            .skip(<span class="number">2</span>)</span><br><span class="line">            .collect(toList());</span><br><span class="line"> </span><br><span class="line"><span class="comment">//打印输出 [Person&#123;name='tom', age=30&#125;]</span></span><br></pre></td></tr></table></figure><ul><li><code>skip(n)</code>用在 <code>limit(n)</code> 前面时，先去除前 m 个元素再返回剩余元素的前 n 个元素</li><li><code>limit(n)</code> 用在 <code>skip(m)</code> 前面时，先返回前 n 个元素再在剩余的 n 个元素中去除 m 个元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list = list.stream()</span><br><span class="line">            .limit(<span class="number">2</span>)</span><br><span class="line">            .skip(<span class="number">1</span>)</span><br><span class="line">            .collect(toList());</span><br><span class="line"> </span><br><span class="line"><span class="comment">//打印输出 [Person&#123;name='mike', age=25&#125;]</span></span><br></pre></td></tr></table></figure><h3 id="map-T-gt-R"><a href="#map-T-gt-R" class="headerlink" title="map(T -&gt; R)"></a>map(T -&gt; R)</h3><p>将流中的每一个元素 T 映射为 R（类似类型转换）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; newlist = list.stream()</span><br><span class="line">    .map(Person::getName)</span><br><span class="line">    .collect(toList());</span><br><span class="line"><span class="comment">//newlist 里面的元素为 list 中每一个 Person 对象的 name 变量</span></span><br></pre></td></tr></table></figure><h3 id="flatMap-T-gt-Stream"><a href="#flatMap-T-gt-Stream" class="headerlink" title="flatMap(T -&gt; Stream)"></a>flatMap(T -&gt; Stream)</h3><p>将流中的每一个元素 T 映射为一个流，再把每一个流连接成为一个流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"aaa bbb ccc"</span>);</span><br><span class="line">list.add(<span class="string">"ddd eee fff"</span>);</span><br><span class="line">list.add(<span class="string">"ggg hhh iii"</span>);</span><br><span class="line"> </span><br><span class="line">list = list.stream()</span><br><span class="line">    .map(s -&gt; s.split(<span class="string">" "</span>))</span><br><span class="line">    .flatMap(Arrays::stream)</span><br><span class="line">    .collect(toList());</span><br></pre></td></tr></table></figure><p>我们的目的是把 List 中每个字符串元素以” “分割开，变成一个新的 List。</p><p>首先 map 方法分割每个字符串元素，但此时流的类型为 Stream&lt;String[ ]&gt;，因为 split 方法返回的是 String[ ] 类型；所以我们需要使用 flatMap 方法，先使用Arrays::stream将每个 String[ ] 元素变成一个 Stream 流，然后 flatMap 会将每一个流连接成为一个流，最终返回我们需要的 Stream。</p><h3 id="anyMatch-T-gt-boolean"><a href="#anyMatch-T-gt-boolean" class="headerlink" title="anyMatch(T -&gt; boolean)"></a>anyMatch(T -&gt; boolean)</h3><p>流中是否有一个元素匹配给定的 <code>T -&gt; boolean</code> 条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否存在一个 person 对象的 age 等于 20：</span></span><br><span class="line"><span class="keyword">boolean</span> b = list.stream()</span><br><span class="line">    .anyMatch(person -&gt; person.getAge() == <span class="number">20</span>);</span><br></pre></td></tr></table></figure><h3 id="allMatch-T-gt-boolean"><a href="#allMatch-T-gt-boolean" class="headerlink" title="allMatch(T -&gt; boolean)"></a>allMatch(T -&gt; boolean)</h3><p>流中是否所有元素都匹配给定的 <code>T -&gt; boolean</code> 条件</p><h3 id="noneMatch-T-gt-boolean"><a href="#noneMatch-T-gt-boolean" class="headerlink" title="noneMatch(T -&gt; boolean)"></a>noneMatch(T -&gt; boolean)</h3><p>流中是否没有元素匹配给定的 T -&gt; boolean 条件</p><h3 id="findAny-和-findFirst"><a href="#findAny-和-findFirst" class="headerlink" title="findAny() 和 findFirst()"></a>findAny() 和 findFirst()</h3><ul><li><p>findAny()：找到其中一个元素 （使用 stream() 时找到的是第一个元素；使用 parallelStream() 并行时找到的是其中一个元素）</p></li><li><p>findFirst()：找到第一个元素</p></li></ul><p>值得注意的是，这两个方法返回的是一个 Optional 对象，它是一个容器类，能代表一个值存在或不存在</p><h3 id="reduce-T-T-gt-T-和-reduce-T-T-T-gt-T"><a href="#reduce-T-T-gt-T-和-reduce-T-T-T-gt-T" class="headerlink" title="reduce((T, T) -&gt; T) 和 reduce(T, (T, T) -&gt; T)"></a>reduce((T, T) -&gt; T) 和 reduce(T, (T, T) -&gt; T)</h3><p>用于组合流中的元素，如求和，求积，求最大值等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算年龄总和：</span></span><br><span class="line"><span class="keyword">int</span> sum = list.stream()</span><br><span class="line">    .map(Person::getAge)</span><br><span class="line">    .reduce(<span class="number">0</span>, (a, b) -&gt; a + b);</span><br><span class="line"><span class="comment">//与之相同:</span></span><br><span class="line"><span class="keyword">int</span> sum = list.stream()</span><br><span class="line">    .map(Person::getAge)</span><br><span class="line">    .reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"><span class="comment">//其中，reduce 第一个参数 0 代表起始值为 0，lambda (a, b) -&gt; a + b 即将两值相加产生一个新值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算年龄总乘积：</span></span><br><span class="line"><span class="keyword">int</span> sum = list.stream()</span><br><span class="line">    .map(Person::getAge)</span><br><span class="line">    .reduce(<span class="number">1</span>, (a, b) -&gt; a * b);</span><br><span class="line"><span class="comment">//与之相同:</span></span><br><span class="line">Optional&lt;Integer&gt; sum = list.stream()</span><br><span class="line">    .map(Person::getAge)</span><br><span class="line">    .reduce(Integer::sum);</span><br><span class="line"><span class="comment">//不接受任何起始值，但因为没有初始值，需要考虑结果可能不存在的情况，因此返回的是 Optional 类型</span></span><br></pre></td></tr></table></figure><h3 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h3><p>返回流中元素个数，结果为 long 类型</p><h3 id="collect"><a href="#collect" class="headerlink" title="collect()"></a>collect()</h3><p>收集方法，我们很常用的是 <code>collect(toList())</code>，当然还有 <code>collect(toSet())</code> 等，参数是一个收集器接口</p><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p>返回结果为 void，很明显我们可以通过它来干什么了，比方说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印各个元素：</span></span><br><span class="line">list.stream()</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="unordered"><a href="#unordered" class="headerlink" title="unordered()"></a>unordered()</h3><p>还有这个比较不起眼的方法，返回一个等效的无序流，当然如果流本身就是无序的话，那可能就会直接返回其本身</p><h2 id="数值流"><a href="#数值流" class="headerlink" title="数值流"></a>数值流</h2><p>前面介绍的如<code>int sum = list.stream().map(Person::getAge).reduce(0, Integer::sum);</code> 计算元素总和的方法，其中暗含了装箱成本，<code>map(Person::getAge)</code> 方法过后流变成了 <code>Stream</code> 类型，而每个 <code>Integer</code> 都要拆箱成一个原始类型再进行 <code>sum</code> 方法求和，这样大大影响了效率。</p><p>针对这个问题 Java 8 有良心地引入了数值流 <code>IntStream</code>, <code>DoubleStream</code>, <code>LongStream</code>，这种流中的元素都是原始数据类型，分别是 <code>int</code>，<code>double</code>，<code>long</code></p><h3 id="流与数值流的转换"><a href="#流与数值流的转换" class="headerlink" title="流与数值流的转换"></a>流与数值流的转换</h3><h4 id="流转换为数值流"><a href="#流转换为数值流" class="headerlink" title="流转换为数值流"></a>流转换为数值流</h4><ul><li>mapToInt(T -&gt; int) : return IntStream</li><li>mapToDouble(T -&gt; double) : return DoubleStream</li><li>mapToLong(T -&gt; long) : return LongStream</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntStream intStream = list.stream()</span><br><span class="line">    .mapToInt(Person::getAge);</span><br></pre></td></tr></table></figure><h4 id="数值流转换为流"><a href="#数值流转换为流" class="headerlink" title="数值流转换为流"></a>数值流转换为流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = intStream.boxed();</span><br></pre></td></tr></table></figure><h3 id="数值流方法"><a href="#数值流方法" class="headerlink" title="数值流方法"></a>数值流方法</h3><ul><li>sum()</li><li>max()</li><li>min()</li><li>average() </li></ul><h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p>IntStream 与 LongStream 拥有 range 和 rangeClosed 方法用于数值范围处理</p><ul><li><p>IntStream ： rangeClosed(int, int) / range(int, int)</p></li><li><p>LongStream ： rangeClosed(long, long) / range(long, long)</p></li></ul><p>我们可以利用 IntStream.rangeClosed(1, 100) 生成 1 到 100 的数值流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求 1 到 10 的数值总和：</span></span><br><span class="line">IntStream intStream = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> sum = intStream.sum();</span><br></pre></td></tr></table></figure><p>这两个方法的区别在于一个是闭区间，一个是半开半闭区间：</p><ul><li>rangeClosed(1, 100) ：[1, 100]</li><li>range(1, 100) ：[1, 100)</li></ul><h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><h4 id="counting"><a href="#counting" class="headerlink" title="counting"></a>counting</h4><p>用于计算总和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> l = list.stream().collect(counting());</span><br><span class="line"><span class="comment">//推荐</span></span><br><span class="line"><span class="keyword">long</span> l = list.stream().count();</span><br></pre></td></tr></table></figure><h4 id="summingInt-summingLong-summingDouble"><a href="#summingInt-summingLong-summingDouble" class="headerlink" title="summingInt, summingLong, summingDouble"></a>summingInt, summingLong, summingDouble</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = list.stream().collect(summingInt(Person::getAge));</span><br><span class="line"><span class="comment">//推荐</span></span><br><span class="line"><span class="keyword">int</span> sum = list.stream().mapToInt(Person::getAge).sum();</span><br><span class="line"><span class="keyword">int</span> sum = list.stream().map(Person::getAge).reduce(Interger::sum).get();</span><br></pre></td></tr></table></figure><h4 id="averagingInt，averagingLong，averagingDouble"><a href="#averagingInt，averagingLong，averagingDouble" class="headerlink" title="averagingInt，averagingLong，averagingDouble"></a>averagingInt，averagingLong，averagingDouble</h4><p>求平均数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Double average = list.stream().collect(averagingInt(Person::getAge));</span><br><span class="line"></span><br><span class="line">OptionalDouble average = list.stream().mapToInt(Person::getAge).average();</span><br></pre></td></tr></table></figure><h4 id="summarizingInt，summarizingLong，summarizingDouble"><a href="#summarizingInt，summarizingLong，summarizingDouble" class="headerlink" title="summarizingInt，summarizingLong，summarizingDouble"></a>summarizingInt，summarizingLong，summarizingDouble</h4><p>这三个方法比较特殊，比如 summarizingInt 会返回 IntSummaryStatistics 类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics l = list.stream().collect(summarizingInt(Person::getAge));</span><br></pre></td></tr></table></figure><p>IntSummaryStatistics 包含了计算出来的平均值，总数，总和，最值，可以通过下面这些方法获得相应的数据</p><ul><li>getAverage()</li><li>getCount()</li><li>getMax()</li><li>getMin()</li><li>getSum()</li></ul><h3 id="取最值"><a href="#取最值" class="headerlink" title="取最值"></a>取最值</h3><p>maxBy，minBy 两个方法，需要一个 Comparator 接口作为参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Person&gt; optional = list.stream().collect(maxBy(comparing(Person::getAge)));</span><br><span class="line">Optional&lt;Person&gt; optional = list.stream().max(comparing(Person::getAge));</span><br></pre></td></tr></table></figure><h3 id="joining-连接字符串"><a href="#joining-连接字符串" class="headerlink" title="joining 连接字符串"></a>joining 连接字符串</h3><p>对流里面的字符串元素进行连接，<strong>其底层实现用的是专门用于字符串连接的 StringBuilder</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s = list.stream().map(Person::getName).collect(joining());</span><br><span class="line"><span class="comment">//结果：jackmiketom</span></span><br><span class="line">String s = list.stream().map(Person::getName).collect(joining(<span class="string">","</span>));</span><br><span class="line"><span class="comment">//结果：jack,mike,tom</span></span><br><span class="line">String s = list.stream().map(Person::getName).collect(joining(<span class="string">" and "</span>, <span class="string">"Today "</span>, <span class="string">" play games."</span>));</span><br><span class="line"><span class="comment">//结果：Today jack and mike and tom play games</span></span><br><span class="line"><span class="comment">//即 Today 放开头，play games. 放结尾，and 在中间连接各个字符串</span></span><br></pre></td></tr></table></figure><h3 id="groupingBy-分组"><a href="#groupingBy-分组" class="headerlink" title="groupingBy 分组"></a>groupingBy 分组</h3><p>groupingBy 用于将数据分组，最终返回一个 Map 类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, List&lt;Person&gt;&gt; map = list.stream().collect(groupingBy(Person::getAge));</span><br><span class="line"><span class="comment">//按照年龄 age 分组，每一个 Person 对象中年龄相同的归为一组</span></span><br><span class="line"><span class="comment">//Person::getAge 决定 Map 的键（Integer 类型），list 类型决定 Map 的值（List 类型）</span></span><br></pre></td></tr></table></figure><h3 id="partitioningBy-分区"><a href="#partitioningBy-分区" class="headerlink" title="partitioningBy 分区"></a>partitioningBy 分区</h3><p>分区与分组的区别在于，分区是按照 true 和 false 来分的，因此partitioningBy 接受的参数的 lambda 也是 <code>T -&gt; boolean</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据年龄是否小于等于20来分区</span></span><br><span class="line">Map&lt;Boolean, List&lt;Person&gt;&gt; map = list.stream()</span><br><span class="line">                                     .collect(partitioningBy(p -&gt; p.getAge() &lt;= <span class="number">20</span>));</span><br><span class="line"><span class="comment">//打印输出</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">false</span>=[Person&#123;name=<span class="string">'mike'</span>, age=<span class="number">25</span>&#125;, Person&#123;name=<span class="string">'tom'</span>, age=<span class="number">30</span>&#125;], </span><br><span class="line">    <span class="keyword">true</span>=[Person&#123;name=<span class="string">'jack'</span>, age=<span class="number">20</span>&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p>之前我就讲到了 parallelStream 方法能生成并行流，因此你通常可以使用 parallelStream 来代替 stream 方法，但是并行的性能问题非常值得我们思考，比方说下面这个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = Stream.iterate(<span class="number">1</span>, a -&gt; a + <span class="number">1</span>).limit(<span class="number">100</span>).parallel().reduce(<span class="number">0</span>, Integer::sum);</span><br></pre></td></tr></table></figure><p>我们通过这样一行代码来计算 1 到 100 的所有数的和，我们使用了 parallel 来实现并行。</p><p>但实际上是，这样的计算，效率是非常低的，比不使用并行还低！一方面是因为装箱问题，还有一方面就是 iterate 方法很难把这些数分成多个独立块来并行执行，因此无形之中降低了效率。</p><h3 id="流的可分解性"><a href="#流的可分解性" class="headerlink" title="流的可分解性"></a>流的可分解性</h3><p>使用并行的时候，我们要注意流背后的数据结构是否易于分解。比如众所周知的 ArrayList 和 LinkedList，明显前者在分解方面占优。</p><table><thead><tr><th align="left">数据源</th><th align="left">可分解性</th></tr></thead><tbody><tr><td align="left">ArrayList</td><td align="left">极佳</td></tr><tr><td align="left">LinkedList</td><td align="left">差</td></tr><tr><td align="left">IntStream.range</td><td align="left">极佳</td></tr><tr><td align="left">Stream.iterate</td><td align="left">差</td></tr><tr><td align="left">HashSet</td><td align="left">好</td></tr><tr><td align="left">TreeSet</td><td align="left">好</td></tr></tbody></table><h3 id="顺序性"><a href="#顺序性" class="headerlink" title="顺序性"></a>顺序性</h3><p>除了可分解性，和刚刚提到的装箱问题，还有一点值得注意的是一些操作本身在并行流上的性能就比顺序流要差，比如：limit，findFirst， 因为这两个方法会考虑元素的顺序性，而并行本身就是违背顺序性的，也是因为如此 findAny 一般比 findFirst 的效率要高。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;  参考文档：&lt;/p&gt;
&lt;p&gt;  &lt;a href=&quot;https://blog.csdn.net/ycj_xiyang/article/details/83624642&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java8-Stream API 详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  &lt;a href=&quot;https://blog.csdn.net/zxl646801924/article/details/90374320?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;java8 stream常用方法&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Stream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。&lt;/p&gt;
&lt;p&gt;Java 8 中的 &lt;strong&gt;Stream 是对集合（Collection）对象功能的增强&lt;/strong&gt;，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。&lt;/p&gt;
&lt;p&gt;Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。&lt;/p&gt;
&lt;p&gt;通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。&lt;/p&gt;
&lt;p&gt;所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://yoursite.com/2020/05/30/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/05/30/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2020-06-08T00:57:52.307Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><ul><li>byte/8</li><li>char/16</li><li>short/16</li><li>int/32</li><li>float/32</li><li>long/64</li><li>double/64</li><li>boolean/~</li></ul><blockquote><p>  boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</p></blockquote><h4 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h4><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用<strong>自动装箱</strong>与<strong>拆箱</strong>完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="number">2</span>;     <span class="comment">// 装箱 调用了 Integer.valueOf(2)</span></span><br><span class="line"><span class="keyword">int</span> y = x;         <span class="comment">// 拆箱 调用了 X.intValue()</span></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h4><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p><ul><li>new Integer(123) 每次都会新建一个对象；</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line">Integer z = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">Integer k = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>  valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p></blockquote><p>基本类型对应的缓冲池如下：</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><blockquote><p>  在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。</p></blockquote><h3 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h3><h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p>String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）</p><p>在 Java 8 中，String 内部使用 <strong>char 数组</strong>存储数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 9 之后，String 类的实现改用 <strong>byte 数组</strong>存储字符串，同时使用 <em>coder</em> 来标识使用了哪种编码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The identifier of the encoding used to encode the bytes in &#123;<span class="doctag">@code</span> value&#125;. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="String-的不可变性："><a href="#String-的不可变性：" class="headerlink" title="String 的不可变性："></a>String 的不可变性：</h4><blockquote><p>  <strong>value 数组被声明为 final</strong>，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p></blockquote><p><strong>不可变的好处：</strong></p><ol><li>可以缓存 hash 值</li></ol><blockquote><p>  因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 <strong>hash 值也不可变，因此只需要进行一次计算</strong>。</p></blockquote><ol start="2"><li>String Pool 的需要</li></ol><blockquote><p>  如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p></blockquote><ol start="3"><li>安全性</li></ol><blockquote><p>  String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p></blockquote><ol start="4"><li>线程安全</li></ol><blockquote><p>  String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p></blockquote><h4 id="String、StringBuffer-和-StringBuilder"><a href="#String、StringBuffer-和-StringBuilder" class="headerlink" title="String、StringBuffer 和 StringBuilder"></a>String、StringBuffer 和 StringBuilder</h4><ol><li>可变性</li></ol><ul><li>String 不可变</li><li>StringBuffer 和 StringBuilder 可变</li></ul><ol start="2"><li>线程安全</li></ol><ul><li>String 不可变，因此是线程安全的</li><li>StringBuffer 是线程安全的，<strong>内部使用 synchronized 进行同步</strong></li><li>StringBuilder 不是线程安全的</li></ul><h4 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h4><p>字符串常量池（String Pool）<strong>保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定</strong>。不仅如此，还可以使用 String 的 intern() 方法在<strong>运行过程</strong>将字符串添加到 String Pool 中。</p><p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p><blockquote><p>  下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得同一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line">String s3 = s1.intern();</span><br><span class="line">String s4 = s1.intern();</span><br><span class="line">System.out.println(s3 == s4);           <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>  如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s5 = <span class="string">"bbb"</span>;</span><br><span class="line">String s6 = <span class="string">"bbb"</span>;</span><br><span class="line">System.out.println(s5 == s6);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>  在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p></blockquote><p><strong>new String(“abc”)</strong></p><blockquote><p>  使用这种方式一共会<strong>创建两个</strong>字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。</p><ul><li>“abc” 属于字符串字面量，因此编译时期会在 <strong>String Pool 中</strong>创建一个字符串对象，指向这个 “abc” 字符串字面量；</li><li>而使用 new 的方式会在<strong>堆中</strong>创建一个字符串对象。</li></ul></blockquote><p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会<strong>指向同一个 value 数组</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>Java 的参数是以<strong>值传递</strong>的形式传入方法中，而不是引用传递。</p><p>以下代码中 Dog dog 的 dog 是一个指针，<strong>存储的是对象的地址</strong>。在将一个参数传入一个方法时，本质上是将<strong>对象的地址以值的方式</strong>传递到形参中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Dog(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getObjectAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PassByValueExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog(<span class="string">"A"</span>);</span><br><span class="line">        func(dog);</span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        dog.setName(<span class="string">"B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在方法中将指针引用了其它对象，那么此时<strong>方法里和方法外的两个指针指向了不同的对象</strong>，<strong>在一个指针改变其所指向对象的内容时对另一个指针所指向的对象没有影响</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassByValueExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog(<span class="string">"A"</span>);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        func(dog);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// A</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        dog = <span class="keyword">new</span> Dog(<span class="string">"B"</span>);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@74a14482</span></span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p><strong>1. 修饰数据</strong></p><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p><ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变，也就<strong>不能引用其它对象</strong>，但是<strong>被引用的对象本身是可以修改的</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// x = 2;  // cannot assign value to final variable 'x'</span></span><br></pre></td></tr></table></figure><p><strong>2. 修饰方法</strong></p><p>声明方法不能被子类重写。</p><p><strong>private 方法隐式地被指定为 final</strong>，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中<strong>定义了一个新的方法</strong>。</p><p><strong>3. 修饰类</strong></p><p>声明类不允许被继承。</p><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p><strong>1. 静态变量</strong></p><ul><li>静态变量：又称为类变量，也就是说这个变量属于类的，<strong>类所有的实例都共享静态变量，可以直接通过类名来访问它</strong>。<strong>静态变量在内存中只存在一份</strong>。</li><li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;         <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> y;  <span class="comment">// 静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// int x = A.x;  // Non-static field 'x' cannot be referenced from a static context</span></span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="keyword">int</span> x = a.x;</span><br><span class="line">        <span class="keyword">int</span> y = A.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 静态方法</strong></p><p><strong>静态方法在类加载的时候就存在了，它不依赖于任何实例</strong>。所以静态方法必须有实现，也就是说它<strong>不能是抽象方法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// public abstract static void func2();  </span></span><br><span class="line">    <span class="comment">// Illegal combination of modifiers: 'abstract' and 'static'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>只能访问所属类的静态字段和静态方法</strong>，方法中不能有 this 和 super 关键字，因此这两个关键字与具体对象关联。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = x;</span><br><span class="line">        <span class="comment">// int b = y;  // Non-static field 'y' cannot be referenced from a static context</span></span><br><span class="line">        <span class="comment">// int b = this.y;     // 'A.this' cannot be referenced from a static context</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 静态语句块</strong></p><p>静态语句块在<strong>类初始化时运行一次</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"123"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a1 = <span class="keyword">new</span> A();</span><br><span class="line">        A a2 = <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p><strong>4. 静态内部类</strong></p><p>非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line"><span class="comment">//非静态内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// InnerClass innerClass = new InnerClass(); </span></span><br><span class="line">        <span class="comment">// 'OuterClass.this' cannot be referenced from a static context</span></span><br><span class="line">        OuterClass outerClass = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        InnerClass innerClass = outerClass.<span class="keyword">new</span> InnerClass();</span><br><span class="line">        StaticInnerClass staticInnerClass = <span class="keyword">new</span> StaticInnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类不能访问外部类的非静态的变量和方法。</p><p><strong>5. 静态导包</strong></p><p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xxx.ClassName.*</span><br></pre></td></tr></table></figure><p><strong>6. 初始化顺序</strong></p><p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String staticField = <span class="string">"静态变量"</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"静态语句块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String field = <span class="string">"实例变量"</span>;</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"普通语句块"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后才是构造函数的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InitialOrderTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"构造函数"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  存在继承的情况下，初始化顺序为：</p><ol><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ol></blockquote><h3 id="Object-中的方法"><a href="#Object-中的方法" class="headerlink" title="Object 中的方法"></a>Object 中的方法</h3><h4 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h4><p>Object中的所有方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; <span class="title">getClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><h4 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h4><p><strong>1. 等价关系</strong></p><p>两个对象具有等价关系，需要满足以下五个条件：</p><blockquote><p>  Ⅰ 自反性</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>  Ⅱ 对称性</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y) == y.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>  Ⅲ 传递性</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))</span><br><span class="line">    x.equals(z); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>  Ⅳ 一致性</p><p>  多次调用 equals() 方法结果不变</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y) == x.equals(y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>  Ⅴ 与 null 的比较</p><p>  对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(<span class="keyword">null</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></blockquote><p><strong>2. 等价与相等</strong></p><ul><li>对于基本类型，== 判断两个值是否相等，<strong>基本类型没有 equals() 方法</strong>。b</li><li>对于引用类型，<strong>== 判断两个变量是否引用同一个对象</strong>，而 <strong>equals() 判断引用的对象是否等价</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x == y);      <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>3. 实现步骤</strong></p><ol><li>检查是否为同一个对象的引用，如果是直接返回 true；</li><li>检查是否是同一个类型，如果不是，直接返回 false；</li><li>将 Object 对象进行转型；</li><li>判断指定的关键域是否相等。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EqualExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        EqualExample that = (EqualExample) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x != that.x) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (y != that.y) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> z == that.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h4><p>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。<strong>等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价</strong>，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。</p><blockquote><p>  在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。</p></blockquote><p>HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法。</p><p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象。但是 EqualExample 没有实现 hashCode() 方法，<strong>因此这两个对象的哈希值是不同的，最终导致集合添加了两个等价的对象</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EqualExample e1 = <span class="keyword">new</span> EqualExample(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">EqualExample e2 = <span class="keyword">new</span> EqualExample(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(e1.equals(e2)); <span class="comment">// true</span></span><br><span class="line">HashSet&lt;EqualExample&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.add(e1);</span><br><span class="line">set.add(e2);</span><br><span class="line">System.out.println(set.size());   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。</p><p>R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">17</span>;</span><br><span class="line">    result = <span class="number">31</span> * result + x;</span><br><span class="line">    result = <span class="number">31</span> * result + y;</span><br><span class="line">    result = <span class="number">31</span> * result + z;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p>默认返回 <code>ToStringExample@4554617c</code> 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ToStringExample</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ToStringExample example = <span class="keyword">new</span> ToStringExample(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(example.toString());<span class="comment">//ToStringExample@4554617c</span></span><br></pre></td></tr></table></figure><h4 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h4><p><strong>1. cloneable</strong></p><p>clone() 是 Object 的 protected 方法，它不是 public，<strong>一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CloneExample e1 = <span class="keyword">new</span> CloneExample();</span><br><span class="line">CloneExample e2 = e1.clone(); <span class="comment">// 'clone()' has protected access in 'java.lang.Object'</span></span><br></pre></td></tr></table></figure><p>重写 clone() 得到以下实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (CloneExample)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CloneExample e1 = <span class="keyword">new</span> CloneExample();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    CloneExample e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//java.lang.CloneNotSupportedException: CloneExample</span></span><br></pre></td></tr></table></figure><p>以上抛出了 <code>CloneNotSupportedException</code>，这是因为 CloneExample 没有实现 Cloneable 接口。</p><p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现Cloneable接口又调用了clone() 方法，就会抛出 <code>CloneNotSupportedException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 浅拷贝</strong></p><p>拷贝对象和原始对象的引用类型<strong>引用同一个对象</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShallowCloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShallowCloneExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ShallowCloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ShallowCloneExample) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ShallowCloneExample e1 = <span class="keyword">new</span> ShallowCloneExample();</span><br><span class="line">ShallowCloneExample e2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 222</span></span><br></pre></td></tr></table></figure><p><strong>3. 深拷贝</strong></p><p>拷贝对象和原始对象的引用类型<strong>引用不同对象</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepCloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeepCloneExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DeepCloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        DeepCloneExample result = (DeepCloneExample) <span class="keyword">super</span>.clone();</span><br><span class="line">        result.arr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            result.arr[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DeepCloneExample e1 = <span class="keyword">new</span> DeepCloneExample();</span><br><span class="line">DeepCloneExample e2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><strong>4. clone() 的替代方案</strong></p><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用<strong>拷贝构造函数</strong>或者<strong>拷贝工厂</strong>来拷贝一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneConstructorExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloneConstructorExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloneConstructorExample</span><span class="params">(CloneConstructorExample original)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[original.arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; original.arr.length; i++) &#123;</span><br><span class="line">            arr[i] = original.arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CloneConstructorExample e1 = <span class="keyword">new</span> CloneConstructorExample();</span><br><span class="line">CloneConstructorExample e2 = <span class="keyword">new</span> CloneConstructorExample(e1);</span><br><span class="line"></span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p><p>优点：</p><ul><li>减少耦合：可以独立地开发、测试、优化、使用、理解和修改</li><li>减轻维护的负担：可以更容易被理解，并且在调试的时候可以不影响其他模块</li><li>有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能</li><li>提高软件的可重用性</li><li>降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</li></ul><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承实现了 <strong>IS-A</strong> 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p><p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态分为编译时多态和运行时多态：</p><ul><li>编译时多态主要指方法的重载</li><li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li></ul><p>运行时多态有三个条件：</p><ul><li>继承</li><li>覆盖（重写）</li><li>向上转型</li></ul><h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><h4 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h4><p>Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p><p>可以对类或类中的成员（字段和方法）加上访问修饰符。</p><ul><li>类可见表示其它类可以用这个类创建实例对象。</li><li>成员可见表示其它类可以用这个类的实例对象访问到该成员；</li></ul><p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p><blockquote><p>  设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。</p></blockquote><p>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是确保满足<strong>里氏替换原则</strong>。</p><p><strong>字段决不能是公有的</strong>，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id + <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = Integer.valueOf(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessWithInnerClassExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的嵌套类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InnerClass innerClass;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccessWithInnerClassExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        innerClass = <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> innerClass.x;  <span class="comment">// 直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h4><p><strong>1. 抽象类</strong></p><p>抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。</p><p>抽象类和普通类最大的区别是，<strong>抽象类不能被实例化，只能被继承</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClassExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExtendClassExample</span> <span class="keyword">extends</span> <span class="title">AbstractClassExample</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractClassExample ac1 = <span class="keyword">new</span> AbstractClassExample(); </span><br><span class="line"><span class="comment">// 'AbstractClassExample' is abstract; cannot be instantiated</span></span><br><span class="line">AbstractClassExample ac2 = <span class="keyword">new</span> AbstractExtendClassExample();</span><br><span class="line">ac2.func1();</span><br></pre></td></tr></table></figure><p><strong>2. 接口</strong></p><p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p><p>从 Java 8 开始，<strong>接口也可以拥有默认的方法实现</strong>，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。</p><blockquote><ul><li>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected</li><li>接口的字段默认都是 static 和 final 的</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">123</span>;</span><br><span class="line">    <span class="comment">// int y;               // Variable 'y' might not have been initialized</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> z = <span class="number">0</span>;       <span class="comment">// Modifier 'public' is redundant for interface fields</span></span><br><span class="line">    <span class="comment">// private int k = 0;   // Modifier 'private' not allowed here</span></span><br><span class="line">    <span class="comment">// protected int l = 0; // Modifier 'protected' not allowed here</span></span><br><span class="line">    <span class="comment">// private void fun3(); // Modifier 'private' not allowed here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceImplementExample</span> <span class="keyword">implements</span> <span class="title">InterfaceExample</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InterfaceExample ie1 = new InterfaceExample(); </span></span><br><span class="line"><span class="comment">// 'InterfaceExample' is abstract; cannot be instantiated</span></span><br><span class="line">InterfaceExample ie2 = <span class="keyword">new</span> InterfaceImplementExample();</span><br><span class="line">ie2.func1();</span><br><span class="line">System.out.println(InterfaceExample.x);</span><br></pre></td></tr></table></figure><p><strong>3. 比较</strong></p><ul><li>从设计层面上看，<strong>抽象类提供了一种 IS-A 关系</strong>，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而<strong>接口更像是一种 LIKE-A 关系</strong>，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li><li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li><li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li><li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li></ul><p><strong>4. 使用选择</strong></p><p>使用接口：</p><ul><li>需要让<strong>不相关的类</strong>都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；</li><li>需要使用<strong>多重继承</strong>。</li></ul><p>使用抽象类：</p><ul><li>需要在几个<strong>相关的类</strong>中共享代码。</li><li>需要能控制继承来的成员的访问权限，而不是都为 public。</li><li>需要继承非静态和非常量字段。</li></ul><blockquote><p>  在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p></blockquote><h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><ul><li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。</li><li>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperExample.func()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperExtendExample</span> <span class="keyword">extends</span> <span class="title">SuperExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperExtendExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y);</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.func();</span><br><span class="line">        System.out.println(<span class="string">"SuperExtendExample.func()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperExample e = <span class="keyword">new</span> SuperExtendExample(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">e.func();</span><br><span class="line"></span><br><span class="line"><span class="comment">//SuperExample.func()</span></span><br><span class="line"><span class="comment">//SuperExtendExample.func()</span></span><br></pre></td></tr></table></figure><h4 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h4><p><strong>1. 重写（Override）</strong></p><p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p><blockquote><p>  为了满足里式替换原则，重写有以下三个限制：</p><ul><li>子类方法的访问权限必须大于等于父类方法；</li><li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li><li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li></ul></blockquote><p>使用 <code>@Override</code> 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。</p><p>下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：</p><ul><li>子类方法访问权限为 public，大于父类的 protected。</li><li>子类的返回类型为 ArrayList，是父类返回类型 List 的子类。</li><li>子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。</li><li>子类重写方法使用 <code>@Override</code> 注解，从而让编译器自动检查是否满足限制条件。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;Integer&gt; <span class="title">func</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">func</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：</p><ol><li>this.func(this)</li><li>super.func(this)</li><li>this.func(super)</li><li>super.func(super)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    A</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    B</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    C</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    D</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(A obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A.show(A)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(C obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A.show(C)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(A obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B.show(A)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    B b = <span class="keyword">new</span> B();</span><br><span class="line">    C c = <span class="keyword">new</span> C();</span><br><span class="line">    D d = <span class="keyword">new</span> D();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 A 中存在 show(A obj)，直接调用</span></span><br><span class="line">    a.show(a); <span class="comment">// A.show(A)</span></span><br><span class="line">    <span class="comment">// 在 A 中不存在 show(B obj)，将 B 转型成其父类 A</span></span><br><span class="line">    a.show(b); <span class="comment">// A.show(A)</span></span><br><span class="line">    <span class="comment">// 在 B 中存在从 A 继承来的 show(C obj)，直接调用</span></span><br><span class="line">    b.show(c); <span class="comment">// A.show(C)</span></span><br><span class="line">    <span class="comment">// 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C</span></span><br><span class="line">    b.show(d); <span class="comment">// A.show(C)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用的还是 B 对象，所以 ba 和 b 的调用结果一样</span></span><br><span class="line">    A ba = <span class="keyword">new</span> B();</span><br><span class="line">    ba.show(c); <span class="comment">// A.show(C)</span></span><br><span class="line">    ba.show(d); <span class="comment">// A.show(C)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 重载（Overload）</strong></p><p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是<strong>参数类型、个数、顺序至少有一个不同</strong>。</p><blockquote><p>  应该注意的是，返回值不同，其它都相同不算是重载。</p></blockquote><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>每个类都有一个 <strong>Class</strong> 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p><p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p><p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p><p>简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</p><p>反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p><blockquote><p>  Java 反射主要提供以下功能：</p><ul><li>在运行时判断任意一个对象所属的类；</li><li>在运行时构造任意一个类的对象；</li><li>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；</li><li>在运行时调用任意一个对象的方法</li></ul></blockquote><p>重点：<strong>是运行时而不是编译时</strong></p><p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p><ul><li><strong>Field</strong> ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li><li><strong>Method</strong> ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li><li><strong>Constructor</strong> ：可以用 Constructor 的 newInstance() 创建新的对象。</li></ul><h4 id="基本运用"><a href="#基本运用" class="headerlink" title="基本运用"></a>基本运用</h4><h5 id="获得-Class-对象"><a href="#获得-Class-对象" class="headerlink" title="获得 Class 对象"></a>获得 Class 对象</h5><p>方法有三种：</p><p>(1) 使用 Class 类的 <code>forName</code> 静态方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">Class.forName(driver);<span class="comment">//比如在 JDBC 开发中常用此方法加载数据库驱动</span></span><br></pre></td></tr></table></figure><p>(2)直接获取某一个对象的 class，比如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; klass = <span class="keyword">int</span><span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Class&lt;?&gt; classInt = Integer.TYPE;</span><br></pre></td></tr></table></figure><p>(3)调用某个对象的 <code>getClass()</code> 方法，比如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">"123"</span>);</span><br><span class="line">Class&lt;?&gt; klass = str.getClass();</span><br></pre></td></tr></table></figure><h5 id="判断是否为某个类的实例"><a href="#判断是否为某个类的实例" class="headerlink" title="判断是否为某个类的实例"></a>判断是否为某个类的实例</h5><p>一般地，我们用 <code>instanceof</code> 关键字来判断是否为某个类的实例。同时我们也可以借助反射中 Class 对象的 <code>isInstance()</code> 方法来判断是否为某个类的实例，它是一个 native 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object obj)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h5><p>通过反射来生成对象主要有两种方式。</p><ol><li>使用Class对象的newInstance()方法来创建Class对象对应类的实例。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Object str = c.newInstance();</span><br></pre></td></tr></table></figure><ol start="2"><li>先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取String所对应的Class对象Class&lt;?&gt; </span></span><br><span class="line">c = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//获取String类带一个String参数的构造器</span></span><br><span class="line">Constructor constructor = c.getConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//根据构造器创建实例</span></span><br><span class="line">Object obj = constructor.newInstance(<span class="string">"23333"</span>);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure><h5 id="获取类的成员变量（字段）"><a href="#获取类的成员变量（字段）" class="headerlink" title="获取类的成员变量（字段）"></a>获取类的成员变量（字段）</h5><p><code>Class</code>类提供了以下几个方法来获取字段：</p><ul><li>Field getField(name)：根据字段名获取某个<strong>public</strong>的field（包括父类）</li><li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li><li>Field[] getFields()：获取所有<strong>public</strong>的field（包括父类）</li><li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）</li></ul><p><strong>获取字段值：</strong></p><p>一个<code>Field</code>对象包含了一个字段的所有信息：</p><ul><li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li><li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li><li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li></ul><blockquote><p>  正常情况下，<code>Main</code>类无法访问类的<code>private</code>字段。要修复错误，可以将<code>private</code>改为<code>public</code>，或者，在调用getXxx()前，先写一句：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field.setAccessible(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>  调用<code>Field.setAccessible(true)</code>的意思是，别管这个字段是不是<code>public</code>，一律允许访问。</p></blockquote><h5 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h5><p><code>Class</code>类提供了以下几个方法来获取<code>Method</code>：</p><ul><li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li><li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li></ul><p>一个<code>Method</code>对象包含一个方法的所有信息：</p><ul><li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li><li><code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code>；</li><li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>{String.class, int.class}</code>；</li><li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li></ul><p><strong>调用方法：</strong></p><p>当我们从类中获取了一个方法后，我们就可以用 <code>invoke()</code> 方法来调用这个方法。<code>invoke</code> 方法的原型为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span></span><br><span class="line"><span class="function">           InvocationTargetException</span></span><br></pre></td></tr></table></figure><p>下面时一个实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; klass = methodClass<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">//创建methodClass的实例</span></span><br><span class="line">        Object obj = klass.newInstance();</span><br><span class="line">        <span class="comment">//获取methodClass类的add方法</span></span><br><span class="line">        Method method = klass.getMethod(<span class="string">"add"</span>,<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">//调用method对应的方法 =&gt; add(1,4)</span></span><br><span class="line">        Object result = method.invoke(obj,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">methodClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> fun = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  为了调用非public方法，我们通过<code>Method.setAccessible(true)</code>允许其调用</p></blockquote><h5 id="获取构造器信息"><a href="#获取构造器信息" class="headerlink" title="获取构造器信息"></a>获取构造器信息</h5><p>通过Class实例获取Constructor的方法如下：</p><ul><li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li><li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li></ul><blockquote><p>  注意<code>Constructor</code>总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。</p></blockquote><blockquote><p>  调用非<code>public</code>的<code>Constructor</code>时，必须首先通过<code>setAccessible(true)</code>设置允许访问。<code>setAccessible(true)</code>可能会失败。</p></blockquote><h5 id="获取对象实例"><a href="#获取对象实例" class="headerlink" title="获取对象实例"></a>获取对象实例</h5><p>主要是通过Class类的getConstructor方法得到Constructor类的一个实例，而Constructor类有一个newInstance方法可以创建一个对象实例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span></span><br></pre></td></tr></table></figure><p>此方法可以根据传入的参数来调用对应的Constructor创建对象实例。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>反射的优点：</strong></p><ul><li><strong>可扩展性</strong> ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</li><li><strong>类浏览器和可视化开发环境</strong> ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</li><li><strong>调试器和测试工具</strong> ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</li></ul><p><strong>反射的缺点：</strong></p><p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</p><ul><li><strong>性能开销</strong> ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</li><li><strong>安全限制</strong> ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</li><li><strong>内部暴露</strong> ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</li></ul><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： <strong>Error</strong> 和 <strong>Exception</strong>。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：</p><ul><li><strong>受检异常</strong> ：需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复；</li><li><strong>非受检异常</strong> ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5trjerdkj31i30u012j.jpg" alt="img"></p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// T stands for "Type"</span></span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">this</span>.t = t; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h3&gt;&lt;h4 id=&quot;基本类型&quot;&gt;&lt;a href=&quot;#基本类型&quot; class=&quot;headerlink&quot; title=&quot;基本类型&quot;&gt;&lt;/a&gt;基本类型&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;byte/8&lt;/li&gt;
&lt;li&gt;char/16&lt;/li&gt;
&lt;li&gt;short/16&lt;/li&gt;
&lt;li&gt;int/32&lt;/li&gt;
&lt;li&gt;float/32&lt;/li&gt;
&lt;li&gt;long/64&lt;/li&gt;
&lt;li&gt;double/64&lt;/li&gt;
&lt;li&gt;boolean/~&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;  boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;包装类型&quot;&gt;&lt;a href=&quot;#包装类型&quot; class=&quot;headerlink&quot; title=&quot;包装类型&quot;&gt;&lt;/a&gt;包装类型&lt;/h4&gt;&lt;p&gt;基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用&lt;strong&gt;自动装箱&lt;/strong&gt;与&lt;strong&gt;拆箱&lt;/strong&gt;完成。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Integer x = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;     &lt;span class=&quot;comment&quot;&gt;// 装箱 调用了 Integer.valueOf(2)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y = x;         &lt;span class=&quot;comment&quot;&gt;// 拆箱 调用了 X.intValue()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java异常</title>
    <link href="http://yoursite.com/2020/05/30/Java%E5%9F%BA%E7%A1%80/Java%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2020/05/30/Java%E5%9F%BA%E7%A1%80/Java%E5%BC%82%E5%B8%B8/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2020-06-08T00:57:51.991Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Java异常简介"><a href="#Java异常简介" class="headerlink" title="Java异常简介"></a>Java异常简介</h4><p>Java异常是Java提供的一种识别及响应错误的一致性机制。</p><p>Java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。在有效使用异常的情况下，异常能清晰的回答what, where, why这3个问题：异常类型回答了“什么”被抛出，异常堆栈跟踪回答了“在哪”抛出，异常信息回答了“为什么”会抛出。</p><a id="more"></a><h4 id="Java异常架构"><a href="#Java异常架构" class="headerlink" title="Java异常架构"></a>Java异常架构</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5trnw45gj30xg0nbact.jpg" alt="Java异常架构"></p><h5 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h5><p>Throwable 是 Java 语言中所有错误与异常的超类。</p><p>Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。</p><p>Throwable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。</p><h5 id="Error（错误）"><a href="#Error（错误）" class="headerlink" title="Error（错误）"></a>Error（错误）</h5><p>定义：Error 类及其子类。程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p><p>特点：此类错误一般表示代码运行时 JVM 出现问题。通常有 Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。</p><p>这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！</p><h5 id="Exception（异常）"><a href="#Exception（异常）" class="headerlink" title="Exception（异常）"></a>Exception（异常）</h5><p>程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</p><p><strong>运行时异常</strong></p><p>定义：RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。</p><p>特点：<strong>Java 编译器不会检查它</strong>。也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。比如NullPointerException空指针异常、ArrayIndexOutBoundException数组下标越界异常、ClassCastException类型转换异常、ArithmeticExecption算术异常。此类异常属于不受检异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理。虽然 Java 编译器不会检查运行时异常，但是我们也可以通过 throws 进行声明抛出，也可以通过 try-catch 对它进行捕获处理。如果产生运行时异常，则需要通过修改代码来进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！</p><p>RuntimeException 异常会由 Java 虚拟机自动抛出并自动捕获（就算我们没写异常捕获语句运行时也会抛出错误！！），此类异常的出现绝大数情况是代码本身有问题应该从逻辑上去解决并改进代码。</p><p><strong>编译时异常</strong></p><p>定义: Exception 中除 RuntimeException 及其子类之外的异常。</p><p>特点: <strong>Java 编译器会检查它</strong>。如果程序中出现此类异常，比如 ClassNotFoundException（没有找到指定的类异常），IOException（IO流异常），要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。在程序中，通常不会自定义该类异常，而是直接使用系统提供的异常类。该异常我们必须手动在代码里添加捕获语句来处理该异常。</p><p><strong>受检异常与非受检异常</strong></p><p>Java 的所有异常可以分为受检异常（checked exception）和非受检异常（unchecked exception）。</p><p><strong>受检异常</strong></p><p>编译器要求必须处理的异常。正确的程序在运行过程中，经常容易出现的、符合预期的异常情况。一旦发生此类异常，就必须采用某种方式进行处理。除 RuntimeException 及其子类外，其他的 Exception 异常都属于受检异常。编译器会检查此类异常，也就是说当编译器检查到应用中的某处可能会此类异常时，将会提示你处理本异常——要么使用try-catch捕获，要么使用方法签名中用 throws 关键字抛出，否则编译不通过。</p><p><strong>非受检异常</strong></p><p>编译器不会进行检查并且不要求必须处理的异常，也就说当程序中出现此类异常时，即使我们没有try-catch捕获它，也没有使用throws抛出该异常，编译也会正常通过。该类异常包括运行时异常（RuntimeException极其子类）和错误（Error）。</p><h4 id="Java异常关键字"><a href="#Java异常关键字" class="headerlink" title="Java异常关键字"></a>Java异常关键字</h4><ul><li>try – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</li><li>catch – 用于捕获异常。catch用来捕获try语句块中发生的异常。</li><li>finally – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</li><li>throw – 用于抛出异常。 </li><li>throws – 用在方法签名中，用于声明该方法可能抛出的异常。</li></ul><h4 id="Java异常处理机制"><a href="#Java异常处理机制" class="headerlink" title="Java异常处理机制"></a>Java异常处理机制</h4><p>Java 通过面向对象的方法进行异常处理，一旦方法抛出异常，系统自动根据该异常对象寻找合适异常处理器（Exception Handler）来处理该异常，把各种不同的异常进行分类，并提供了良好的接口。在 Java 中，<strong>每个异常都是一个对象，它是 Throwable 类或其子类的实例</strong>。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws 和 finally。</p><p>在Java应用中，异常的处理机制分为声明异常，抛出异常和捕获异常。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5trp4s55j30t60h7jsz.jpg" alt="异常处理"></p><h5 id="声明异常"><a href="#声明异常" class="headerlink" title="声明异常"></a>声明异常</h5><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。</p><p>注意，非检查异常（Error、RuntimeException 或它们的子类）不可使用 throws 关键字来声明要抛出的异常。<br>一个方法出现编译时异常，就需要 try-catch/ throws 处理，否则会导致编译错误。</p><h5 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h5><p>如果你觉得解决不了某些异常问题，且不需要调用者处理，那么你可以抛出异常。</p><p>throw关键字作用是在方法内部抛出一个Throwable类型的异常。任何Java代码都可以通过throw语句抛出异常。</p><h5 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h5><p>程序通常在运行之前不报错，但是运行后可能会出现某些未知的错误，但是还不想直接抛出到上一级，那么就需要通过try…catch…的形式进行异常捕获，之后根据不同的异常情况来进行相应的处理。</p><h2 id="Java异常常见面试题"><a href="#Java异常常见面试题" class="headerlink" title="Java异常常见面试题"></a>Java异常常见面试题</h2><h4 id="Error-和-Exception-区别？"><a href="#Error-和-Exception-区别？" class="headerlink" title="Error 和 Exception 区别？"></a>Error 和 Exception 区别？</h4><p>Error 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，JAVA 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复；</p><p>Exception 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。</p><h4 id="运行时异常和一般异常-受检异常-区别是什么？"><a href="#运行时异常和一般异常-受检异常-区别是什么？" class="headerlink" title="运行时异常和一般异常(受检异常)区别是什么？"></a>运行时异常和一般异常(受检异常)区别是什么？</h4><p>运行时异常包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。</p><p>受检异常是Exception 中除 RuntimeException 及其子类之外的异常。 Java 编译器会检查受检异常。</p><p>RuntimeException异常和受检异常之间的区别：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，否则就选择非受检异常(RuntimeException)。一般来讲，如果没有特殊的要求，我们建议使用RuntimeException异常。</p><h4 id="JVM-是如何处理异常的？"><a href="#JVM-是如何处理异常的？" class="headerlink" title="JVM 是如何处理异常的？"></a>JVM 是如何处理异常的？</h4><p>在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</p><p>JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。</p><h4 id="throw-和-throws-？"><a href="#throw-和-throws-？" class="headerlink" title="throw 和 throws ？"></a>throw 和 throws ？</h4><p>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。</p><p>throws 关键字和 throw 关键字在使用上的几点区别如下：</p><ul><li>throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。</li><li>throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</li></ul><h4 id="final、finally、finalize-？"><a href="#final、finally、finalize-？" class="headerlink" title="final、finally、finalize ？"></a>final、finally、finalize ？</h4><ul><li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li><li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li><li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，Java 中允许使用 finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。</li></ul><h4 id="NoClassDefFoundError-和-ClassNotFoundException-？"><a href="#NoClassDefFoundError-和-ClassNotFoundException-？" class="headerlink" title="NoClassDefFoundError 和 ClassNotFoundException ？"></a>NoClassDefFoundError 和 ClassNotFoundException ？</h4><p>NoClassDefFoundError 是一个 Error 类型的异常，是由 JVM 引起的，不应该尝试捕获这个异常。</p><p>引起该异常的原因是 JVM 或 ClassLoader 尝试加载某类时在内存中找不到该类的定义，该动作发生在运行期间，即编译时该类存在，但是在运行时却找不到了，可能是编译后被删除了等原因导致；</p><p>ClassNotFoundException 是一个受检异常，需要显式地使用 try-catch 对其进行捕获和处理，或在方法签名中用 throws 关键字进行声明。当使用 Class.forName, ClassLoader.loadClass 或 ClassLoader.findSystemClass 动态加载类到内存的时候，通过传入的类路径参数没有找到该类，就会抛出该异常；另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中，另一个加载器又尝试去加载它。</p><h4 id="如果-catch-中-return-了，finally-还会执行吗？"><a href="#如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="如果 catch 中 return 了，finally 还会执行吗？"></a>如果 catch 中 return 了，finally 还会执行吗？</h4><p>答：会执行，在 return 前执行。</p><p>注意：</p><p>在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，try中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值，</p><p>然后如果在 finally 中修改了返回值，就会返回修改后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java 中也可以通过提升编译器的语法检查级别来产生警告或错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Java异常简介&quot;&gt;&lt;a href=&quot;#Java异常简介&quot; class=&quot;headerlink&quot; title=&quot;Java异常简介&quot;&gt;&lt;/a&gt;Java异常简介&lt;/h4&gt;&lt;p&gt;Java异常是Java提供的一种识别及响应错误的一致性机制。&lt;/p&gt;
&lt;p&gt;Java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。在有效使用异常的情况下，异常能清晰的回答what, where, why这3个问题：异常类型回答了“什么”被抛出，异常堆栈跟踪回答了“在哪”抛出，异常信息回答了“为什么”会抛出。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java设计模式</title>
    <link href="http://yoursite.com/2020/05/30/Java%E5%9F%BA%E7%A1%80/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/05/30/Java%E5%9F%BA%E7%A1%80/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2020-06-08T00:57:51.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="S-O-L-I-D"><a href="#S-O-L-I-D" class="headerlink" title="S.O.L.I.D"></a>S.O.L.I.D</h3><table><thead><tr><th>简写</th><th>全拼</th><th>中文翻译</th></tr></thead><tbody><tr><td>SRP</td><td>The Single Responsibility Principle</td><td>单一责任原则</td></tr><tr><td>OCP</td><td>The Open Closed Principle</td><td>开放封闭原则</td></tr><tr><td>LSP</td><td>The Liskov Substitution Principle</td><td>里氏替换原则</td></tr><tr><td>ISP</td><td>The Interface Segregation Principle</td><td>接口分离原则</td></tr><tr><td>DIP</td><td>The Dependency Inversion Principle</td><td>依赖倒置原则</td></tr></tbody></table><a id="more"></a><h4 id="1-单一责任原则"><a href="#1-单一责任原则" class="headerlink" title="1. 单一责任原则"></a>1. 单一责任原则</h4><blockquote><p>  修改一个类的原因应该只有一个。</p></blockquote><p>换句话说就是<strong>让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类</strong>。</p><p>如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。</p><h4 id="2-开放封闭原则"><a href="#2-开放封闭原则" class="headerlink" title="2. 开放封闭原则"></a>2. 开放封闭原则</h4><blockquote><p>  类应该对扩展开放，对修改关闭。</p></blockquote><p>扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。</p><p>符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。</p><h4 id="3-里氏替换原则"><a href="#3-里氏替换原则" class="headerlink" title="3. 里氏替换原则"></a>3. 里氏替换原则</h4><blockquote><p>  子类对象必须能够替换掉所有父类对象。</p></blockquote><p>继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。</p><p>如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。</p><h4 id="4-接口分离原则"><a href="#4-接口分离原则" class="headerlink" title="4. 接口分离原则"></a>4. 接口分离原则</h4><blockquote><p>  不应该强迫客户依赖于它们不用的方法。</p></blockquote><p>因此使用多个专门的接口比使用单一的总接口要好。</p><h4 id="5-依赖倒置原则"><a href="#5-依赖倒置原则" class="headerlink" title="5. 依赖倒置原则"></a>5. 依赖倒置原则</h4><blockquote><p>  高层模块不应该依赖于低层模块，二者都应该依赖于抽象；<br>  抽象不应该依赖于细节，细节应该依赖于抽象。</p></blockquote><p>高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。</p><p>依赖于抽象意味着：</p><ul><li>任何变量都不应该持有一个指向具体类的指针或者引用；</li><li>任何类都不应该从具体类派生；</li><li>任何方法都不应该覆写它的任何基类中的已经实现的方法。</li></ul><h3 id="其他常见原则"><a href="#其他常见原则" class="headerlink" title="其他常见原则"></a>其他常见原则</h3><p>除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。</p><table><thead><tr><th>简写</th><th>全拼</th><th>中文翻译</th></tr></thead><tbody><tr><td>LOD</td><td>The Law of Demeter</td><td>迪米特法则</td></tr><tr><td>CRP</td><td>The Composite Reuse Principle</td><td>合成复用原则</td></tr><tr><td>CCP</td><td>The Common Closure Principle</td><td>共同封闭原则</td></tr><tr><td>SAP</td><td>The Stable Abstractions Principle</td><td>稳定抽象原则</td></tr><tr><td>SDP</td><td>The Stable Dependencies Principle</td><td>稳定依赖原则</td></tr></tbody></table><h4 id="1-迪米特法则"><a href="#1-迪米特法则" class="headerlink" title="1. 迪米特法则"></a>1. 迪米特法则</h4><p>迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。</p><h4 id="2-合成复用原则"><a href="#2-合成复用原则" class="headerlink" title="2. 合成复用原则"></a>2. 合成复用原则</h4><p>尽量使用对象组合，而不是通过继承来达到复用的目的。</p><h4 id="3-共同封闭原则"><a href="#3-共同封闭原则" class="headerlink" title="3. 共同封闭原则"></a>3. 共同封闭原则</h4><p>一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。</p><h4 id="4-稳定抽象原则"><a href="#4-稳定抽象原则" class="headerlink" title="4. 稳定抽象原则"></a>4. 稳定抽象原则</h4><p>最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。</p><h4 id="5-稳定依赖原则"><a href="#5-稳定依赖原则" class="headerlink" title="5. 稳定依赖原则"></a>5. 稳定依赖原则</h4><p>包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h3><h4 id="单例模式（Singleton）"><a href="#单例模式（Singleton）" class="headerlink" title="单例模式（Singleton）"></a>单例模式（Singleton）</h4><p><strong>Intent</strong></p><p>确保一个类只有一个实例，并提供该实例的全局访问点。</p><p><strong>Class Diagram</strong></p><p>使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。</p><p>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5tri9r9hj30cd0873ym.jpg" alt="img"></p><p><strong>Implementation</strong></p><p><strong>Ⅰ 懒汉式-线程不安全</strong></p><p>以下实现中，私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。</p><p>这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 <code>if (uniqueInstance == null)</code> ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 <code>uniqueInstance = new Singleton();</code> 语句，这将导致实例化多次 uniqueInstance。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Ⅱ 饿汉式-线程安全</strong></p><p>线程不安全问题主要是由于 uniqueInstance 被实例化多次，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全问题。</p><p>但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.在本类内部创建对象实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">//3.提供一个共有的静态方法，返回实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Ⅲ 懒汉式-线程安全</strong></p><p>只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次 uniqueInstance。</p><p>但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 uniqueInstance 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Ⅳ 双重校验锁-线程安全</strong></p><p>uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。</p><p>双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑下面的实现，也就是只使用了一个 if 语句。在 uniqueInstance == null 的情况下，如果两个线程都执行了 if 语句，那么两个线程都会进入 if 语句块内。虽然在 if 语句块内有加锁操作，但是两个线程都会执行 <code>uniqueInstance = new Singleton();</code> 这条语句，只是先后的问题，那么就会进行两次实例化。</p><p>因此必须使用双重校验锁，也就是需要使用两个 if 语句：<strong>第一个 if 语句用来避免 uniqueInstance 已经被实例化之后的加锁操作，而第二个 if 语句进行了加锁，所以只能有一个线程进入，就不会出现 uniqueInstance == null 时两个线程同时进行实例化操作。</strong></p><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的，<code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ol><p>但是由于 JVM 具有<strong>指令重排</strong>的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p><p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><p><strong>Ⅴ 静态内部类实现</strong></p><p>当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 <code>getUniqueInstance()</code> 方法从而触发 <code>SingletonHolder.INSTANCE</code> 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。</p><p>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Ⅵ 枚举实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String objName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getObjName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObjName</span><span class="params">(String objName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objName = objName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 单例测试</span></span><br><span class="line">        Singleton firstSingleton = Singleton.INSTANCE;</span><br><span class="line">        firstSingleton.setObjName(<span class="string">"firstName"</span>);</span><br><span class="line">        System.out.println(firstSingleton.getObjName());</span><br><span class="line">        Singleton secondSingleton = Singleton.INSTANCE;</span><br><span class="line">        secondSingleton.setObjName(<span class="string">"secondName"</span>);</span><br><span class="line">        System.out.println(firstSingleton.getObjName());</span><br><span class="line">        System.out.println(secondSingleton.getObjName());</span><br><span class="line">        <span class="comment">// 反射获取实例测试</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Singleton[] enumConstants = Singleton<span class="class">.<span class="keyword">class</span>.<span class="title">getEnumConstants</span>()</span>;</span><br><span class="line">            <span class="keyword">for</span> (Singleton enumConstant : enumConstants) &#123;</span><br><span class="line">                System.out.println(enumConstant.getObjName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">firstName</span><br><span class="line">secondName</span><br><span class="line">secondName</span><br><span class="line">secondName</span><br></pre></td></tr></table></figure><p>该实现可以防止反射攻击。在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。</p><p>该实现在多次序列化和序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。</p><h4 id="简单工厂（Simple-Factory）"><a href="#简单工厂（Simple-Factory）" class="headerlink" title="简单工厂（Simple Factory）"></a>简单工厂（Simple Factory）</h4><p><strong>Intent</strong></p><p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</p><p><strong>Class Diagram</strong></p><p>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。</p><p>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</p><h4 id="工厂方法（Factory-Method）"><a href="#工厂方法（Factory-Method）" class="headerlink" title="工厂方法（Factory Method）"></a>工厂方法（Factory Method）</h4><p><strong>Intent</strong></p><p>定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</p><p><strong>Class Diagram</strong></p><p>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。</p><h4 id="抽象工厂（Abstract-Factory）"><a href="#抽象工厂（Abstract-Factory）" class="headerlink" title="抽象工厂（Abstract Factory）"></a>抽象工厂（Abstract Factory）</h4><p><strong>Intent</strong></p><p>提供一个接口，用于创建 <strong>相关的对象家族</strong> 。</p><p><strong>Class Diagram</strong></p><p>抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。</p><p>抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。</p><p>至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。</p><p>从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;设计原则&quot;&gt;&lt;a href=&quot;#设计原则&quot; class=&quot;headerlink&quot; title=&quot;设计原则&quot;&gt;&lt;/a&gt;设计原则&lt;/h2&gt;&lt;h3 id=&quot;S-O-L-I-D&quot;&gt;&lt;a href=&quot;#S-O-L-I-D&quot; class=&quot;headerlink&quot; title=&quot;S.O.L.I.D&quot;&gt;&lt;/a&gt;S.O.L.I.D&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;简写&lt;/th&gt;
&lt;th&gt;全拼&lt;/th&gt;
&lt;th&gt;中文翻译&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;SRP&lt;/td&gt;
&lt;td&gt;The Single Responsibility Principle&lt;/td&gt;
&lt;td&gt;单一责任原则&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OCP&lt;/td&gt;
&lt;td&gt;The Open Closed Principle&lt;/td&gt;
&lt;td&gt;开放封闭原则&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LSP&lt;/td&gt;
&lt;td&gt;The Liskov Substitution Principle&lt;/td&gt;
&lt;td&gt;里氏替换原则&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ISP&lt;/td&gt;
&lt;td&gt;The Interface Segregation Principle&lt;/td&gt;
&lt;td&gt;接口分离原则&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DIP&lt;/td&gt;
&lt;td&gt;The Dependency Inversion Principle&lt;/td&gt;
&lt;td&gt;依赖倒置原则&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java集合</title>
    <link href="http://yoursite.com/2020/05/30/Java%E5%9F%BA%E7%A1%80/java%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2020/05/30/Java%E5%9F%BA%E7%A1%80/java%E9%9B%86%E5%90%88/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2020-07-01T15:04:29.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集合分类"><a href="#集合分类" class="headerlink" title="集合分类"></a>集合分类</h2><p>Java 容器分为 Collection 和 Map 两大类：</p><p>Collection集合主要有List和Set两大接口</p><ul><li>Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</li><li>List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList。<br>Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</li></ul><a id="more"></a><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul><li><p>Arraylist： Object数组</p></li><li><p>Vector： Object数组</p></li><li><p>LinkedList： 双向循环链表</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3></li><li><p>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</p></li><li><p>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。</p></li><li><p>TreeSet（有序，唯一）： 红黑树（自平衡的排序二叉树）。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3></li><li><p>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为<strong>红黑树</strong>，以减少搜索时间。</p></li><li><p>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，<strong>增加了一条双向链表</strong>，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</p></li><li><p>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。</p></li><li><p>TreeMap： 红黑树（自平衡的排序二叉树）</p><h2 id="线程安全的集合类"><a href="#线程安全的集合类" class="headerlink" title="线程安全的集合类"></a>线程安全的集合类</h2></li><li><p>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。</p></li><li><p>stack：堆栈类，先进后出。</p></li><li><p>hashtable：就比hashmap多了个线程安全。</p></li><li><p>enumeration：枚举，相当于迭代器。</p><h2 id="快速失败-fail-fast-和安全失败-fail-safe"><a href="#快速失败-fail-fast-和安全失败-fail-safe" class="headerlink" title="快速失败(fail-fast)和安全失败(fail-safe)"></a>快速失败(fail-fast)和安全失败(fail-safe)</h2><h3 id="快速失败（fail—fast）"><a href="#快速失败（fail—fast）" class="headerlink" title="快速失败（fail—fast）"></a>快速失败（fail—fast）</h3></li></ul><p>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。</p><p>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p>注意：这里异常的抛出条件是检测到 modCount != expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</p><p>场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</p><h3 id="安全失败（fail—safe）"><a href="#安全失败（fail—safe）" class="headerlink" title="安全失败（fail—safe）"></a>安全失败（fail—safe）</h3><p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p><p>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p><p>缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p><p>场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p><h2 id="集合和数组的区别"><a href="#集合和数组的区别" class="headerlink" title="集合和数组的区别"></a>集合和数组的区别</h2><ul><li>数组是固定长度的；集合可变长度的。</li><li>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</li><li>数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。<h2 id="使用集合框架的好处"><a href="#使用集合框架的好处" class="headerlink" title="使用集合框架的好处"></a>使用集合框架的好处</h2></li></ul><ol><li>容量自增长；</li><li>提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量；</li><li>允许不同 API 之间的互操作，API之间可以来回传递集合；</li><li>可以方便地扩展或改写集合，提高代码复用性和可操作性;</li><li>通过使用JDK自带的集合类，可以降低代码维护和学习新API成本。<h2 id="确保一个集合不能被修改"><a href="#确保一个集合不能被修改" class="headerlink" title="确保一个集合不能被修改"></a>确保一个集合不能被修改</h2>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java.lang. UnsupportedOperationException 异常：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list. add(<span class="string">"x"</span>);</span><br><span class="line">Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);</span><br><span class="line">clist. add(<span class="string">"y"</span>); <span class="comment">// 运行时此行报错</span></span><br><span class="line">System. out. println(list. size());</span><br></pre></td></tr></table></figure><h2 id="comparable-和-comparator"><a href="#comparable-和-comparator" class="headerlink" title="comparable 和 comparator"></a>comparable 和 comparator</h2><ul><li>comparable接口出自java.lang包，它有一个compareTo(Object obj)方法用来排序</li><li>comparator接口出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序<br>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort()。</li></ul><h2 id="Collection-和-Collections"><a href="#Collection-和-Collections" class="headerlink" title="Collection 和 Collections"></a>Collection 和 Collections</h2><ul><li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li><li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。<br>Collections 工具类的 sort 方法有两种重载的形式，</li></ul><ol><li><p>第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较。</p></li><li><p>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。</p></li></ol><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><h3 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器 Iterator"></a>迭代器 Iterator</h3><p>Iterator 接口提供遍历任何 <strong>Collection</strong> 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p><h4 id="单向遍历"><a href="#单向遍历" class="headerlink" title="单向遍历"></a>单向遍历</h4><p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    String obj = it.next();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Iterator-和-ListIterator"><a href="#Iterator-和-ListIterator" class="headerlink" title="Iterator 和 ListIterator"></a>Iterator 和 ListIterator</h4><ul><li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li><li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历。</li><li>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。<h3 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h3><h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4></li></ul><ol><li><p>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。</p></li><li><p>迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。</p></li><li><p>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</p></li></ol><p><strong>RandomAccess</strong></p><p>Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。</p><ul><li><p>如果一个数据集合实现了该接口，就意味着它支持 RandomAccess，按位置读取元素的平均时间复杂度为 <strong>O(1)</strong>，如ArrayList。</p></li><li><p>如果没有实现该接口，表示不支持 RandomAccess，如LinkedList。</p></li><li><p>推荐的做法就是，支持 RandomAccess 的列表可用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。</p><h4 id="ArrayList-的优缺点"><a href="#ArrayList-的优缺点" class="headerlink" title="ArrayList 的优缺点"></a>ArrayList 的优缺点</h4><p>ArrayList的优点如下：</p></li><li><p>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。</p></li><li><p>ArrayList 在顺序添加一个元素的时候非常方便。<br>ArrayList 的缺点如下：</p></li><li><p>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。</p></li><li><p>插入元素的时候，也需要做一次元素复制操作，缺点同上。<br>ArrayList 比较适合<strong>顺序添加、随机访问</strong>的场景。</p></li></ul><h4 id="数组和-List-的转换"><a href="#数组和-List-的转换" class="headerlink" title="数组和 List 的转换"></a>数组和 List 的转换</h4><ul><li>数组转 List：使用 Arrays. asList(array) 进行转换。</li><li>List 转数组：使用 List 自带的 toArray() 方法。<h4 id="ArrayList-和-LinkedList-区别"><a href="#ArrayList-和-LinkedList-区别" class="headerlink" title="ArrayList 和 LinkedList 区别"></a>ArrayList 和 LinkedList 区别</h4></li><li>数据结构实现：ArrayList 是<strong>动态数组</strong>的数据结构实现，而 LinkedList 是<strong>双向链表</strong>的数据结构实现。</li><li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li><li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li><li>内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li><li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全。<br>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</li></ul><h4 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h4><p>ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。transient 的作用是说不希望 elementData 数组被序列化，每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。</p><h3 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h3><h4 id="HashSet-的实现原理"><a href="#HashSet-的实现原理" class="headerlink" title="HashSet 的实现原理"></a>HashSet 的实现原理</h4><p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p><h4 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复"></a>HashSet 如何检查重复</h4><p>向HashSet 中add()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equals()方法比较。 HashSet 中的add()方法会使用HashMap 的put()方法。</p><p>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V，所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span></span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode() 与 equals()"></a>hashCode() 与 equals()</h4><ul><li>如果两个对象相等，则hashcode()一定也是相同的</li><li>两个对象相等,对两个equals()方法返回true</li><li>两个对象有相同的hashcode()值，它们不一定是相等的<h4 id="HashSet与HashMap的区别"><a href="#HashSet与HashMap的区别" class="headerlink" title="HashSet与HashMap的区别"></a>HashSet与HashMap的区别</h4><table><thead><tr><th>HashMap</th><th>HashSet</th></tr></thead><tbody><tr><td>实现了Map接口</td><td>实现Set接口</td></tr><tr><td>存储键值对</td><td>仅存储对象</td></tr><tr><td>调用put()向map中添加元素</td><td>调用add()方法向Set中添加元素</td></tr><tr><td>HashMap使用键(Key)计算hashcode</td><td>hashSet使用成员对象来计算hashcode值</td></tr><tr><td>较快，因为它是使用唯一的键获取对象</td><td>HashSet较HashMap来说比较慢</td></tr><tr><td>### Queue</td><td></td></tr><tr><td>#### 阻塞队列BlockingQueue</td><td></td></tr><tr><td>Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现==生产者-消费者模式==。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</td><td></td></tr></tbody></table></li></ul><h4 id="poll-和-remove-区别"><a href="#poll-和-remove-区别" class="headerlink" title="poll()和 remove()区别"></a>poll()和 remove()区别</h4><p>0相同点：都是返回第一个元素，并在队列中删除返回的对象。<br>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</p><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><h4 id="HashMap-的实现原理"><a href="#HashMap-的实现原理" class="headerlink" title="HashMap 的实现原理"></a>HashMap 的实现原理</h4><p>put元素时，利用key的hashCode值计算出当前对象的元素在数组中的下标存储时，如果出现hash值相同的key，此时有两种情况：</p><ol><li>如果key相同，则覆盖原始值；</li><li>如果key不同（出现冲突），则将当前的key-value放入链表中<br>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</li></ol><h4 id="put方法的具体流程"><a href="#put方法的具体流程" class="headerlink" title="put方法的具体流程"></a>put方法的具体流程</h4><p>put的时候，首先计算 key的hash值，这里调用了 hash方法，hash方法实际是让key.hashCode()与key.hashCode()&gt;&gt;&gt;16进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：==高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞==。按照函数注释，因为bucket数组大小是2的幂，计算下标index = (table.length - 1) &amp; hash，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。</p><h4 id="HashMap的扩容操作"><a href="#HashMap的扩容操作" class="headerlink" title="HashMap的扩容操作"></a>HashMap的扩容操作</h4><ul><li><p>在jdk1.8中，在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；</p></li><li><p>每次扩展的时候，都是扩展2倍；</p></li><li><p>扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。<br>resize() 方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12)，这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方：</p></li><li><p>在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发；</p></li><li><p>在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上。</p><h4 id="Hash冲突"><a href="#Hash冲突" class="headerlink" title="Hash冲突"></a>Hash冲突</h4></li></ul><p><strong>哈希的概念</strong></p><p>Hash，一般翻译为“散列”，也有直接音译为“哈希”的，就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p><p>所有散列函数都有如下一个基本特性：<strong>根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同</strong>。</p><p><strong>HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</strong></p><p>hashCode()方法返回的是int整数类型，其范围为-(2 ^ 31)(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过hashCode()计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</p><p>所以HashMap自己实现了自己的hash()方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均。</p><p>在保证数组长度为2的幂次方的时候，使用hash()运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；</p><p><strong>HashMap 的长度为什么是2的幂次方</strong></p><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</p><p>这个算法应该如何设计呢？</p><p>我们首先可能会想到采用取余的操作来实现。但是，重点来了：取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方）， 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</p><p><strong>那为什么是两次扰动呢？</strong></p><p>这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性和均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的。</p><p><strong>解决hash冲突的方式</strong></p><p><em>JDK1.8之前</em></p><p>JDK1.8之前采用的是拉链法。</p><p>拉链法：将链表和数组相结合。创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p>相比于hashCode返回的int类型，我们HashMap初始的容量大小 DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4（即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的下标将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，所以我们还需要对hashCode作一定的优化。</p><p><em>JDK1.8之后</em></p><p><strong>优化hash函数</strong></p><p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于==参与运算的只有hashCode的低位，高位是没有起到任何作用的==，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为扰动，在JDK 1.8中的hash()函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// 与自己右移16位进行异或运算（高低位异或）</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这比在JDK 1.7中，更为简洁，相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）。</p><p><strong>新增红黑树</strong></p><p>当链表长度大于阈值（默认为8）且数组长度大于64时，将链表转化为红黑树，以减少搜索时间，从原来的O(n)到O(logn)。（链表长度大于阈值，但是数组长度小于64时会首先进行扩容）</p><h4 id="链表成环（死循环）"><a href="#链表成环（死循环）" class="headerlink" title="链表成环（死循环）"></a>链表成环（死循环）</h4><p>多线程操作HashMap时可能引起死循环。</p><p>我先举个例子吧，我们现在往一个容量大小为2的put两个值，负载因子是0.75，2*0.75 = 1 所以插入第二个就要resize了，我们要在容量为2的容器里面用不同线程插入A，B，C，假如我们在resize之前打个短点，那意味着数据都插入了但是还没resize那扩容前可能是这样的。</p><p>因为resize的赋值方式，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置，==在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。==一旦几个线程都调整完成，就可能出现环形链表。</p><p>使用头插会改变链表的上的顺序，但是如果使用尾插，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。</p><ul><li>Java7在多线程操作HashMap时可能引起死循环，原因是扩容转移后前后链表顺序倒置，在转移过程中修改了原来链表中节点的引用关系。</li><li>Java8在同样的前提下并不会引起死循环，原因是扩容转移后前后链表顺序不变，保持之前节点的引用关系。<br>我认为即使不会出现死循环，但是通过源码看到put/get方法都没有加同步锁，多线程情况最容易出现的就是：无法保证上一秒put的值，下一秒get的时候还是原值，所以线程安全还是无法保证。</li></ul><h4 id="类作为key的条件"><a href="#类作为key的条件" class="headerlink" title="类作为key的条件"></a>类作为key的条件</h4><p>可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：</p><ul><li>如果类重写了 equals() 方法，也应该重写 hashCode() 方法。</li><li>类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。</li><li>如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。</li><li>用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</li></ul><p><strong>为什么HashMap中String、Integer这样的包装类适合作为K？</strong></p><p>String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p><ul><li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况。</li><li>内部已重写了equals()、hashCode()等方法，遵守了HashMap内部的规范，不容易出现Hash值计算错误的情况。</li></ul><p><strong>如果使用Object作为HashMap的Key，应该怎么办呢？</strong></p><p>重写hashCode()和equals()方法</p><ul><li>重写hashCode()是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</li><li>重写equals()方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性；<h4 id="HashMap-与-HashTable-区别"><a href="#HashMap-与-HashTable-区别" class="headerlink" title="HashMap 与 HashTable 区别"></a>HashMap 与 HashTable 区别</h4></li></ul><ol><li><p>线程安全： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 synchronized 修饰。（如果要保证线程安全的话就使用 ConcurrentHashMap 吧！）</p></li><li><p>效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</p></li><li><p>对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。</p></li><li><p>初始容量大小和每次扩充容量大小的不同 ：</p><ul><li>创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。</li><li>创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 <strong>HashMap 总是使用2的幂作为哈希表的大小</strong>。</li></ul></li><li><p>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p></li></ol><p>在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</p><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p><strong>底层数据结构</strong></p><p>JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表实现，JDK1.8 采用的数据结构跟HashMap的结构一样，数组+链表/红黑二叉树。HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</p><p><strong>实现线程安全的方式</strong></p><p><em>JDK1.7</em></p><p>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现。</p><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</p><p><em>JDK1.8</em></p><p>JDK1.8 的时候已经摒弃了Segment的概念，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现。synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发。</p><h4 id="TreeMap-和-TreeSet"><a href="#TreeMap-和-TreeSet" class="headerlink" title="TreeMap 和 TreeSet"></a>TreeMap 和 TreeSet</h4><ul><li>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。</li><li>TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口，从而根据键对元素进行排序。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;集合分类&quot;&gt;&lt;a href=&quot;#集合分类&quot; class=&quot;headerlink&quot; title=&quot;集合分类&quot;&gt;&lt;/a&gt;集合分类&lt;/h2&gt;&lt;p&gt;Java 容器分为 Collection 和 Map 两大类：&lt;/p&gt;
&lt;p&gt;Collection集合主要有List和Set两大接口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。&lt;/li&gt;
&lt;li&gt;List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList。&lt;br&gt;Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java虚拟机</title>
    <link href="http://yoursite.com/2020/05/30/Java%E5%9F%BA%E7%A1%80/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://yoursite.com/2020/05/30/Java%E5%9F%BA%E7%A1%80/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2020-06-08T00:57:51.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM-的主要组成部分"><a href="#JVM-的主要组成部分" class="headerlink" title="JVM 的主要组成部分"></a>JVM 的主要组成部分</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf004cfo6tj30y90jnjxw.jpg" alt="JVM主要组成部分"></p><p>JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。</p><ul><li><p>Class loader(类装载)：根据给定的全类名(如：java.lang.Object)来装载class文件到运行时区域中的方法区。</p></li><li><p>Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。</p></li><li><p>Execution engine(执行引擎)：执行class中的指令。</p></li><li><p>Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。</p></li></ul><a id="more"></a><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5togp3xij30kd0sl0uh.jpg" alt="img" style="zoom:50%;" /><p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成。</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p><p>可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M：</p><p>该区域可能抛出以下异常：</p><ul><li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</li><li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。</li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的。</p><p>本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存，也是垃圾收集的主要区域（”GC 堆”）。</p><p>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：</p><ul><li>新生代（Young Generation）</li><li>老年代（Old Generation）</li></ul><p>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</p><h4 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h4><ol><li><p>物理地址</p><ul><li><p>堆的物理地址分配对对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。</p></li><li><p>栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。</p></li></ul></li><li><p>内存分别</p><ul><li><p>堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般堆大小远远大于栈。</p></li><li><p>栈是连续的，所以分配的内存大小要在编译期就确认，大小是固定的。</p></li></ul></li><li><p>存放的内容</p><ul><li><p>堆存放的是对象的实例和数组。因此该区更关注的是数据的存储</p></li><li><p>栈存放：局部变量，操作数栈，返回结果。更关注的是程序方法的执行。</p></li></ul></li><li><p>程序的可见度</p><ul><li><p>堆对于整个应用程序都是共享、可见的。</p></li><li><p>栈只对于线程是可见的，所以也是线程私有，生命周期和线程相同。</p></li></ul></li></ol><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</p><p>和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。</p><p>HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</p><p>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池是方法区的一部分。</p><p>Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。</p><p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>在 JDK 1.4 中新引入了 NIO 类，它可以将本地方法库直接分配到堆外内存，然后通过堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</p><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。</p><p>但是，即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。</p><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</p><p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。</p><h3 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a>判断一个对象是否可被回收</h3><h4 id="1-引用计数算法"><a href="#1-引用计数算法" class="headerlink" title="1. 引用计数算法"></a>1. 引用计数算法</h4><p>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p><p>在两个对象出现<strong>循环引用</strong>的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test a = <span class="keyword">new</span> Test();</span><br><span class="line">        Test b = <span class="keyword">new</span> Test();</span><br><span class="line">        a.instance = b;</span><br><span class="line">        b.instance = a;</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        b = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。</p><h4 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2. 可达性分析算法"></a>2. 可达性分析算法</h4><p>采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。</p><p>以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。</p><p>Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：</p><ul><li>虚拟机栈中局部变量表中引用的对象</li><li>本地方法栈中 JNI 中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ul><h3 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h3><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</p><p>主要是对常量池的回收和对类的卸载。</p><p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</p><p>类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</p><ul><li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li></ul><h3 id="finalize-函数"><a href="#finalize-函数" class="headerlink" title="finalize()函数"></a>finalize()函数</h3><p>类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p><p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p><p>Java 提供了四种强度不同的引用类型。</p><h4 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1. 强引用"></a>1. 强引用</h4><p>被强引用关联的对象不会被回收。</p><p>使用 new 一个新对象的方式来创建强引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><h4 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2. 软引用"></a>2. 软引用</h4><p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p><p>使用 SoftReference 类来创建软引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure><h4 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3. 弱引用"></a>3. 弱引用</h4><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p><p>使用 WeakReference 类来创建弱引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h4 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4. 虚引用"></a>4. 虚引用</h4><p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p><p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p><p>使用 PhantomReference 来创建虚引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj, <span class="keyword">null</span>);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记 - 清除"></a>标记 - 清除</h4><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5tqwqbz6j30ia0a90st.jpg" alt="img" style="zoom:67%;" /><p>标记无用对象，然后进行清除回收。</p><p>标记-清除算法（Mark-Sweep）是一种常见的基础垃圾收集算法，它将垃圾收集分为两个阶段：</p><ol><li>标记阶段：标记出可以回收的对象。</li><li>清除阶段：回收被标记的对象所占用的空间。</li></ol><p>标记-清除算法之所以是基础的，是因为后面讲到的垃圾收集算法都是在此算法的基础上进行改进的。</p><ul><li><p>优点：实现简单，不需要对象进行移动。</p></li><li><p>缺点：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。</p></li></ul><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5tslijnej30i209f0su.jpg" alt="img" style="zoom:67%;" /><p>为了解决标记-清除算法的效率不高的问题，产生了复制算法。它把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中，最后将当前使用的区域的可回收的对象进行回收。</p><ul><li>优点：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。</li><li>缺点：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。</li></ul><h4 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记 - 整理"></a>标记 - 整理</h4><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5tsnco95j30ia09r0st.jpg" alt="img" style="zoom:67%;" /><p>在新生代中可以使用复制算法，但是在老年代就不能选择复制算法了，因为老年代的对象存活率会较高，这样会有较多的复制操作，导致效率变低。标记-清除算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存碎片。因此就出现了一种标记-整理算法（Mark-Compact）算法，与标记-整理算法不同的是，在标记可回收的对象后将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起，然后对端边界以外的内存进行回收。回收后，已用和未用的内存都各自一边。</p><ul><li><p>优点：解决了标记-清理算法存在的内存碎片问题。</p></li><li><p>缺点：仍需要进行局部对象移动，一定程度上降低了效率。</p></li></ul><h4 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h4><p>当前商业虚拟机都采用分代收集的垃圾收集算法。分代收集算法，顾名思义是根据对象的存活周期将内存划分为几块，一般包括年轻代和老年代。</p><p>一般将堆分为新生代和老年代。</p><ul><li>新生代使用：复制算法</li><li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li></ul><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5tspm8g3j30hy0av0td.jpg" alt="img"></p><p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p><ul><li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li><li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li></ul><p>新生代垃圾回收器一般采用的是复制算法；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p><ol><li>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li><li>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li><li>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</li><li>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；</li><li>Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</li><li>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</li><li>G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</li></ol><h3 id="分代垃圾回收器的工作过程"><a href="#分代垃圾回收器的工作过程" class="headerlink" title="分代垃圾回收器的工作过程"></a>分代垃圾回收器的工作过程</h3><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p><p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p><ol><li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</li><li>清空 Eden 和 From Survivor 分区；</li><li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</li></ol><p>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p><p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><h3 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h3><ul><li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li><li>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</li></ul><h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><h4 id="1-对象优先在-Eden-分配"><a href="#1-对象优先在-Eden-分配" class="headerlink" title="1. 对象优先在 Eden 分配"></a>1. 对象优先在 Eden 分配</h4><p>多数情况，对象都在新生代 Eden 区分配。当 Eden 区分配没有足够的空间进行分配时，虚拟机将会发起一次 Minor GC。如果本次 GC 后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。</p><h4 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h4><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p><p>前面我们介绍过新生代使用的是标记-清除算法来处理垃圾回收的，如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分配。</p><h4 id="3-长期存活的对象进入老年代"><a href="#3-长期存活的对象进入老年代" class="headerlink" title="3. 长期存活的对象进入老年代"></a>3. 长期存活的对象进入老年代</h4><p>虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区中每「熬过」一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升到老年代。</p><h4 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h4><p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p><h4 id="5-空间分配担保机制"><a href="#5-空间分配担保机制" class="headerlink" title="5. 空间分配担保机制"></a>5. 空间分配担保机制</h4><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p><p>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</p><h3 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h3><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p><h4 id="1-调用-System-gc"><a href="#1-调用-System-gc" class="headerlink" title="1. 调用 System.gc()"></a>1. 调用 System.gc()</h4><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p><h4 id="2-老年代空间不足"><a href="#2-老年代空间不足" class="headerlink" title="2. 老年代空间不足"></a>2. 老年代空间不足</h4><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p><p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p><h4 id="3-空间分配担保失败"><a href="#3-空间分配担保失败" class="headerlink" title="3. 空间分配担保失败"></a>3. 空间分配担保失败</h4><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。</p><h4 id="4-JDK-1-7-及以前的永久代空间不足"><a href="#4-JDK-1-7-及以前的永久代空间不足" class="headerlink" title="4. JDK 1.7 及以前的永久代空间不足"></a>4. JDK 1.7 及以前的永久代空间不足</h4><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p><p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p><p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p><h4 id="5-Concurrent-Mode-Failure"><a href="#5-Concurrent-Mode-Failure" class="headerlink" title="5. Concurrent Mode Failure"></a>5. Concurrent Mode Failure</h4><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p><h2 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h2><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类，因为如果一次性加载，那么会占用很多的内存。</p><p>Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。</p><p><strong>类装载方式：</strong></p><ol><li><p>隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中</p></li><li><p>显式装载， 通过class.forname()等方法，显式加载需要的类</p></li></ol><p><strong>类装载过程：</strong></p><ol><li>通过编译器把 Java 代码转换成字节码</li><li>类加载器把字节码加载到内存中，将其放在运行时数据区的方法区内</li><li>字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口来实现整个程序的功能</li></ol><h3 id="类装载的执行过程"><a href="#类装载的执行过程" class="headerlink" title="类装载的执行过程"></a>类装载的执行过程</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5tsut5fnj30u50750ta.jpg" alt="img"></p><p>类装载分为以下 5 个步骤：</p><ol><li>加载：根据查找路径找到相应的 class 文件然后导入；</li><li>验证：检查加载的 class 文件的正确性；</li><li>准备：给类中的静态变量分配内存空间；</li><li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li><li>初始化：对静态变量和静态代码块执行初始化工作。</li></ol><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据全类名将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p><p><strong>类加载器分类</strong></p><ul><li>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</li></ul><p>其他类加载器：</p><ul><li>扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</li><li>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li></ul><p><strong>双亲委派模型</strong></p><p>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p><p><strong>好处</strong></p><p>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。</p><blockquote><p>  例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。</p></blockquote><h3 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h3><h4 id="1-主动引用"><a href="#1-主动引用" class="headerlink" title="1. 主动引用"></a>1. 主动引用</h4><p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：</p><ul><li>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。</li><li>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；</li><li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</li></ul><h4 id="2-被动引用"><a href="#2-被动引用" class="headerlink" title="2. 被动引用"></a>2. 被动引用</h4><p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p><ul><li>通过子类引用父类的静态字段，不会导致子类初始化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(SubClass.value);  <span class="comment">// value 字段在 SuperClass 中定义</span></span><br></pre></td></tr></table></figure><ul><li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><ul><li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JVM-的主要组成部分&quot;&gt;&lt;a href=&quot;#JVM-的主要组成部分&quot; class=&quot;headerlink&quot; title=&quot;JVM 的主要组成部分&quot;&gt;&lt;/a&gt;JVM 的主要组成部分&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gf004cfo6tj30y90jnjxw.jpg&quot; alt=&quot;JVM主要组成部分&quot;&gt;&lt;/p&gt;
&lt;p&gt;JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Class loader(类装载)：根据给定的全类名(如：java.lang.Object)来装载class文件到运行时区域中的方法区。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Execution engine(执行引擎)：执行class中的指令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>存储高性能</title>
    <link href="http://yoursite.com/2020/05/30/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84--%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E3%80%8A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84%E3%80%8B%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/05/30/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84--%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E3%80%8A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84%E3%80%8B%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2020-06-18T00:01:07.887Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h4><ul><li>读写分离（减轻访问压力）</li></ul><p>基本原理：将数据库读写操作分散到不同节点上，减小单个数据库的访问压力，提高访问效率。</p><a id="more"></a><p>基本实现：</p><p>数据库服务器搭建主从集群，一主一从或者一主多从。<br>数据库主机负责读写操作，从机负责读操作。<br>数据库主机通过复制将数据同步到从机。<br>业务服务器将读写发送到主机，将读发送到从机。<br>事务问题：<strong>一致性</strong>。</p><p>【问题】</p><p>如何保证主机和从机的数据一致？？？主从复制的延迟性问题。</p><ul><li>二次读取，读完从机再读一次主机</li><li>关键业务指向主机，非关键业务指向从机</li><li>分库分表（减轻存储压力）</li></ul><p><strong>分库</strong></p><p>将业务模块分到不同数据库服务器里。比如电商项目中用户，商品，订单就可以防在三台不同的服务器上。</p><p>【问题】</p><ul><li><p>join操作问题</p></li><li><p>无法实现关联查询</p></li><li><p>事务问题</p></li></ul><p>数据需要保持一致。比如订单加1商品数量就会减1。（延迟性问题）</p><ul><li>成本</li></ul><p><strong>分表</strong></p><p>单表数据拆分有水平拆分和垂直拆分两种。</p><p>拆分后可以放在同一数据库中，也可以放在不同数据库中。</p><ul><li>垂直分表</li></ul><p>将表中不常用的列拆分出去。会带来表数量增加的复杂性。但能显著提高查询效率。</p><ul><li>水平分表</li></ul><p>水平分表适合表行数特别大的表。</p><pre><code>水平分表的问题</code></pre><ul><li><p>路由：根据什么条件拆分表</p><ul><li><p>范围路由：根据有序的数据列作为路由拆分条件，比如1-999999，1000000-1999999.</p><p>  建议段大小在100万到2000万之间</p><p>  优缺点：分段大小选取具有复杂性；但可以随着数据增加平滑扩展新的表</p></li><li><p>Hash路由</p></li><li><p>配置路由</p></li></ul></li></ul><ul><li><p>join操作需要合并结果</p></li><li><p>order by 操作无法在数据库中进行，只能通过业务代码或者数据库中间件分别查询，然后汇总排序</p></li></ul><h4 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h4><p>NoSQL分类：</p><ul><li>K-V存储：Redis</li><li>文档数据库：MongoDB</li><li>列式数据库：HBase</li><li>全文搜索引擎：ElasticSearch<h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5>基本原理：将可能会重用的数据放在内存中，一次生成，多次使用。</li></ul><p>【一个明星发一条微博，执行一个insert，然后n多个select】</p><ul><li>缓存穿透</li></ul><p>缓存没有发挥作用，业务系统向缓存中读取，但并没有数据。</p><p>问题：</p><p>存储数据不存在<br>缓存需要时间较长</p><ul><li>缓存雪崩</li></ul><p>当缓存失效后系统性能急剧下降。很多请求访问数据库，同时生成缓存。</p><p>解决方案：</p><p>更新锁，只能有一个线程生成缓存。（分布式锁）<br>后台更新。不用业务线程更新，而是用后台线程专门更新。</p><ul><li>缓存热点</li></ul><p>复制多份缓存，创建缓存服务器集群，将请求分发到不同服务器上。</p><p>【比如新浪微博上粉丝超过100w的明星发的微博，生成100份缓存（当然需要100台服务器）】</p><h3 id="第五章-计算高性能"><a href="#第五章-计算高性能" class="headerlink" title="第五章 计算高性能"></a>第五章 计算高性能</h3><p>从物理层面上来说：</p><ul><li>尽量提升单服务器的性能，将资源发挥到极致</li><li>单服务器达到性能瓶颈，设计服务器集群方案</li></ul><h4 id="集群高性能"><a href="#集群高性能" class="headerlink" title="集群高性能"></a>集群高性能</h4><p>负载均衡代替前面的任务分配。</p><h4 id="负载均衡分类"><a href="#负载均衡分类" class="headerlink" title="负载均衡分类"></a>负载均衡分类</h4><ul><li><p>DNS负载均衡（实现地理级别的负载均衡）</p></li><li><p>硬件负载均衡（类似路由交换机）100w以上的并发，就是贵，好一点的就是一台宝马了。</p></li><li><p>软件负载均衡（Nginx&amp;&amp;LVS)</p><h5 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h5></li><li><p>轮询</p></li><li><p>加权轮询</p></li><li><p>负载最低优先<br>Hash类（根据关键信息进行Hash运算，将相同Hash值的请求分发到同一台服务器山）</p><h3 id="第六章-分布式系统设计理论CAP"><a href="#第六章-分布式系统设计理论CAP" class="headerlink" title="第六章 分布式系统设计理论CAP"></a>第六章 分布式系统设计理论CAP</h3><p>对于分布式计算系统，只能满足一致性，可用性，分区容错性三个中的两个。</p></li></ul><p>三进二</p><ul><li>一致性</li></ul><p>所有节点在同一时刻都能看到相同的数据。（比如MySQL集群主从数据一致性）</p><ul><li>可用性</li></ul><p>非故障节点在合理时间返回合理响应。（不能是错误或者超时的响应）</p><ul><li>分区容错性</li></ul><p>当出现网络分区后（网络故障，丢包网络中断），系统可以继续运行。</p><h4 id="CAP细节"><a href="#CAP细节" class="headerlink" title="CAP细节"></a>CAP细节</h4><ul><li>CAP粒度是数据，而不是系统</li></ul><p>比如用户账号数据选择CP，而其他信息选择AP</p><ul><li>正常情况下，可以同时满足CA</li></ul><p>当发生了分区情况，也就是网络故障，才会存在CA的选择，在网络正常的情况下，CA可以同时满足。</p><h4 id="ACID："><a href="#ACID：" class="headerlink" title="ACID："></a>ACID：</h4><p>关于数据库事务完整性的理论</p><p>原子性：单个事务要么都完成，要么都失败（比如银行转账，一个减，一个加，必须同步）<br>一致性：并发请求下数据保持一致<br>隔离性：防止多个事务并发交叉执行导致的数据不一致问题。（悲观锁和乐观锁实现）<br>持久性：事务结束后，对数据的修改就是永久的，即使系统故障也不会丢失。</p><h4 id="BASE"><a href="#BASE" class="headerlink" title="BASE:"></a>BASE:</h4><p>如果无法达到强一致性，那就最终一致性</p><ul><li>Basically Availible 基本可用</li></ul><p>分布式系统故障时，保证核心功能可用（保持登录可用，损失注册）</p><ul><li>Soft Status 软状态</li></ul><p>数据不一致</p><ul><li>Eventually Consistency 最终一致性</li></ul><p>BASE理论是AP方案的延申。</p><h3 id="第七章-存储高可用"><a href="#第七章-存储高可用" class="headerlink" title="第七章 存储高可用"></a>第七章 存储高可用</h3><h4 id="主备复制"><a href="#主备复制" class="headerlink" title="主备复制"></a>主备复制</h4><ul><li>主机存储数据，将数据复制给备机</li><li>备机不提供读写服务</li><li>主机发生故障需要人工干预将备机升为主机<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4></li><li>主机存储数据，将数据复制给备机</li><li>备机提供读服务</li><li>主机故障可以进行读业务，发挥了备机的性能</li><li>主从复制比主备复制复杂，主要体现在客户端需要识别主从关系</li><li>适用写少读多的系统（论坛，新闻网站）<h4 id="主备倒换和主从倒换"><a href="#主备倒换和主从倒换" class="headerlink" title="主备倒换和主从倒换"></a>主备倒换和主从倒换</h4></li><li>主备复制和主从复制的共性问题是主机故障，无法进行写操作。</li></ul><p>主备倒换和主从倒换在原有基础上增加角色倒换的功能。</p><ul><li>互连式：主备机间建立状态传递的通道。</li></ul><p>通道可以是网络连接，也可以是串口连接。</p><ul><li>中介式</li></ul><p>主备机不进行直接连接，而是通过中介传递信息。（需要中介高可用）</p><p>Zookeeper仲裁节点设置节点级别。</p><ul><li>模拟式</li></ul><p>将备机模拟成客户端，模拟读写操作。</p><h4 id="主主复制"><a href="#主主复制" class="headerlink" title="主主复制"></a>主主复制</h4><ul><li>两台主机都有数据，通过复制通道同步</li><li>一致性问题很大</li><li>适合临时性，可丢失，可覆盖的场景<h4 id="数据分散集群"><a href="#数据分散集群" class="headerlink" title="数据分散集群"></a>数据分散集群</h4>数据分散集群指多个服务器组成一个集群，每台服务器都会存储一部分数据，同时，每台服务器会备份一部分数据。（分库分表）</li></ul><h4 id="分布式事务算法：保持一致性"><a href="#分布式事务算法：保持一致性" class="headerlink" title="分布式事务算法：保持一致性"></a>分布式事务算法：保持一致性</h4><h5 id="2PC-二阶段提交"><a href="#2PC-二阶段提交" class="headerlink" title="2PC 二阶段提交"></a>2PC 二阶段提交</h5><ul><li><p>第一阶段：协调者向所有参与者发送请求（投票阶段）（任一参与者否定都可终止提交）</p></li><li><p>第二阶段：参与者全部通过请求，协调者提交请求。<br>问题：</p></li><li><p>同步阻塞：协调者和参与者互相等待</p></li><li><p>协调者单点故障</p><h5 id="3PC-三阶段提交"><a href="#3PC-三阶段提交" class="headerlink" title="3PC 三阶段提交"></a>3PC 三阶段提交</h5></li><li><p>第一阶段：协调者向所有参与者发送请求（投票阶段），参与者有否定则事务中止，在超时时间内收到所有yes则进入第二阶段。</p></li><li><p>第二阶段：协调者发送预提交给参与者，参与者收到信息执行事务操作，返回ACK消息。</p></li><li><p>第三阶段：协调者收到所有的ACK消息后发送执行提交。参与者执行提交后返回已提交消息给协调者。<br>分布式一致性算法</p></li><li><p>Paxos（纯理论）</p></li></ul><p>特别复杂</p><p>多数一致性<br>读操作也会将算法完全执行一遍</p><ul><li>Raft</li></ul><p>Leader选举<br>日志复制<br>安全保证</p><ul><li>ZAB</li></ul><p>Zookeeper采用的分布式一致性算法</p><h3 id="第八章-计算高可用"><a href="#第八章-计算高可用" class="headerlink" title="第八章 计算高可用"></a>第八章 计算高可用</h3><p>当部分硬件损坏时，计算任务可以正常运行。</p><p>基本思想：通过增加更多的服务器达到计算高可用。</p><h4 id="主备"><a href="#主备" class="headerlink" title="主备"></a>主备</h4><ul><li><p>主机执行所有的计算任务</p></li><li><p>当主机损坏且无法恢复时，需要人工将备机升至主机，并且增加新的备机</p></li><li><p>冷备：程序包和配置文件准备好，启动服务器，但业务不启动；温备：业务已启动，但不对外提供服务</p></li><li><p>适用内部管理系统，后台管理系统的等使用人数不多的情况</p></li></ul><h4 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h4><ul><li>主机执行部分任务，备机执行部分任务</li><li>主机故障，任务分发不变，即使主机无法正常运作</li><li>需要人工将备机升为主机，并添加新的备机</li></ul><h4 id="对称集群（负载均衡集群）"><a href="#对称集群（负载均衡集群）" class="headerlink" title="对称集群（负载均衡集群）"></a>对称集群（负载均衡集群）</h4><ul><li><p>正常情况下，任务分配器将任务分配给不同的主机</p></li><li><p>当某台服务器故障后，任务分配器将跳过该台服务器</p></li><li><p>当故障服务器恢复后，重新分配任务</p><h4 id="非对称集群"><a href="#非对称集群" class="headerlink" title="非对称集群"></a>非对称集群</h4><p>Master-Slave</p></li><li><p>集群通过某种方式区分服务器角色，选出Master服务器</p></li><li><p>当Master服务器故障后，推选出新的Master服务器</p></li><li><p>Zookeeper通过ZAB协议选取Master</p></li></ul><h3 id="第九章-业务高可用"><a href="#第九章-业务高可用" class="headerlink" title="第九章 业务高可用"></a>第九章 业务高可用</h3><p>异地多活<br>机房断电，机房火灾，城市地震…（但是鸡蛋也不是那么容易碎的）（不要把鸡蛋放在一个篮子里）</p><p>同城异区<br>跨城异地<br>跨国异地</p><h4 id="异地多活设计技巧"><a href="#异地多活设计技巧" class="headerlink" title="异地多活设计技巧"></a>异地多活设计技巧</h4><ul><li>保证核心业务的异地多活</li><li>核心数据最终一致（异地多活不可能很快）</li><li>采用多种手段同步数据<ul><li>消息队列</li><li>二次读取<ul><li>回源读取等等<br>保证大部分地区的异地多活（无法达到100%）<h4 id="异地多活设计步骤"><a href="#异地多活设计步骤" class="headerlink" title="异地多活设计步骤"></a>异地多活设计步骤</h4></li></ul></li></ul></li><li>业务分级（挑选核心业务）</li><li>数据分类（数据量，唯一性，实时性，可恢复性）</li><li>数据同步（存储系统同步，消息队列同步等等）</li><li>异常处理（多通道同步，同步和访问结合，日志记录，用户补偿）<h4 id="接口级故障应对方案"><a href="#接口级故障应对方案" class="headerlink" title="接口级故障应对方案"></a>接口级故障应对方案</h4>相对与概率小的机房火灾，断电等故障，接口故障发生的情况更多。</li></ul><p>接口级故障：</p><ul><li>内部：程序问题，计算机性能到达极限，导致数据库慢查询</li><li>外部：黑客攻击，促销抢购导致用户访问量突增，第三方响应缓慢等</li></ul><h4 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h4><p>降级是着眼与整个系统的高可用，丢车保帅的一种行为。</p><p>比如论坛的系统接近负载，暂停发帖子功能，只能看帖子。</p><p>（如果系统持续负载，服务器崩溃，看帖子的功能也废了）</p><h4 id="熔断："><a href="#熔断：" class="headerlink" title="熔断："></a>熔断：</h4><p>是降级的一种情况。换句话说，熔断会导致降级。</p><p>熔断是指请求达到一个阈值，暂停该服务的调用，防止系统负载过大，导致崩溃。</p><h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><p>只让一部分访问通过。保证一部分响应优于全部不能响应。</p><ul><li>基于请求限流（控制阈值）</li><li>基于资源限流（对关键资源限流，比如线程池最大并发量）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;关系数据库&quot;&gt;&lt;a href=&quot;#关系数据库&quot; class=&quot;headerlink&quot; title=&quot;关系数据库&quot;&gt;&lt;/a&gt;关系数据库&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;读写分离（减轻访问压力）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本原理：将数据库读写操作分散到不同节点上，减小单个数据库的访问压力，提高访问效率。&lt;/p&gt;
    
    </summary>
    
    
      <category term="架构--阅读笔记" scheme="http://yoursite.com/categories/%E6%9E%B6%E6%9E%84-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>架构基础</title>
    <link href="http://yoursite.com/2020/05/30/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84--%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/05/30/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84--%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E7%A1%80/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2021-01-29T08:56:12.576Z</updated>
    
    <content type="html"><![CDATA[<h4 id="模块与组件"><a href="#模块与组件" class="headerlink" title="模块与组件"></a>模块与组件</h4><p>模块：从逻辑角度拆分，主要目的是职责分离</p><p>组件：从物理角度拆分，主要目的是单元复用</p><a id="more"></a><h4 id="框架与架构"><a href="#框架与架构" class="headerlink" title="框架与架构"></a>框架与架构</h4><p>框架：组件规范（开发规范），提供基础功能的产品。</p><p>架构：对软件系统结构的描述</p><h4 id="架构设计的目的是什么？"><a href="#架构设计的目的是什么？" class="headerlink" title="架构设计的目的是什么？"></a>架构设计的目的是什么？</h4><p>软件架构的历史</p><ul><li><p>第一次软件危机——结构化程序设计登场<br>2000名程序员历时一年，花费原子弹1/4的投入，生产100w行代码。最终以失败告终。</p></li><li><p>第二次软件危机——面对对象</p></li></ul><p>软件扩展能力不足，生产力跟不上硬件和业务的发展。</p><p>软件架构</p><ul><li>随着软件系统规模增加，当系统由许多部分组成时，整个系统的组织，导致了一系列的新的设计问题。</li></ul><p><strong>只有规模较大的软件系统会面临软件架构的问题</strong></p><ol><li>系统规模庞大，内部耦合严重</li><li>修改和扩展困难</li><li>逻辑复杂，问题难以排查和修复</li></ol><p>【人力总会有局限，当自身的能力不足以应对问题时，除了学习之外，也应该思考是否不是自己的问题，而是问题本身超过了人类的局限】</p><h4 id="架构设计的目的"><a href="#架构设计的目的" class="headerlink" title="架构设计的目的"></a>架构设计的目的</h4><p>整个软件开发的历史，就是一部与复杂度斗争的历史。</p><p>而架构设计的主要目的就是为了解决复杂度带来的问题。</p><p>复杂度来源</p><ol><li>高性能</li></ol><p>电子管，晶体管到集成电路，复杂度难以估量。但这种复杂度在选择方面几乎不用考虑，因为没有人会去选择购买电子管计算机。</p><p>但是对于不同的出行方式，自行车，公交，火车，高铁，飞机，出行前我们都会根据距离，费用等略作判断。时代的背景下，飞机的出现并没有取代火车，自行车等工具，但从现代计算机的应用来说，电子管已经被淘汰了。</p><p>而软件架构就是在一次旅行中，选择最高性价比的方案。</p><p>在软件系统中，对高性能需求的复杂度体现在<strong>单台计算机为了高性能带来的复杂度和多台计算机集群为了高性能带来的复杂度</strong>。</p><ul><li>单机复杂度</li></ul><p>操作系统的多进程，多线程，进程通信，多线程并发等等。</p><p>Redis采用单进程，Nginx可以用多进程。具体使用需要结合业务来分析。</p><ul><li><p>集群复杂度</p><ul><li>任务分配：使用多台机器，每台机器都可以处理完整的业务，但会设计到任务分配器，比如硬件F5，软件Nginx等等。</li></ul><p>  <strong>随着机器增多，任务分配器的任务就会加重，成为新的性能瓶颈</strong>。这个时候就需要集群式的任务分配器。</p><ul><li><p>任务分解：将系统拆分成更小的组成部分，部署到不同的服务器中</p><p>任务分配可以突破单台计算机的瓶颈，但持续的增加机器的效率会越来越低。</p><p>任务分解换了一种思路，将系统分解，有针对的扩展。</p></li></ul><p>  <strong>优点：</strong></p><p>  简单系统更加容易有针对性的优化，排错<br>  可以对单个部分进行扩展，有的放矢</p><p>  <strong>问题:</strong></p><p>  系统间调用资源消耗</p><p>  <strong>总结：</strong></p><p>  任务分解和任务分配一样，有一个度，超过这个度，性能反而下降。</p></li></ul><ol start="2"><li>高可用：系统无中断的执行功能</li></ol><p>本质上通过冗余来实现高可用。</p><p>冗余：就好像买电瓶车，一次买十辆，第一辆被偷了骑第二辆，第二辆被偷了骑第三辆，依次类推。</p><pre><code>- 计算高可用集群配置，同时有任务分配的瓶颈- 存储高可用存储集群。但会产生数据传输的一致性问题。</code></pre><p>可扩展（靠经验）</p><p>预测变化<br>应对变化</p><ol start="3"><li>低成本</li></ol><p>低成本和高可用，高性能是冲突的。</p><p>引入新技术，创造新技术。</p><ol start="4"><li>安全</li></ol><h3 id="第二章-架构设计原则"><a href="#第二章-架构设计原则" class="headerlink" title="第二章 架构设计原则"></a>第二章 架构设计原则</h3><p>架构与编程的鸿沟：不确定性。</p><p>编程是确定的，不管采用何种方式，执行结果都是肯定的。</p><p>而不同的架构可能会产生相同的结果。</p><h4 id="合适原则"><a href="#合适原则" class="headerlink" title="合适原则"></a>合适原则</h4><p>合适优于业界领先。</p><p>优秀的架构都是在企业当前人力，条件，业务等各种约束下设计出来的。（生搬硬套不可取）</p><h4 id="简单原则"><a href="#简单原则" class="headerlink" title="简单原则"></a>简单原则</h4><p>简单优于复杂。</p><p>长城的宏伟，悉尼歌剧院的艺术感，”复杂“在制造领域代表先进，在建筑领域代表领先，但在软件领域代表问题。</p><p>为什么软件的复杂会带来问题？？？</p><p>除了软件开发的复杂性之外，软件在投入使用后，需要不断变化。没听说过长城不断拆了重建吧。</p><h4 id="演化原则"><a href="#演化原则" class="headerlink" title="演化原则"></a>演化原则</h4><p>演化优于一步到位。</p><p>对于建筑来说，永恒是主题；而对于软件来说，变化才是主题。</p><p>软件架构更像是一个人类的进化史：</p><p>首先，需要适应环境活下来（突然想到了初中历史书上的山顶洞人）恶劣的环境需要大量的体毛来保持身体的恒温</p><p>在不断的发展中，开始制造工具，开始生火抵抗寒冷</p><p>再到后来，建房子，用动物皮毛保暖</p><p>于是体毛渐渐退化，也不再吃生肉</p><p>生存的方式也从打猎变成更加细分的职业</p><p>到如今的互联网商业繁荣，大脑思考更加复杂的软件架构</p><p>类比软件架构：</p><ul><li><p>首先，设计出来的产品可以满足当前业务需要</p></li><li><p>之后在实际的应用中迭代，保留优秀设计，剔除无用设计，增加必要设计</p></li><li><p>最好，当业务发生巨大改变，性能要求更高时，架构要面临扩展，重构；甚至代码语言会发生变化，但在演变过程中的经验，逻辑，设计等会在新的架构中延续。（设计模式强推）</p></li></ul><p><strong>不要贪大求全，不要盲目照搬大公司的架构</strong></p><h3 id="第三章-架构设计流程"><a href="#第三章-架构设计流程" class="headerlink" title="第三章 架构设计流程"></a>第三章 架构设计流程</h3><h4 id="识别复杂度——有针对性"><a href="#识别复杂度——有针对性" class="headerlink" title="识别复杂度——有针对性"></a>识别复杂度——有针对性</h4><ul><li>分析业务逻辑的复杂性</li><li>是否有做高性能高可用的成本<br>优先解决最主要的复杂度问题。</li></ul><h4 id="使用成熟技术——设计备选方案"><a href="#使用成熟技术——设计备选方案" class="headerlink" title="使用成熟技术——设计备选方案"></a>使用成熟技术——设计备选方案</h4><ul><li><p>备选方案以3-5个为最佳</p></li><li><p>备选方案差异要比较明显（比如主备方案和集群方案）</p></li><li><p>备选方案的技术不要局限已经熟悉的技术（如果你有一把锤子，那么所有的问题都是钉子）</p></li><li><p>备选方案不用过于详细（关注技术选型，而不是技术细节）</p></li></ul><h4 id="深思熟虑——评估备选方案"><a href="#深思熟虑——评估备选方案" class="headerlink" title="深思熟虑——评估备选方案"></a>深思熟虑——评估备选方案</h4><p>性能<br>复杂度和开发时间<br>成本<br>扩展</p><h4 id="精雕细琢——详细方案设计"><a href="#精雕细琢——详细方案设计" class="headerlink" title="精雕细琢——详细方案设计"></a>精雕细琢——详细方案设计</h4><p>Nginx负载均衡策略的算法选择</p><ul><li>轮询</li><li>加权轮询</li><li>ip_hash</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;模块与组件&quot;&gt;&lt;a href=&quot;#模块与组件&quot; class=&quot;headerlink&quot; title=&quot;模块与组件&quot;&gt;&lt;/a&gt;模块与组件&lt;/h4&gt;&lt;p&gt;模块：从逻辑角度拆分，主要目的是职责分离&lt;/p&gt;
&lt;p&gt;组件：从物理角度拆分，主要目的是单元复用&lt;/p&gt;
    
    </summary>
    
    
      <category term="架构--阅读笔记" scheme="http://yoursite.com/categories/%E6%9E%B6%E6%9E%84-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>力扣</title>
    <link href="http://yoursite.com/2020/05/30/%E5%88%B7%E9%A2%98/%E5%8A%9B%E6%89%A3/"/>
    <id>http://yoursite.com/2020/05/30/%E5%88%B7%E9%A2%98/%E5%8A%9B%E6%89%A3/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2020-06-08T00:54:29.910Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题-08-11-硬币凑整"><a href="#面试题-08-11-硬币凑整" class="headerlink" title="面试题 08.11. 硬币凑整"></a>面试题 08.11. 硬币凑整</h2><p>给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p><a id="more"></a><blockquote><p>  示例1:</p><p>  输入: n = 5 </p><p>  输出：2 </p><p>  解释: 有两种方式可以凑成总金额: 5=5 5=1+1+1+1+1</p><p>  示例2:</p><p>  输入: n = 10 </p><p>  输出：4 </p><p>  解释: 有四种方式可以凑成总金额: 10=10 10=5+5 10=5+1+1+1+1+1 10=1+1+1+1+1+1+1+1+1+1</p><p>  说明：</p><p>  你可以假设：0 &lt;= n (总金额) &lt;= 1000000</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;       </span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];      </span><br><span class="line">        <span class="keyword">int</span>[] coins = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>&#125;;</span><br><span class="line">        <span class="comment">//刚好可以用一个硬币凑成的情况，是一种情况</span></span><br><span class="line">        <span class="comment">// while i == coin :</span></span><br><span class="line">        <span class="comment">//dp[i] = dp[i - coin] =&gt; dp[0]</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * dp方程：dp[i] += dp[i - coin];</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = coin; i &lt;= n; i++) &#123;</span><br><span class="line">                dp[i] = (dp[i] + dp[i - coin]) % <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题51-数组中的逆序对"><a href="#面试题51-数组中的逆序对" class="headerlink" title="面试题51. 数组中的逆序对"></a>面试题51. 数组中的逆序对</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><blockquote><p>  示例 1:</p><p>  输入: [7,5,6,4]</p><p>  输出: 5</p><p>  限制：0 &lt;= 数组长度 &lt;= 50000</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> merge(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> count = merge(arr, start, mid) + merge(arr, mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = start, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= end) &#123;</span><br><span class="line">            count += arr[i] &lt;= arr[j] ? j - (mid + <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">            temp[k++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            count += j - (mid + <span class="number">1</span>);</span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= end)&#123;</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        &#125;  </span><br><span class="line">        System.arraycopy(temp, <span class="number">0</span>, arr, start, end - start + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h2><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><blockquote><p>  示例 1:</p><p>  输入: “abcabcbb”</p><p>  输出: 3 </p><p>  解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><p>  示例 2:</p><p>  输入: “bbbbb”</p><p>  输出: 1</p><p>  解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p><p>  示例 3:</p><p>  输入: “pwwkew”</p><p>  输出: 3</p><p>  解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。</p><p>  请注意，你的答案必须是 <code>子串</code> 的长度，”pwke” 是一个子序列，不是子串。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="comment">//记录最大长度</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录最左开始字母下标</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                <span class="comment">//更新最左开始字母下标</span></span><br><span class="line">                left = Math.max(left,map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(i),i);</span><br><span class="line">            max = Math.max(max,i-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h2><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。</p><p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p><blockquote><p>  示例 1:</p><p>  nums1 = [1, 3]</p><p>  nums2 = [2]</p><p>  则中位数是 2.0</p><p>  示例 2:</p><p>  nums1 = [1, 2]</p><p>  nums2 = [3, 4]</p><p>  则中位数是 (2 + 3)/2 = 2.5</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="comment">//分配新数组</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[m + n];</span><br><span class="line">        <span class="comment">//nums1为空</span></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//判断奇偶性，分类求中位数</span></span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> (nums2[n / <span class="number">2</span> - <span class="number">1</span>] + nums2[n / <span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[n / <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//nums2为空</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//判断奇偶性，分类求中位数</span></span><br><span class="line">            <span class="keyword">if</span> (m % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> (nums1[m / <span class="number">2</span> - <span class="number">1</span>] + nums1[m / <span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[m / <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新数组指针</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//nums1和nums2的指针</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历复制</span></span><br><span class="line">        <span class="keyword">while</span> (count != (m + n)) &#123;</span><br><span class="line">            <span class="comment">//nums1数组遍历完，直接复制nums2数组</span></span><br><span class="line">            <span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">                <span class="keyword">while</span> (j != n) &#123;</span><br><span class="line">                    nums[count++] = nums2[j++];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//nums2数组遍历完，直接复制nums1数组</span></span><br><span class="line">            <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">                <span class="keyword">while</span> (i != m) &#123;</span><br><span class="line">                    nums[count++] = nums1[i++];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//选择nums1中和nums2中小的加入</span></span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">                nums[count++] = nums1[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[count++] = nums2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回中位数</span></span><br><span class="line">        <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (nums[count / <span class="number">2</span> - <span class="number">1</span>] + nums[count / <span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[count / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><blockquote><p>  示例 1：</p><p>  输入: “babad”</p><p>  输出: “bab”</p><p>  注意: “aba” 也是一个有效答案。</p><p>  示例 2：</p><p>  输入: “cbbd”</p><p>  输出: “bb”</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.equals(<span class="string">""</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//字符串s[i⋯j]是否为回文子串，如果是，dp[i][j]=true，如果不是，dp[i][j]=false</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录最长回文字串的左右下标</span></span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化，单个字符都是回文子串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//开始遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; s.length(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    <span class="comment">//考虑“cbba”这种情况</span></span><br><span class="line">                    <span class="keyword">if</span>(j - i == <span class="number">1</span>)&#123;</span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//只要dp[i+1][j-1]是回文子串，那么dp[i][j]也就是回文子串</span></span><br><span class="line">                        dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>]; </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j])&#123;</span><br><span class="line">                    <span class="comment">//找到更长字串，则更新</span></span><br><span class="line">                    <span class="keyword">if</span>(max - min &lt;= j - i)&#123;</span><br><span class="line">                        min = i;</span><br><span class="line">                        max = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(min, max + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h2><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfa9qwtom2j30m90anwep.jpg" alt="img"></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><blockquote><p>  说明：你不能倾斜容器，且 n 的值至少为 2。</p><p>  示例：</p><p>  输入：[1,8,6,2,5,4,8,3,7]</p><p>  输出：49</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在每一个状态下，无论长板或短板收窄1格，都会导致水槽底边宽度−1：</span></span><br><span class="line"><span class="comment">若向内移动短板，水槽的短板 min(h[i], h[j])min(h[i],h[j]) 可能变大，因此水槽面积 S(i, j)S(i,j) 可能增大。</span></span><br><span class="line"><span class="comment">若向内移动长板，水槽的短板 min(h[i], h[j])min(h[i],h[j]) 不变或变小，下个水槽的面积一定小于当前水槽面积。</span></span><br><span class="line"><span class="comment">因此，向内收窄短板可以获取面积最大值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, j = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i] &lt;= height[j])&#123;</span><br><span class="line">                res = Math.max(res, height[i] * (j - i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res = Math.max(res, height[j] * (j - i));</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23-合并K个排序链表"><a href="#23-合并K个排序链表" class="headerlink" title="23. 合并K个排序链表"></a>23. 合并K个排序链表</h2><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><blockquote><p>  示例:</p><p>  输入:<br>  [<br>    1-&gt;4-&gt;5,<br>    1-&gt;3-&gt;4,<br>    2-&gt;6<br>  ]</p><p>  输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p></blockquote><p><strong>利用堆做排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists==<span class="keyword">null</span> || lists.length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个堆，并设置元素的排序方式</span></span><br><span class="line">        PriorityQueue&lt;ListNode&gt; queue = <span class="keyword">new</span> PriorityQueue(<span class="keyword">new</span> Comparator&lt;ListNode&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode o1, ListNode o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (o1.val - o2.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历链表数组，然后将每个链表的每个节点都放入堆中</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lists.length; i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(lists[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">queue.add(lists[i]);</span><br><span class="line">lists[i] = lists[i].next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;   </span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode head = dummy;</span><br><span class="line">        <span class="comment">//从堆中不断取出元素，并将取出的元素串联起来</span></span><br><span class="line">        <span class="keyword">while</span>( !queue.isEmpty() ) &#123;</span><br><span class="line">            dummy.next = queue.poll();</span><br><span class="line">            dummy = dummy.next;</span><br><span class="line">        &#125;</span><br><span class="line">        dummy.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>堆排序优化</strong></p><p>我们建立完k个大小的堆后，就不断的从堆中获取节点，如果获取到的节点不为空，即还有下一个节点，那么就将下一个节点放到堆中。利用这个特点我们就可以优化空间了，将原先的O(N)的空间复杂度优化到O(k)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists==<span class="keyword">null</span> || lists.length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个小根堆，并定义好排序函数</span></span><br><span class="line">        PriorityQueue&lt;ListNode&gt; queue = <span class="keyword">new</span> PriorityQueue(<span class="keyword">new</span> Comparator&lt;ListNode&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode o1, ListNode o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (o1.val - o2.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="comment">//这里跟上一版不一样，不再是一股脑全部放到堆中</span></span><br><span class="line">        <span class="comment">//而是只把k个链表的第一个节点放入到堆中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">            ListNode head = lists[i];</span><br><span class="line">            <span class="keyword">if</span>(head!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(head);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//之后不断从堆中取出节点，如果这个节点还有下一个节点，</span></span><br><span class="line">        <span class="comment">//就将下个节点也放入堆中</span></span><br><span class="line">        <span class="keyword">while</span>(queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ListNode node = queue.poll();</span><br><span class="line">            cur.next = node;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="keyword">if</span>(node.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>两两合并</strong></p><p>对于这四个链表，我们先合并A1和A2，将这两个链表变成A1-A2，然后再按照两两合并的方式，合并A1-A2和A3，这三个链表就合并成了A1-A2-A3，最后将A1-A2-A3跟A4两两合并，四个链表就合并完了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists==<span class="keyword">null</span> || lists.length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将lists[0]作为最终合并的链表，然后将list[0]和lists[1]合并成lists[0-1]</span></span><br><span class="line">        <span class="comment">//再将lists[0-1]和lists[2]合并，如此反复最终lists[0]就是最终结果</span></span><br><span class="line">        ListNode res = lists[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;lists.length;i++) &#123;</span><br><span class="line">            res = merge(res,lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并两个有序链表</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode a, ListNode b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="keyword">null</span> || b==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (a==<span class="keyword">null</span>) ? b : a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a.val&lt;=b.val) &#123;</span><br><span class="line">            a.next = merge(a.next,b);</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            b.next = merge(a,b.next);</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><blockquote><p>  示例 1:</p><p>  输入: [1,3,5,6], 5</p><p>  输出: 2</p><p>  示例 2:</p><p>  输入: [1,3,5,6], 2</p><p>  输出: 1</p><p>  示例 3:</p><p>  输入: [1,3,5,6], 7</p><p>  输出: 4</p><p>  示例 4:</p><p>  输入: [1,3,5,6], 0</p><p>  输出: 0</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//下标小于low的值都小于target</span></span><br><span class="line">        <span class="keyword">int</span> low = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//下标大于high的值都大于target</span></span><br><span class="line">        <span class="keyword">int</span> high = nums.length;</span><br><span class="line">        <span class="comment">//当low和high之间有值时不断循环</span></span><br><span class="line">        <span class="keyword">while</span>(low + <span class="number">1</span> &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target)&#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h2><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><blockquote><p>  示例:</p><p>  输入: [1,2,3]</p><p>  输出:<br>  [<br>    [1,2,3],<br>    [1,3,2],<br>    [2,1,3],<br>    [2,3,1],<br>    [3,1,2],<br>    [3,2,1]<br>  ]</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 记录「路径」</span></span><br><span class="line">        LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        backtrack(nums, track);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 路径：记录在 track 中</span></span><br><span class="line">    <span class="comment">// 选择列表：nums 中不存在于 track 的那些元素</span></span><br><span class="line">    <span class="comment">// 结束条件：nums 中的元素全都在 track 中出现</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 触发结束条件</span></span><br><span class="line">        <span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList(track));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 排除不合法的选择</span></span><br><span class="line">            <span class="keyword">if</span> (track.contains(nums[i]))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            <span class="comment">// 进入下一层决策树</span></span><br><span class="line">            backtrack(nums, track);</span><br><span class="line">            <span class="comment">// 取消选择</span></span><br><span class="line">            track.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个位置。</p><blockquote><p>  示例 1:</p><p>  输入: [2,3,1,1,4]</p><p>  输出: true</p><p>  解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p><p>  示例 2:</p><p>  输入: [3,2,1,0,4]</p><p>  输出: false</p><p>  解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//记录当前最大跳跃距离</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//如果当前坐标大于最大跳跃距离，则当前坐标不可达，返回false</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; maxLen)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则更新最大跳跃距离</span></span><br><span class="line">            maxLen = Math.max(maxLen, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a>76. 最小覆盖子串</h2><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p><blockquote><p>  示例：</p><p>  输入: S = “ADOBECODEBANC”, T = “ABC”</p><p>  输出: “BANC”</p><p>  说明：</p><p>  如果 S 中不存这样的子串，则返回空字符串 “”。</p><p>  如果 S 中存在这样的子串，我们保证它是唯一的答案。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s == <span class="string">""</span> || t == <span class="keyword">null</span> || t == <span class="string">""</span> </span><br><span class="line">        || s.length() &lt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用来统计t中每个字符出现次数</span></span><br><span class="line">        <span class="keyword">int</span>[] needs = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用来统计滑动窗口中每个字符出现次数</span></span><br><span class="line">        <span class="keyword">int</span>[] window = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            needs[t.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//滑动窗口左右边界</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//目前有多少个字符</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用来记录最短需要多少个字符。</span></span><br><span class="line">        <span class="keyword">int</span> minLength = s.length() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(right);</span><br><span class="line">            window[ch]++;</span><br><span class="line">            <span class="keyword">if</span> (needs[ch] &gt; <span class="number">0</span> &amp;&amp; needs[ch] &gt;= window[ch]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//移动到不满足条件为止</span></span><br><span class="line">            <span class="keyword">while</span> (count == t.length()) &#123;</span><br><span class="line">                ch = s.charAt(left);</span><br><span class="line">                <span class="keyword">if</span> (needs[ch] &gt; <span class="number">0</span> &amp;&amp; needs[ch] &gt;= window[ch]) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; minLength) &#123;</span><br><span class="line">                    minLength = right - left + <span class="number">1</span>;</span><br><span class="line">                    res = s.substring(left, right + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                window[ch]--;</span><br><span class="line">                left++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a>84. 柱状图中最大的矩形</h2><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfa9z1nt7vj305805o0it.jpg" alt="img"></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfa9y9gpiyj305805ogld.jpg" alt="img"></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p><blockquote><p>  示例:</p><p>  输入: [2,1,5,6,2,3]</p><p>  输出: 10</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过观察，可以发现，最大面积矩形存在于以下几种情况：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.确定了最矮柱子以后，矩形的宽尽可能往两边延伸。</span></span><br><span class="line"><span class="comment">2.在最矮柱子左边的最大面积矩形（子问题）。</span></span><br><span class="line"><span class="comment">3.在最矮柱子右边的最大面积矩形（子问题）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> largestRectangleArea(heights, <span class="number">0</span>, heights.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right == left) &#123;</span><br><span class="line">            <span class="keyword">return</span> heights[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存储最小高度</span></span><br><span class="line">        <span class="keyword">int</span> minHeight = heights[left];</span><br><span class="line">        <span class="comment">//存储最小高度下标</span></span><br><span class="line">        <span class="keyword">int</span> minHeightIndex = left;</span><br><span class="line">        <span class="comment">//遍历找出最小高度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heights[i] &lt; minHeight) &#123;</span><br><span class="line">                minHeight = heights[i];</span><br><span class="line">                minHeightIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归求解最大值</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(</span><br><span class="line">            minHeight * (right - left + <span class="number">1</span>), </span><br><span class="line">            Math.max(largestRectangleArea(heights, left, minHeightIndex - <span class="number">1</span>),                           largestRectangleArea(heights, minHeightIndex + <span class="number">1</span>, right)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p><blockquote><p>  例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><blockquote><p>  但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 2   2</span><br><span class="line">  \   \</span><br><span class="line">  3    3</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isMirrorBTree(root.left, root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isMirrorBTree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == root1 &amp;&amp; <span class="keyword">null</span> == root2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">null</span> == root1 || <span class="keyword">null</span> == root2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1.val != root2.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此处注意相反比较</span></span><br><span class="line">        <span class="keyword">return</span> isMirrorBTree(root1.left,root2.right)</span><br><span class="line">            &amp;&amp; isMirrorBTree(root1.right,root2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h2><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p>注意：你可以假设树中没有重复的元素。</p><blockquote><p>  例如，给出</p><p>  前序遍历 preorder = [3,9,20,15,7]</p><p>  中序遍历 inorder = [9,3,15,20,7]</p><p>  返回如下的二叉树：</p><p>  [3,9,20,15,7]</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.length == <span class="number">0</span> || in.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//前序遍历的第一个节点为根节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++)&#123;</span><br><span class="line">            <span class="comment">//找到中序遍历中根节点的位置</span></span><br><span class="line">            <span class="keyword">if</span>(pre[<span class="number">0</span>] == in[i])&#123;</span><br><span class="line">                root.left = buildTree</span><br><span class="line">                    (Arrays.copyOfRange(pre, <span class="number">1</span>, i+<span class="number">1</span>), </span><br><span class="line">                     Arrays.copyOfRange(in, <span class="number">0</span>, i));</span><br><span class="line">                root.right = buildTree</span><br><span class="line">                    (Arrays.copyOfRange(pre, i+<span class="number">1</span>, pre.length), </span><br><span class="line">                     Arrays.copyOfRange(in, i+<span class="number">1</span>, in.length));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146. LRU缓存机制"></a>146. LRU缓存机制</h2><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><ul><li><p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。</p></li><li><p>写入数据 put(key, value) - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p></li></ul><p>进阶:</p><p>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><blockquote><p>  示例:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache = <span class="keyword">new</span> LRUCache( <span class="number">2</span> <span class="comment">/* 缓存容量 */</span> );</span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// 返回  1</span></span><br><span class="line">cache.put(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// 该操作会使得密钥 2 作废</span></span><br><span class="line">cache.get(<span class="number">2</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.put(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// 该操作会使得密钥 1 作废</span></span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.get(<span class="number">3</span>);       <span class="comment">// 返回  3</span></span><br><span class="line">cache.get(<span class="number">4</span>);       <span class="comment">// 返回  4</span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Node类用于抽象链表的节点</span></span><br><span class="line"><span class="comment">     * key、value存储键、值，</span></span><br><span class="line"><span class="comment">     * before、after分别指向当前节点的前后Node节点；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        Node before;</span><br><span class="line">        Node after;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用HashMap缓存Node节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; cache = <span class="keyword">new</span> HashMap&lt;Integer, Node&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大容量，超过capacity时继续插入会触发删除最老未被使用的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头节点、尾节点（注意这两个节点不存储实际的数据）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head, tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line"></span><br><span class="line">        head = <span class="keyword">new</span> Node();</span><br><span class="line">        head.before = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        tail = <span class="keyword">new</span> Node();</span><br><span class="line">        tail.after = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        head.after = tail;</span><br><span class="line">        tail.before = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        Node node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果获取到数据，则将获取到的节点移动到队列头部;</span></span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将节点移动到有效数据头部</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除队列中的一个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node before = node.before;</span><br><span class="line">        Node after = node.after;</span><br><span class="line">        before.after = after;</span><br><span class="line">        after.before = before;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将节点插入队列头部</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        node.before = head;</span><br><span class="line">        node.after = head.after;</span><br><span class="line">        head.after.before = node;</span><br><span class="line">        head.after = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node();</span><br><span class="line">            newNode.key = key;</span><br><span class="line">            newNode.value = value;</span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            <span class="keyword">if</span> (cache.size() &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 删除队尾有效数据节点</span></span><br><span class="line">                Node tail = <span class="keyword">this</span>.popTail();</span><br><span class="line">                <span class="keyword">this</span>.cache.remove(tail.key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            <span class="comment">// 在使用get方法获取值之后，需要将当前获取的节点移动到队列头部</span></span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除有效数据尾节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 尾节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">popTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node res = tail.before;</span><br><span class="line">        <span class="keyword">this</span>.removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a>152. 乘积最大子数组</h2><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><blockquote><p>  示例 1:</p><p>  输入: [2,3,-2,4]</p><p>  输出: 6</p><p>  解释: 子数组 [2,3] 有最大乘积 6。</p><p>  示例 2:</p><p>  输入: [-2,0,-1]</p><p>  输出: 0</p><p>  解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>], min = nums[<span class="number">0</span>], result = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//由于数组中含有负数，需要同时维护max和min</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = max;</span><br><span class="line">            <span class="comment">//max 取 max * nums[i]、min * nums[i]、nums[i]中的最大值</span></span><br><span class="line">            max = Math.max(Math.max(max * nums[i], min * nums[i]), nums[i]);</span><br><span class="line">            <span class="comment">//min 取 temp * nums[i]、min * nums[i]、nums[i]中的最小值</span></span><br><span class="line">            min = Math.min(Math.min(temp * nums[i], min * nums[i]), nums[i]);</span><br><span class="line">            <span class="comment">//记录最大值</span></span><br><span class="line">            <span class="keyword">if</span> (max &gt; result) result = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. 打家劫舍</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><blockquote><p>  示例 1:</p><p>  输入: [1,2,3,1]</p><p>  输出: 4</p><p>  解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>           偷窃到的最高金额 = 1 + 3 = 4 。</p><p>  示例 2:</p><p>  输入: [2,7,9,3,1]</p><p>  输出: 12</p><p>  解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>           偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="comment">//动态规划方程：dp[n] = MAX( dp[n-1], dp[n-2] + num )</span></span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>] + nums[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a>210. 课程表 II</h2><p>现在你总共有 n 门课需要选，记为 0 到 n-1。在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p><p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p><p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p><blockquote><p>  示例 1:</p><p>  输入: 2, [[1,0]] </p><p>  输出: [0,1]</p><p>  解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</p><p>  示例 2:</p><p>  输入: 4, [[1,0],[2,0],[3,1],[3,2]]</p><p>  输出: [0,1,2,3] or [0,2,1,3]</p><p>  解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="comment">//课程数为0，直接返回空数组</span></span><br><span class="line">        <span class="keyword">if</span> (numCourses == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 建立入度表</span></span><br><span class="line">        <span class="keyword">int</span>[] inDegrees = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="comment">// 对于有先修课的课程，计算有几门先修课</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] p : prerequisites) &#123; </span><br><span class="line">            inDegrees[p[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 入度为0的节点,加入队列，表示可以直接学习</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inDegrees.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegrees[i] == <span class="number">0</span>) queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录学完的课程数量</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录学完的课程</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="comment">// 根据提供的先修课列表，删除入度为0的节点</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//将可以学完的课程加入结果当中</span></span><br><span class="line">            <span class="keyword">int</span> curr = queue.poll();</span><br><span class="line">            res[count++] = curr;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] p : prerequisites) &#123;</span><br><span class="line">                <span class="comment">//将先修课程为curr的节点入度减1</span></span><br><span class="line">                <span class="keyword">if</span> (p[<span class="number">1</span>] == curr)&#123;</span><br><span class="line">                    inDegrees[p[<span class="number">0</span>]]--;</span><br><span class="line">                    <span class="comment">//如果节点入度为0，则加入队列，代表可以直接学习</span></span><br><span class="line">                    <span class="keyword">if</span> (inDegrees[p[<span class="number">0</span>]] == <span class="number">0</span>) queue.offer(p[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果已学习课程数count等于总数numCourses，则返回结果res</span></span><br><span class="line">        <span class="keyword">if</span> (count == numCourses) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//否则返回空数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a>287. 寻找重复数</h2><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><blockquote><p>  示例 1:</p><p>  输入: [1,3,4,2,2]</p><p>  输出: 2</p><p>  示例 2:</p><p>  输入: [3,1,3,4,2]</p><p>  输出: 3</p><p>  说明：</p><ol><li>不能更改原数组（假设数组是只读的）。</li><li>只能使用额外的 O(1) 的空间。</li><li>时间复杂度小于 O(n2) 。</li><li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(nums[i]) == <span class="keyword">null</span>)&#123;</span><br><span class="line">                map.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a>394. 字符串解码</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><blockquote><p>  示例:</p><p>  s = “3[a]2[bc]”, 返回 “aaabcbc”.</p><p>  s = “3[a2[c]]”, 返回 “accaccacc”.</p><p>  s = “2[abc]3[cd]ef”, 返回 “abcabccdcdcdef”.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">① 找到第一对匹配的括号开始和结束的索引位置</span></span><br><span class="line"><span class="comment">② 从"["括号的开始位置向前扫描，找到数字出现的起始坐标</span></span><br><span class="line"><span class="comment">③ 把出现在数字之前的字符复制到StringBuilder中</span></span><br><span class="line"><span class="comment">④ 复制括号中的字符到StringBuilder中</span></span><br><span class="line"><span class="comment">⑤ 复制"]"括号后的字符到StringBuilder中</span></span><br><span class="line"><span class="comment">⑥ s赋值为StringBuilder中的字符串，并将StringBuilder清空，重复上述过程，指导s字符串中找不到括号为止；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (s.contains(<span class="string">"["</span>)) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//记录第一对括号的起始位置和结束位置</span></span><br><span class="line">            <span class="keyword">int</span> startEqual = <span class="number">0</span>, endEqual = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == <span class="string">'['</span>) &#123;</span><br><span class="line">                    startEqual = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == <span class="string">']'</span>) &#123;</span><br><span class="line">                    endEqual = i; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//括号中的字符串sub</span></span><br><span class="line">            String sub = s.substring(startEqual + <span class="number">1</span>, endEqual);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//向前扫描，找到数字开始的位置;</span></span><br><span class="line">            <span class="keyword">int</span> numIndex = startEqual - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (numIndex &gt;= <span class="number">0</span> &amp;&amp; Character.isDigit(s.charAt(numIndex)))&#123;</span><br><span class="line">                numIndex--;</span><br><span class="line">            &#125;                          </span><br><span class="line"></span><br><span class="line">            <span class="comment">//需要重复的次数，求出数字的值</span></span><br><span class="line">            <span class="keyword">int</span> times = Integer.parseInt(s.substring(numIndex + <span class="number">1</span>, startEqual));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将"["括号数字之前的字符添加到sb中</span></span><br><span class="line">            sb.append(s, <span class="number">0</span>, numIndex + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (times-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                sb.append(sub);</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">//将"]"右括号之后的字符添加到sb中</span></span><br><span class="line">            sb.append(s, endEqual + <span class="number">1</span>, s.length());</span><br><span class="line"></span><br><span class="line">            s = sb.toString();</span><br><span class="line">            sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="402-移掉K位数字"><a href="#402-移掉K位数字" class="headerlink" title="402. 移掉K位数字"></a>402. 移掉K位数字</h2><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。</p><p>注意:</p><p>num 的长度小于 10002 且 ≥ k。</p><p>num 不会包含任何前导零。</p><blockquote><p>  示例 1 :</p><p>  输入: num = “1432219”, k = 3</p><p>  输出: “1219”</p><p>  解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。</p><p>  示例 2 :</p><p>  输入: num = “10200”, k = 1</p><p>  输出: “200”</p><p>  解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</p><p>  示例 3 :</p><p>  输入: num = “10”, k = 2</p><p>  输出: “0”</p><p>  解释: 从原数字移除所有的数字，剩余为空就是0。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeKdigits</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num.length() == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder(num);</span><br><span class="line">        <span class="comment">//共删除k次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//找到持续增加的区间最后的数字，也就是最大的数字下标idx</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; s.length() &amp;&amp; s.charAt(j) &gt;= s.charAt(j - <span class="number">1</span>); j++) &#123;</span><br><span class="line">                idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//删除idx</span></span><br><span class="line">            s.delete(idx, idx + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//特殊情况：删除最大数后第一位为0</span></span><br><span class="line">            <span class="keyword">while</span> (s.length() &gt; <span class="number">1</span> &amp;&amp; s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>)&#123;</span><br><span class="line">                s.delete(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="680-验证回文字符串-Ⅱ"><a href="#680-验证回文字符串-Ⅱ" class="headerlink" title="680. 验证回文字符串 Ⅱ"></a>680. 验证回文字符串 Ⅱ</h2><p>给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</p><blockquote><p>  示例 1:</p><p>  输入: “aba”</p><p>  输出: True</p><p>  示例 2:</p><p>  输入: “abca”</p><p>  输出: True</p><p>  解释: 你可以删除c字符。</p><p>  注意:</p><p>  字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将字符串转换为字符数组</span></span><br><span class="line">        array = s.toCharArray();</span><br><span class="line">        <span class="comment">//双指针</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> low = <span class="number">0</span>, high = array.length - <span class="number">1</span>; low &lt; high; low++, high--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (array[low] != array[high])&#123;</span><br><span class="line">                <span class="keyword">return</span> isSub(low + <span class="number">1</span>, high) || isSub(low, high - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这种情况是没有删除字符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSub</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">if</span> (array[low++] != array[high--])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="974-和可被-K-整除的子数组"><a href="#974-和可被-K-整除的子数组" class="headerlink" title="974. 和可被 K 整除的子数组"></a>974. 和可被 K 整除的子数组</h2><p>给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。</p><blockquote><p>  示例：</p><p>  输入：A = [4,5,0,-2,-3,1], K = 5</p><p>  输出：7</p><p>  解释：</p><p>  有 7 个子数组满足其元素之和可被 K = 5 整除：</p><p>  [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]</p><p>  提示：</p><p>  1 &lt;= A.length &lt;= 30000</p><p>  -10000 &lt;= A[i] &lt;= 10000</p><p>  2 &lt;= K &lt;= 10000</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraysDivByK</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.length, sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[K];</span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="comment">//前缀和</span></span><br><span class="line">            sum = sum + A[i-<span class="number">1</span>]; </span><br><span class="line">            <span class="comment">//将key定义为sum[i]%K</span></span><br><span class="line">            <span class="keyword">int</span> key = (sum % K + K) % K;</span><br><span class="line">            ans += map[key];</span><br><span class="line">            map[key]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面试题-08-11-硬币凑整&quot;&gt;&lt;a href=&quot;#面试题-08-11-硬币凑整&quot; class=&quot;headerlink&quot; title=&quot;面试题 08.11. 硬币凑整&quot;&gt;&lt;/a&gt;面试题 08.11. 硬币凑整&lt;/h2&gt;&lt;p&gt;给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://yoursite.com/2020/05/30/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Docker/"/>
    <id>http://yoursite.com/2020/05/30/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Docker/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2021-01-29T08:51:53.892Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  参考文档：<a href="https://snailclimb.gitee.io/javaguide/#/docs/tools/Docker-Image" target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/docs/tools/Docker-Image</a></p></blockquote><h2 id="Docker-下载镜像"><a href="#Docker-下载镜像" class="headerlink" title="Docker 下载镜像"></a>Docker 下载镜像</h2><p>如果我们想要在本地运行容器，就必须保证本地存在对应的镜像。所以，第一步，我们需要下载镜像。当我们尝试下载镜像时，Docker 会尝试先从默认的镜像仓库（默认使用 Docker Hub 公共仓库）去下载，当然了，用户也可以自定义配置想要下载的镜像仓库。</p><a id="more"></a><h3 id="1-1-下载镜像"><a href="#1-1-下载镜像" class="headerlink" title="1.1 下载镜像"></a>1.1 下载镜像</h3><p>镜像是运行容器的前提，我们可以使用 <code>docker pull[IMAGE_NAME]:[TAG]</code>命令来下载镜像，其中 <code>IMAGE_NAME</code> 表示的是镜像的名称，而 <code>TAG</code> 是镜像的标签，也就是说我们需要通过 “<strong>镜像 + 标签</strong>” 的方式来下载镜像。</p><p><strong>注意：</strong> 您也可以不显式地指定 TAG, 它会默认下载 latest 标签，也就是下载仓库中最新版本的镜像。这里并不推荐您下载 latest 标签，因为该镜像的内容会跟踪镜像的最新版本，并随之变化，所以它是不稳定的。在生产环境中，可能会出现莫名其妙的 bug, 推荐您最好还是显示的指定具体的 TAG。</p><p>举个例子，如我们想要下载一个 Mysql 5.7 镜像，可以通过命令来下载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 由于官方 DockerHub 仓库服务器在国外，下载速度较慢</p><h3 id="1-2-验证"><a href="#1-2-验证" class="headerlink" title="1.2 验证"></a>1.2 验证</h3><p>让我们来验证一下，本地是否存在 Mysql5.7 的镜像，运行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>可以看到本地的确存在该镜像，则确实是下载成功了！</p><h3 id="1-3-下载镜像相关细节"><a href="#1-3-下载镜像相关细节" class="headerlink" title="1.3 下载镜像相关细节"></a>1.3 下载镜像相关细节</h3><p>通过下载过程，可以看到，一个镜像一般是由多个层（ <code>layer</code>） 组成，类似 <code>f7e2b70d04ae</code>这样的串表示层的唯一 ID（实际上完整的 ID 包括了 256 个 bit, 64 个十六进制字符组成）。</p><p><strong>您可能会想，如果多个不同的镜像中，同时包含了同一个层（ layer）,这样重复下载，岂不是导致了存储空间的浪费么?</strong></p><p>实际上，Docker 并不会这么傻会去下载重复的层（ <code>layer</code>）,Docker 在下载之前，会去检测本地是否会有同样 ID 的层，如果本地已经存在了，就直接使用本地的就好了。</p><p><strong>另一个问题，不同仓库中，可能也会存在镜像重名的情况发生, 这种情况咋办？</strong></p><p>严格意义上，我们在使用 <code>docker pull</code> 命令时，还需要在镜像前面指定仓库地址( <code>Registry</code>), 如果不指定，则 Docker 会使用您默认配置的仓库地址。例如配置的是国内 <code>docker.io</code> 的仓库地址，我在 <code>pull</code> 的时候，docker 会默认为我加上 <code>docker.io/library</code> 的前缀。</p><p>如：当我执行 <code>docker pull mysql:5.7</code> 命令时，实际上相当于 <code>docker pull docker.io/mysql:5.7</code>，如果您未自定义配置仓库，则默认在下载的时候，会在镜像前面加上 DockerHub 的地址。</p><p>Docker 通过前缀地址的不同，来保证不同仓库中，重名镜像的唯一性。</p><h3 id="1-4-PULL-子命令"><a href="#1-4-PULL-子命令" class="headerlink" title="1.4 PULL 子命令"></a>1.4 PULL 子命令</h3><p>命令行中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull --help</span><br></pre></td></tr></table></figure><p>会得到如下信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">slimshady@MacBook-Pro ~ % docker pull --help</span><br><span class="line"></span><br><span class="line">Usage:docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br><span class="line"></span><br><span class="line">Pull an image or a repository from a registry</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --all-tags                Download all tagged images in the repository</span><br><span class="line">      --disable-content-trust   Skip image verification (default true)</span><br><span class="line">  -q, --quiet                   Suppress verbose output</span><br></pre></td></tr></table></figure><p>我们可以看到主要支持的子命令有：</p><ol><li><code>-a,--all-tags=true|false</code>: 是否获取仓库中所有镜像，默认为否；</li><li><code>--disable-content-trust</code>: 跳过镜像内容的校验，默认为 true;</li></ol><h2 id="查看镜像信息"><a href="#查看镜像信息" class="headerlink" title="查看镜像信息"></a>查看镜像信息</h2><h3 id="2-1-images-命令列出镜像"><a href="#2-1-images-命令列出镜像" class="headerlink" title="2.1 images 命令列出镜像"></a>2.1 images 命令列出镜像</h3><p>通过使用如下两个命令，列出本机已有的镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4sejxos4j31ma054td9.jpg" alt="image-20200525164236760"></p><p>解释：</p><ul><li><strong>REPOSITORY</strong>: 来自于哪个仓库；</li><li><strong>TAG</strong>: 镜像的标签信息，比如 5.7、latest 表示不同的版本信息；</li><li><strong>IMAGE ID</strong>: 镜像的 ID, 如果您看到两个 ID 完全相同，那么实际上，它们指向的是同一个镜像，只是标签名称不同罢了；</li><li><strong>CREATED</strong>: 镜像最后的更新时间；</li><li><strong>SIZE</strong>: 镜像的大小，优秀的镜像一般体积都比较小，这也是我更倾向于使用轻量级的 alpine 版本的原因；</li></ul><blockquote><p>  注意：图中的镜像大小信息只是逻辑上的大小信息，因为一个镜像是由多个镜像层（ <code>layer</code>）组成的，而相同的镜像层本地只会存储一份，所以，真实情况下，占用的物理存储空间大小，可能会小于逻辑大小。</p></blockquote><h3 id="2-2-使用-tag-命令为镜像添加标签"><a href="#2-2-使用-tag-命令为镜像添加标签" class="headerlink" title="2.2 使用 tag 命令为镜像添加标签"></a>2.2 使用 tag 命令为镜像添加标签</h3><p>通常情况下，为了方便在后续工作中，快速地找到某个镜像，我们可以使用 <code>docker tag</code> 命令，为本地镜像添加一个新的标签。<code>docker tag</code> 命令功能更像是, 为指定镜像添加快捷方式一样。</p><p>标签和原镜像的镜像 ID 是一模一样的，说明它们是同一个镜像，只是别名不同而已。</p><h3 id="2-3-使用-inspect-命令查看镜像详细信息"><a href="#2-3-使用-inspect-命令查看镜像详细信息" class="headerlink" title="2.3 使用 inspect 命令查看镜像详细信息"></a>2.3 使用 inspect 命令查看镜像详细信息</h3><p>通过 <code>docker inspect</code> 命令，我们可以获取镜像的详细信息，其中，包括创建者，各层的数字摘要等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect IMAGE ID</span><br></pre></td></tr></table></figure><p><code>docker inspect</code> 返回的是 <code>JSON</code> 格式的信息，如果您想获取其中指定的一项内容，可以通过 <code>-f</code> 来指定，如获取镜像大小：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f &#123;&#123;".Size"&#125;&#125; IMAGE ID</span><br></pre></td></tr></table></figure><h3 id="2-4-使用-history-命令查看镜像历史"><a href="#2-4-使用-history-命令查看镜像历史" class="headerlink" title="2.4 使用 history 命令查看镜像历史"></a>2.4 使用 history 命令查看镜像历史</h3><p>前面的小节中，我们知道了，一个镜像是由多个层（layer）组成的，那么，我们要如何知道各个层的具体内容呢？</p><p>通过 <code>docker history</code> 命令，可以列出各个层（layer）的创建信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker history IMAGE ID</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4t03poegj31mm0kw4kn.jpg" alt="image-20200525170130201"></p><p>可以看到，上面过长的信息，为了方便展示，后面都省略了，如果您想要看具体信息，可以通过添加 <code>--no-trunc</code> 选项，如下面命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker history --no-trunc IMAGE ID</span><br></pre></td></tr></table></figure><h2 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h2><h3 id="3-1-search-命令"><a href="#3-1-search-命令" class="headerlink" title="3.1 search 命令"></a>3.1 search 命令</h3><p>您可以通过下面命令进行搜索：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search [option] keyword</span><br></pre></td></tr></table></figure><p>比如，您想搜索仓库中 <code>mysql</code> 相关的镜像，可以输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure><h3 id="3-2-search-子命令"><a href="#3-2-search-子命令" class="headerlink" title="3.2 search 子命令"></a>3.2 search 子命令</h3><p>命令行输入 <code>docker search --help</code>, 输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">slimshady@MacBook-Pro ~ % docker search --help</span><br><span class="line"></span><br><span class="line">Usage:docker search [OPTIONS] TERM</span><br><span class="line"></span><br><span class="line">Search the Docker Hub for images</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Pretty-print search using a Go template</span><br><span class="line">      --limit int       Max number of search results (default 25)</span><br><span class="line">      --no-trunc        Don't truncate output</span><br></pre></td></tr></table></figure><p>可以看到 <code>search</code> 支持的子命令有：</p><ul><li><code>-f,--filter filter</code>: 过滤输出的内容；</li><li><code>--limit int</code>：指定搜索内容展示个数;</li><li><code>--no-trunc</code>：不截断输出内容；</li></ul><p>举个列子，比如我们想搜索官方提供的 mysql 镜像，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search --filter&#x3D;is-official&#x3D;true mysql</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4t3o28nsj31nk042n0v.jpg" alt="image-20200525170645573"></p><p>再比如，我们想搜索 Stars 数超过 100 的 mysql 镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search --filter&#x3D;stars&#x3D;100 mysql</span><br></pre></td></tr></table></figure><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><h3 id="4-1-通过标签删除镜像"><a href="#4-1-通过标签删除镜像" class="headerlink" title="4.1 通过标签删除镜像"></a>4.1 通过标签删除镜像</h3><p>通过如下两个都可以删除镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [image]</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm [image]</span><br></pre></td></tr></table></figure><p>支持的子命令如下：</p><ul><li><code>-f,-force</code>: 强制删除镜像，即便有容器引用该镜像；</li><li><code>-no-prune</code>: 不要删除未带标签的父镜像；</li></ul><p>对于带有标签的镜像：</p><p><strong>实际上，当同一个镜像拥有多个标签时，执行 <code>docker rmi</code> 命令，只是会删除了该镜像众多标签中，您指定的标签而已，并不会影响原始的那个镜像文件。</strong>如果某个镜像不存在多个标签，当且仅当只有一个标签时，执行删除命令时，您就要小心了，这会彻底删除镜像。</p><h3 id="4-2-通过-ID-删除镜像"><a href="#4-2-通过-ID-删除镜像" class="headerlink" title="4.2 通过 ID 删除镜像"></a>4.2 通过 ID 删除镜像</h3><p>除了通过标签名称来删除镜像，我们还可以通过制定镜像 ID, 来删除镜像，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi IMAGE ID</span><br></pre></td></tr></table></figure><p><strong>一旦制定了通过 ID 来删除镜像，它会先尝试删除所有指向该镜像的标签，然后在删除镜像本身。</strong></p><h3 id="4-3-删除镜像的限制"><a href="#4-3-删除镜像的限制" class="headerlink" title="4.3 删除镜像的限制"></a>4.3 删除镜像的限制</h3><p>删除镜像很简单，但也不是我们何时何地都能删除的，它存在一些限制条件。</p><p>当通过该镜像创建的容器未被销毁时，镜像是无法被删除的。因为有容器正在引用他。同时，可以通过添加 <code>-f</code> 子命令，也就是强制删除，才能移除掉该镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f IMAGE ID</span><br></pre></td></tr></table></figure><p>但是，我们一般不推荐这样暴力的做法，正确的做法应该是：</p><ol><li>先删除引用这个镜像的容器；</li><li>再删除这个镜像；</li></ol><h3 id="4-4-清理镜像"><a href="#4-4-清理镜像" class="headerlink" title="4.4 清理镜像"></a>4.4 清理镜像</h3><p>我们在使用 Docker 一段时间后，系统一般都会残存一些临时的、没有被使用的镜像文件，可以通过以下命令进行清理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure><p>它支持的子命令有：</p><ul><li><code>-a,--all</code>: 删除所有没有用的镜像，而不仅仅是临时文件；</li><li><code>-f,--force</code>：强制删除镜像文件，无需弹出提示确认；</li></ul><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p>Docker 创建镜像主要有三种：</p><ol><li>基于已有的镜像创建；</li><li>基于 Dockerfile 来创建；</li><li>基于本地模板来导入；</li></ol><p>我们将主要介绍常用的 1，2 两种。</p><h3 id="5-1-基于已有的镜像创建"><a href="#5-1-基于已有的镜像创建" class="headerlink" title="5.1 基于已有的镜像创建"></a>5.1 基于已有的镜像创建</h3><p>通过如下命令来创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container commit</span><br></pre></td></tr></table></figure><p>支持的子命令如下：</p><ul><li><code>-a,--author</code>=””: 作者信息；</li><li><code>-c,--change</code>=[]: 可以在提交的时候执行 Dockerfile 指令，如 CMD、ENTRYPOINT、ENV、EXPOSE、LABEL、ONBUILD、USER、VOLUME、WORIR 等；</li><li><code>-m,--message</code>=””: 提交信息；</li><li><code>-p,--pause</code>=true: 提交时，暂停容器运行。</li></ul><h3 id="5-2-基于-Dockerfile-创建"><a href="#5-2-基于-Dockerfile-创建" class="headerlink" title="5.2 基于 Dockerfile 创建"></a>5.2 基于 Dockerfile 创建</h3><p>通过 Dockerfile 的方式来创建镜像，是最常见的一种方式了，也是比较推荐的方式。Dockerfile 是一个文本指令文件，它描述了是如何基于一个父镜像，来创建一个新镜像的过程。</p><h2 id="导出-amp-加载镜像"><a href="#导出-amp-加载镜像" class="headerlink" title="导出&amp;加载镜像"></a>导出&amp;加载镜像</h2><p>通常我们会有下面这种需求，需要将镜像分享给别人，这个时候，我们可以将镜像导出成 tar 包，别人直接通过加载这个 tar 包，快速地将镜像引入到本地镜像库。</p><p>要想使用这两个功能，主要是通过如下两个命令：</p><ol><li><code>docker save</code></li><li><code>docker load</code></li></ol><h3 id="6-1-导出镜像"><a href="#6-1-导出镜像" class="headerlink" title="6.1 导出镜像"></a>6.1 导出镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o IMAGE ID</span><br></pre></td></tr></table></figure><h3 id="6-2-加载镜像"><a href="#6-2-加载镜像" class="headerlink" title="6.2 加载镜像"></a>6.2 加载镜像</h3><p>别人拿到了这个 <code>tar</code> 包后，要如何导入到本地的镜像库呢？</p><p>通过执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i xxx.tar</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; xxx.tar</span><br></pre></td></tr></table></figure><p>导入成功后，查看本地镜像信息，你就可以获得别人分享的镜像了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;  参考文档：&lt;a href=&quot;https://snailclimb.gitee.io/javaguide/#/docs/tools/Docker-Image&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://snailclimb.gitee.io/javaguide/#/docs/tools/Docker-Image&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Docker-下载镜像&quot;&gt;&lt;a href=&quot;#Docker-下载镜像&quot; class=&quot;headerlink&quot; title=&quot;Docker 下载镜像&quot;&gt;&lt;/a&gt;Docker 下载镜像&lt;/h2&gt;&lt;p&gt;如果我们想要在本地运行容器，就必须保证本地存在对应的镜像。所以，第一步，我们需要下载镜像。当我们尝试下载镜像时，Docker 会尝试先从默认的镜像仓库（默认使用 Docker Hub 公共仓库）去下载，当然了，用户也可以自定义配置想要下载的镜像仓库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="常用工具" scheme="http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://yoursite.com/2020/05/30/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git/"/>
    <id>http://yoursite.com/2020/05/30/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2021-01-29T08:52:31.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><blockquote><p>  参考文档：</p><p>  <a href="https://cyc2018.github.io/CS-Notes/#/notes/Git" target="_blank" rel="noopener">Git</a></p><p>  <a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">Git教程</a></p></blockquote><h2 id="Git与Svn的区别"><a href="#Git与Svn的区别" class="headerlink" title="Git与Svn的区别"></a>Git与Svn的区别</h2><p>Git 属于分布式版本控制系统，而 SVN 属于集中式。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfg0q07re2j30tt0grq4a.jpg" alt="img" style="zoom:50%;" /><a id="more"></a><ul><li>集中式版本控制只有中心服务器拥有一份代码，而分布式版本控制每个人的电脑上就有一份完整的代码。</li><li>集中式版本控制有安全性问题，当中心服务器挂了所有人都没办法工作了。</li><li>集中式版本控制需要连网才能工作，如果网速过慢，那么提交一个文件会非常慢。而分布式版本控制不需要连网就能工作。</li><li>分布式版本控制新建分支、合并分支操作速度非常快，而集中式版本控制新建一个分支相当于复制一份完整代码。</li></ul><h2 id="中心服务器"><a href="#中心服务器" class="headerlink" title="中心服务器"></a>中心服务器</h2><p>中心服务器用来交换每个用户的修改，没有中心服务器也能工作，但是中心服务器能够 24 小时保持开机状态，这样就能更方便的交换修改。</p><blockquote><p>  Github 就是一个中心服务器。</p></blockquote><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>新建一个仓库之后，当前目录就成为了工作区，工作区下有一个隐藏目录 <code>.git</code>，它属于 Git 的版本库。</p><p>Git 的版本库有一个称为 <code>Stage</code> 的暂存区以及最后的 <code>History</code> 版本库，<code>History</code> 存储所有分支信息，使用一个 <code>HEAD</code> 指针指向当前分支。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfg0rc9y5gj30xi0i2gn2.jpg" alt="img" style="zoom:50%;" /><ul><li>git add files 把文件的修改添加到暂存区</li><li>git commit 把暂存区的修改提交到当前分支，提交之后暂存区就被清空了</li><li>git reset – files 使用当前分支上的修改覆盖暂存区，用来撤销最后一次 git add files</li><li>git checkout – files 使用暂存区的修改覆盖工作目录，用来撤销本地修改</li></ul><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfg0rcxfh7j30sj0hfaap.jpg" alt="img" style="zoom:50%;" /><p>可以跳过暂存区域直接从分支中取出修改，或者直接提交修改到分支中。</p><ul><li>git commit -a 直接把所有文件的修改添加到暂存区然后执行提交</li><li>git checkout HEAD – files 取出最后一次修改，可以用来进行回滚操作</li></ul><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfg0rddh3uj30tf0h5aam.jpg" alt="img" style="zoom:50%;" /><h2 id="分支实现"><a href="#分支实现" class="headerlink" title="分支实现"></a>分支实现</h2><p>使用指针将每个提交连接成一条时间线，HEAD 指针指向当前分支指针。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfg0xkrfkdj30wr0dd0tc.jpg" alt="img" style="zoom:50%;" /><p>新建分支是新建一个指针指向时间线的<strong>最后一个节点</strong>，并让 HEAD 指针指向新分支，表示新分支成为当前分支。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfg0xkbrhyj30xi0fv0tb.jpg" alt="img" style="zoom:50%;" /><p>每次提交只会让当前分支指针向前移动，而其它分支指针不会移动。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfg0xjso19j30wr0gf0tb.jpg" alt="img" style="zoom:50%;" /><p>合并分支也只需要改变指针即可。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfg0xjkyvqj30w90gbq3h.jpg" alt="img" style="zoom:50%;" /><h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><p>当两个分支都对同一个文件的<strong>同一行</strong>进行了修改，在分支合并时就会产生冲突。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfg156vrrdj30xa0it3z8.jpg" alt="img" style="zoom:50%;" /><p>Git 会使用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; ，======= ，&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 标记出不同分支的内容，只需要把不同分支中冲突部分修改成一样就能解决冲突。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure><h2 id="Fast-forward"><a href="#Fast-forward" class="headerlink" title="Fast forward"></a>Fast forward</h2><p>“快进式合并”（fast-farward merge），会直接将 master 分支指向合并的分支，这种模式下进行分支合并会丢失分支信息，也就不能在分支历史上看出分支信息。</p><p>可以在合并时加上 –no-ff 参数来禁用 Fast forward 模式，并且加上 -m 参数让合并时产生一个新的 commit。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; devCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfg16fmyvvj30vm0hi3zb.jpg" alt="img" style="zoom:50%;" /><h2 id="储藏（Stashing）"><a href="#储藏（Stashing）" class="headerlink" title="储藏（Stashing）"></a>储藏（Stashing）</h2><p>在一个分支上操作之后，如果还没有将修改提交到分支上，此时进行切换分支，那么<strong>另一个分支上也能看到新的修改</strong>。这是因为<strong>所有分支都共用一个工作区</strong>的缘故。</p><p>可以使用 git stash 将当前分支的修改储藏起来，此时当前工作区的所有修改都会被存到栈中，也就是说当前工作区是干净的，没有任何未提交的修改。此时就可以安全的切换到其它分支上了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state \ &quot;WIP on master: 049d078 added the index file&quot;</span><br><span class="line">HEAD is now at 049d078 added the index file (To restore them type &quot;git stash apply&quot;)</span><br></pre></td></tr></table></figure><blockquote><p>  该功能可以用于 bug 分支的实现。如果当前正在 dev 分支上进行开发，但是此时 master 上有个 bug 需要修复，但是 dev 分支上的开发还未完成，不想立即提交。在新建 bug 分支并切换到 bug 分支之前就需要使用 git stash 将 dev 分支的未提交修改储藏起来。</p></blockquote><h2 id="SSH-传输设置"><a href="#SSH-传输设置" class="headerlink" title="SSH 传输设置"></a>SSH 传输设置</h2><p>Git 仓库和 Github 中心仓库之间的传输是通过 SSH 加密。</p><p>如果工作区下没有 .ssh 目录，或者该目录下没有 id_rsa 和 id_rsa.pub 这两个文件，可以通过以下命令来创建 SSH Key：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><p>然后把公钥 id_rsa.pub 的内容复制到 Github “Account settings” 的 SSH Keys 中。</p><h2 id="gitignore-文件"><a href="#gitignore-文件" class="headerlink" title=".gitignore 文件"></a>.gitignore 文件</h2><p>忽略以下文件：</p><ul><li>操作系统自动生成的文件，比如缩略图；</li><li>编译生成的中间文件，比如 Java 编译产生的 .class 文件；</li><li>自己的敏感信息，比如存放口令的配置文件。</li></ul><p>不需要全部自己编写，可以到 <a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a> 中进行查询。</p><h2 id="Git-命令一览"><a href="#Git-命令一览" class="headerlink" title="Git 命令一览"></a>Git 命令一览</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfg16ezy5qj30j80pr0v7.jpg" alt="img"></p><p>详细：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfg1da1xjqj313h0u0qnf.jpg" alt="image-20200604101359466"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Git&quot;&gt;&lt;a href=&quot;#Git&quot; class=&quot;headerlink&quot; title=&quot;Git&quot;&gt;&lt;/a&gt;Git&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  参考文档：&lt;/p&gt;
&lt;p&gt;  &lt;a href=&quot;https://cyc2018.github.io/CS-Notes/#/notes/Git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  &lt;a href=&quot;https://www.liaoxuefeng.com/wiki/896043488029600&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Git教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Git与Svn的区别&quot;&gt;&lt;a href=&quot;#Git与Svn的区别&quot; class=&quot;headerlink&quot; title=&quot;Git与Svn的区别&quot;&gt;&lt;/a&gt;Git与Svn的区别&lt;/h2&gt;&lt;p&gt;Git 属于分布式版本控制系统，而 SVN 属于集中式。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gfg0q07re2j30tt0grq4a.jpg&quot; alt=&quot;img&quot; style=&quot;zoom:50%;&quot; /&gt;
    
    </summary>
    
    
      <category term="常用工具" scheme="http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
</feed>
