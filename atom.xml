<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>严冰的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-13T00:02:32.504Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>yanbing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指offer</title>
    <link href="http://yoursite.com/2020/06/12/%E5%89%91%E6%8C%87offer/"/>
    <id>http://yoursite.com/2020/06/12/%E5%89%91%E6%8C%87offer/</id>
    <published>2020-06-12T12:50:49.000Z</published>
    <updated>2020-06-13T00:02:32.504Z</updated>
    
    <content type="html"><![CDATA[<p>求职在即，《剑指offer》作为大家都推荐的一本应试宝典算法相关资料，确实也有刷一刷的必要。很多题目都比较经典，也涵盖了大多数的算法和数据结构。把自己刷题的过程做一个总结，权当是一个笔记。当前还处在未完成状态，希望自己能坚持做完。</p><p>本人在LeetCode上面刷的题目，给出所有代码为本人提交Accepted后记录。</p><a id="more"></a><h2 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>运用HashMap，将数组中的数一一存入，同时比较是否map中存在，已存在的话就输出，不存在则存入map中并赋给初始值1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">int</span> n=nums.length;</span><br><span class="line">              <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (map.containsKey(nums[i])) &#123;</span><br><span class="line">result=nums[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">map.put(nums[i], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他解法：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/hua-jie-suan-fa-mian-shi-ti-3-shu-zu-zhong-zhong-f/" target="_blank" rel="noopener">HashSet</a></p><h2 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>要求只出现一次的第一个字符，就需要去计数每一个字符出现了几次。一般都是用哈希表，但是字符往多了数按照扩展的ASCII码也就256个，就可以使用int[] count来代替哈希表：键就是字符对应的数，值就是该字符出现的次数。</li><li>第一次遍历计数每个字符出现的次数for(char c : chars) count[c]++;。第二次遍历按顺序去查看该字符出现了几次，如果该字符出现了1次，它就是第一个仅出现一次的字符，直接返回。</li><li>如果第二次遍历没有返回，就说明没有仅出现一次的字符，返回’ ‘。<br>时间复杂度为O(n)，空间复杂度为O(n)（因为使用了辅助的字符数组）.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] count=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">char</span>[] chars=s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:chars)&#123;</span><br><span class="line">            count[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:chars)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count[c]==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>其他解法：<a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/solution/mian-shi-ti-50-di-yi-ge-zhi-chu-xian-yi-ci-de-zi-3/" target="_blank" rel="noopener">HashMap</a></li></ul><h2 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>排序 或者不断记录出现次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//记录每个数字的出现次数</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            count[nums[i]]++;</span><br><span class="line">            <span class="keyword">if</span>(count[nums[i]] &gt; nums.length/<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">不能有负数，不能有大数，否则数组越界，简单方法就排序</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他方法：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/solution/qiao-miao-jie-ti-bi-pai-xu-shi-xian-geng-gao-xiao-/" target="_blank" rel="noopener">比排序高效的算法</a></p><h2 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>简单题，主要复习了java数组拷贝知识和排序算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span>[] result=<span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        result=Arrays.copyOf(arr,k);</span><br><span class="line">        <span class="keyword">return</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">if</span>(k&lt;= <span class="number">0</span> || k &gt; input.length)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="comment">//初次排序，完成k个元素的排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt; k; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = i-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> unFindElement = input[i];</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; input[j] &gt; unFindElement)&#123;</span><br><span class="line">            input[j+<span class="number">1</span>] = input[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        input[j+<span class="number">1</span>] = unFindElement;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历后面的元素 进行k个元素的更新和替换</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; input.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(input[i] &lt; input[k-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> newK = input[i];</span><br><span class="line">            <span class="keyword">int</span> j = k-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; input[j] &gt; newK)&#123;</span><br><span class="line">                input[j+<span class="number">1</span>] = input[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            input[j+<span class="number">1</span>] = newK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把前k个元素返回</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        result.add(input[i]);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他算法：<a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/3chong-jie-fa-miao-sha-topkkuai-pai-dui-er-cha-sou/" target="_blank" rel="noopener">TOPK问题解法</a></p><p>笔记记录：<a href="https://blog.csdn.net/i_silence/article/details/106457958" target="_blank" rel="noopener">java数组复制</a></p><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>求斐波那契数列，斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。<br>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] result= <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        result[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        result[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            result[i]=(result[i-<span class="number">2</span>]+result[i-<span class="number">1</span>])%<span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">递归算法</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>) + Fibonacci(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">        Set&lt;String&gt; ans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        f(ans, <span class="number">0</span>, arr);</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> String[ans.size()]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与其说是递归，不如说是树形遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Set ans, <span class="keyword">int</span> position, <span class="keyword">char</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(position == arr.length)</span><br><span class="line">            ans.add(String.valueOf(arr));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = position; i&lt;arr.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 对数组swap的过程就是排列的过程，</span></span><br><span class="line">            <span class="comment">// 在for循环中swap，每次swap后，就会有新的元素排在第一位</span></span><br><span class="line">            swap(arr, position, i);</span><br><span class="line">            f(ans, position+<span class="number">1</span>, arr);</span><br><span class="line">            swap(arr, position, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他算法：<a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/solution/mian-shi-ti-38-zi-fu-chuan-de-pai-lie-hui-su-fa-by/" target="_blank" rel="noopener">回溯法</a></p><p>字典序相关:<a href="https://blog.csdn.net/i_silence/article/details/80616452?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159092775719724839200634%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=159092775719724839200634&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_blog_default-2-80616452.pc_v2_rank_blog_default&utm_term=%E5%AD%97%E5%85%B8%E5%BA%8F" target="_blank" rel="noopener">我的博客记录</a></p><p>求幂<br>(int)Math.pow(10,n);</p><h2 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><p>递归调用（分治思想），要注意的一点是，虽然题目中告诉我们不需要考虑大数问题，但是给出的 n 可以取到 -2147483648−2147483648（整型负数的最小值），因此，在编码的时候，需要将 n 转换成 long 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N=n;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> myPow(x,N);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/myPow(x,-N);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">double</span> square=myPow(x,n/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> square*square;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">double</span> square=myPow(x,(n-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">             <span class="keyword">return</span> square*square*x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><p>此类求 <strong>多少种可能性</strong> 的题目一般都有 递推性质 ，即f(n) 和 f(n-1)…f(1) 之间是有联系的。</p><p>设跳上 n 级台阶有 f(n) 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上 1 级或 2 级台阶。<br>当为 1 级台阶： 剩 n-1 个台阶，此情况共有 f(n−1) 种跳法；<br>当为 2 级台阶： 剩 n−2 个台阶，此情况共有 f(n-2) 种跳法。<br>f(n) 为以上两种情况之和，即 f(n)=f(n-1)+f(n-2)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=(dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>])%<span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意直接存储会时间超限，所以使用数组记录计算出来的值</p><h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。</p><h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><p>把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p><p>也可以使用java自带的Bitcount直接得到结果： return Integer.bitCount(n);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            n=n&amp;(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除链表的节点"><a href="#删除链表的节点" class="headerlink" title="删除链表的节点"></a>删除链表的节点</h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。<br>返回删除后的链表的头节点。</p><h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><p>简单实现链表的删除操作，即改变指针指向。<br>注意不能使用java不能使用p-&gt;next，只能p.next</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.val == val) <span class="keyword">return</span> head.next;</span><br><span class="line"></span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span>(p.next.val != val) p = p.next;</span><br><span class="line"></span><br><span class="line">        p.next = p.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><p>链表特点： 只能从前至后访问每个节点。</p><p>题目要求： 倒序输出节点值。</p><p>这种 先入后出 的需求可以借助 栈 来实现。</p><p>算法流程：</p><p>入栈： 遍历链表，将各节点值 push 入栈。（​Java​借助 LinkedList 的addLast()方法）。</p><p>出栈： 将各节点值 pop 出栈，存储于数组并返回。（Java ​新建一个数组，通过 popLast() 方法将各元素存入数组，实现倒序输出）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.addLast(head.val);</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[stack.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.length;i++)&#123;</span><br><span class="line">            res[i]=stack.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从尾到头打印链表-1"><a href="#从尾到头打印链表-1" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><h3 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3><p>输入：</p><p>[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br>这一行表示输入的操作</p><p>[ [],[3],[],[] ]<br>这个表示每一行代码操作后对应的结果</p><p>举例：<br>CQueue 表示新建一个CQueue对象，对应的结果为[]。<br>appendTail 表示执行一个appendTail()操作，对应要被操作的元素为3，，对应的结果为[3]<br>deleteHead 表示执行一个deleteHead操作，对应的结果为[]<br>deleteHead 表示执行一个deleteHead操作，对应的结果为[]</p><p>以上的输入其实是一个代码执行的步骤描述与其对应结果或操作。<br>并不是说，上面的“输入”表示的输入程序验证的数据.</p><p>使用java的要注意，如果使用Stack的方式来做这道题，会造成速度较慢； 原因的话是Stack继承了Vector接口，而Vector底层是一个Object[]数组，那么就要考虑空间扩容和移位的问题了。 可以使用LinkedList来做Stack的容器，因为LinkedList实现了Deque接口，所以Stack能做的事LinkedList都能做，其本身结构是个双向链表，扩容消耗少。</p><p>两个栈，叫他兄弟栈好了，每次入队都是哥哥出，但要出队的时候，哥哥找弟弟帮忙把栈底的元素（也就是队头）出队。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Integer&gt; stack1;</span><br><span class="line">    LinkedList&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        stack2=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        stack1.add(value);  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack1.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.add(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> stack2.pop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法说明：<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution/mian-shi-ti-09-yong-liang-ge-zhan-shi-xian-dui-l-3/" target="_blank" rel="noopener">官方解答</a></p><hr><h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h2><h3 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 </p><h3 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h3><p>二分法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int minArray(int[] nums) &#123;</span></span><br><span class="line"><span class="comment">        int min=nums[0];</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;nums.length;i++)&#123;</span></span><br><span class="line"><span class="comment">            if(nums[i]&lt;min)&#123;</span></span><br><span class="line"><span class="comment">                return nums[i];</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return min;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[m] &gt; numbers[j]) i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (numbers[m] &lt; numbers[j]) j = m;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">二叉搜索树的最近公共祖先</a></h2><h3 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>示例见原题。</p><h3 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于二叉搜索树：</p><p>根据以上定义，若 root是 p,q 的 最近公共祖先 ，则只可能为以下情况之一：</p><ul><li>p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；</li><li>p = root，且 q 在 root 的左或右子树中；</li><li>q = root，且 p 在 root 的左或右子树中；</li></ul><ol><li>若 root.val &lt; p.val ，则 p 在 root 右子树 中；</li><li>若 root.val &gt; p.val ，则 p 在 root 左子树 中；</li><li>若 root.val = p.val ，则 p 和 root 指向 同一节点 。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val&gt;p.val&amp;&amp;root.val&gt;q.val)&#123;</span><br><span class="line">            root=root.left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;p.val&amp;&amp;root.val&lt;q.val)&#123;</span><br><span class="line">            root=root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h2><h3 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个链表，找出它们的第一个公共节点。示例：</p><ul><li>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</li><li>输出：Reference of the node with value = 2</li></ul><h3 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode h1 = headA, h2 = headB;</span><br><span class="line">        <span class="keyword">while</span> (h1 != h2) &#123;</span><br><span class="line"></span><br><span class="line">            h1 = h1 == <span class="keyword">null</span> ? headB : h1.next;</span><br><span class="line">            h2 = h2 == <span class="keyword">null</span> ? headA : h2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> h1;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此题太浪漫了！两个结点去对方的轨迹中寻找对方的身影，只要二人有交集，就终会相遇❤</p><h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h2><h3 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。</p><h3 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h3><p>使用HashMap存储子链表的值，然后根据存储的map get存储指针指向关系。只学了第一种解题方案，但效率挺高的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希表</span></span><br><span class="line"><span class="comment">     * 空间复杂度 O（N)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;Node, Node&gt;();</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="comment">//map中存的是(原节点，拷贝节点)的一个映射</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.put(cur, <span class="keyword">new</span> Node(cur.val));</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="comment">//将拷贝的新的节点组织成一个链表</span></span><br><span class="line">        <span class="comment">//由原链表的关系，生成新链表的关系</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.get(cur).next = map.get(cur.next);</span><br><span class="line">            map.get(cur).random = map.get(cur.random);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原地修改，空间复杂度为O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空间复杂度O(1)</span></span><br><span class="line"><span class="comment">     * 1.将复制的节点放在原节点之后</span></span><br><span class="line"><span class="comment">     * 2.将复制节点的random节点放在原节点的random节点之后</span></span><br><span class="line"><span class="comment">     * 3.将二者分开</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将拷贝节点放到原节点后面，例如1-&gt;2-&gt;3这样的链表就变成了这样1-&gt;1'-&gt;2'-&gt;3-&gt;3'</span></span><br><span class="line">        <span class="keyword">for</span> (Node node = head, copy = <span class="keyword">null</span>; node != <span class="keyword">null</span>; node = node.next.next) &#123;</span><br><span class="line">            copy = <span class="keyword">new</span> Node(node.val);</span><br><span class="line">            copy.next = node.next;</span><br><span class="line">            node.next = copy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拷贝节点的random信息</span></span><br><span class="line">        <span class="keyword">for</span> (Node node = head; node != <span class="keyword">null</span>; node = node.next.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.next.random = node.random.next;</span><br><span class="line">        <span class="comment">//node.next 是 node 复制出来的节点 ，node.random.next 是 node.random 复制出来的节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分离拷贝节点和原节点，变成1-&gt;2-&gt;3和1'-&gt;2'-&gt;3'两个链表，后者就是答案</span></span><br><span class="line">        Node newHead = head.next;</span><br><span class="line">        <span class="keyword">for</span> (Node node = head, temp = <span class="keyword">null</span>; node != <span class="keyword">null</span> &amp;&amp; node.next != <span class="keyword">null</span>;) &#123;</span><br><span class="line">            temp = node.next;</span><br><span class="line">            node.next = temp.next;</span><br><span class="line">            node = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试题讲解：<a href="https://www.bilibili.com/video/BV1XE411L7CK?from=search&seid=9278996534222741920" target="_blank" rel="noopener">up主讲解</a></p><h2 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a>翻转单词顺序</h2><h3 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p><h3 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h3><p>trim()函数删除首位空格；</p><p>split函数为java字符串分隔符：<a href="https://www.cnblogs.com/xiaoxiaohui2015/p/5838674.html" target="_blank" rel="noopener">详细用法</a></p><p>如果字符串前面有空格 split() 会产生一个””，如果中间有连续的三个空格 会产生两个””。</p><p>使用equals而不用==，因为==比较的是内存地址即是否为同一个对象，equals比较的是内存空间里的内容是否相同。所以String类型要用”==”无效 要使用equals() 方法判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String[] strs = s.trim().split(<span class="string">" "</span>); <span class="comment">// 删除首尾空格，分割字符串</span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = strs.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 倒序遍历单词列表</span></span><br><span class="line">            <span class="keyword">if</span>(strs[i].equals(<span class="string">""</span>)) <span class="keyword">continue</span>; <span class="comment">// 遇到空单词则跳过</span></span><br><span class="line">            res.append(strs[i] + <span class="string">" "</span>); <span class="comment">// 将单词拼接至 StringBuilder</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim(); <span class="comment">// 转化为字符串，删除尾部空格，并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题解：<a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/solution/mian-shi-ti-58-i-fan-zhuan-dan-ci-shun-xu-shuang-z/" target="_blank" rel="noopener">题目讲解</a></p><h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><h3 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h3><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><h3 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h3><p>直接使用切片函数return s.subString(n,s.length())+s.subString(0,n);</p><p>使用StringBulider保存变化长度字符串，注意原string字符串s[i]不能使用要用s.charAt[i]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder str=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;s.length();i++)&#123;</span><br><span class="line">            str.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            str.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效率不高QAQ，就这样吧</p><h2 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h2><h3 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h3><p>这题麻烦点就在于边界问题，最开始的空格要处理，然后负号要标记，遇到正负号index++后，还要判断int数组边界问题。int的范围[-2147483648,2147483647]。</p><h3 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h3><p>判断好边界情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        str=str.trim();</span><br><span class="line">        <span class="keyword">if</span>(str.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> c=str.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(c!=<span class="string">'-'</span>&amp;&amp;c!=<span class="string">'+'</span>&amp;&amp;(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len=str.length();</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>,tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sign=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i)==<span class="string">'-'</span>)&#123;</span><br><span class="line">            sign=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i)==<span class="string">'-'</span>||str.charAt(i)==<span class="string">'+'</span>)&#123;</span><br><span class="line">            ++i;       </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;len&amp;&amp;str.charAt(i)&gt;=<span class="string">'0'</span>&amp;&amp;str.charAt(i)&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">            tmp=str.charAt(i)-<span class="number">48</span>;</span><br><span class="line">            <span class="keyword">if</span>(sign==<span class="number">1</span> &amp;&amp; (ans&gt;<span class="number">214748364</span> ||ans==<span class="number">214748364</span> &amp;&amp; tmp&gt;=<span class="number">7</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2147483647</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sign==<span class="number">0</span> &amp;&amp; (ans&gt;<span class="number">214748364</span> ||ans==<span class="number">214748364</span> &amp;&amp; tmp&gt;=<span class="number">8</span>))&#123;</span><br><span class="line">            <span class="comment">//注意符号是符数但ans不是负数</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">2147483648</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=ans*<span class="number">10</span>+tmp;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sign==<span class="number">0</span>) <span class="keyword">return</span> -ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h2><h3 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h3><p>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><h3 id="解题思路-19"><a href="#解题思路-19" class="headerlink" title="解题思路"></a>解题思路</h3><p>递归或者与或运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n==<span class="number">0</span> ? <span class="number">0</span>:n+sumNums(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int sumNums(int n) &#123;</span></span><br><span class="line"><span class="comment">        boolean flag = n &gt; 0 &amp;&amp; (n += sumNums(n - 1)) &gt; 0;</span></span><br><span class="line"><span class="comment">        return n;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="股票的最大利润"><a href="#股票的最大利润" class="headerlink" title="股票的最大利润"></a>股票的最大利润</h2><h3 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p>示例：输入: [7,1,5,3,6,4]<br>输出: 5</p><h3 id="解题思路-20"><a href="#解题思路-20" class="headerlink" title="解题思路"></a>解题思路</h3><p>动态规划，dp[0]=0,cost不断更新最低价格</p><p>dp[i]=max(dp[i−1],prices[i]−min(cost,prices[i])。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cost=Integer.MAX_VALUE,profit=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price:prices)&#123;</span><br><span class="line">            cost=Math.min(cost,price);</span><br><span class="line">            profit=Math.max(profit,price-cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h2><h3 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。<br>要求时间复杂度为O(n)。</p><h3 id="解题思路-21"><a href="#解题思路-21" class="headerlink" title="解题思路"></a>解题思路</h3><p>动态规划：由于 dp[i] 只与 dp[i-1] 和 nums[i] 有关系，因此可以将原数组 nums 用作 dp 列表，即直接在 nums 上修改即可。减少了O(n)的空间复杂度。<br>由于省去 dp 列表使用的额外空间，因此空间复杂度从 O(N) 降至 O(1) 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            nums[i]+=Math.max(nums[i-<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">            result=Math.max(nums[i],result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><h3 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><h3 id="解题思路-22"><a href="#解题思路-22" class="headerlink" title="解题思路"></a>解题思路</h3><p>二叉树本身就是递归定义的一种数据结构，使用递归解答本题还是很容易的。</p><p>解析：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-ii-er-cha-shu-de-zui-jin-gong-gon-7/" target="_blank" rel="noopener">后序遍历DFS</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>||root == p||root==q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 后续遍历，二叉树数的套路</span></span><br><span class="line">        TreeNode l = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode r = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">//边界条件</span></span><br><span class="line">        <span class="keyword">if</span>(l==<span class="keyword">null</span>&amp;&amp;r==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(l!=<span class="keyword">null</span>&amp;&amp;r!=<span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(l!=<span class="keyword">null</span>&amp;&amp;r==<span class="keyword">null</span>) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从上到下打印二叉树"><a href="#从上到下打印二叉树" class="headerlink" title="从上到下打印二叉树"></a>从上到下打印二叉树</h2><h3 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h3><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><h3 id="解题思路-23"><a href="#解题思路-23" class="headerlink" title="解题思路"></a>解题思路</h3><p>此题树刚好获取上一层，才打印下一层，层序遍历使用队列先进先出</p><table><thead><tr><th></th><th></th><th></th><th>1</th></tr></thead><tbody><tr><td></td><td></td><td>1.2</td><td>1.1</td></tr><tr><td>第一层队列——————1</td><td></td><td></td><td></td></tr></tbody></table><p>第二层队列———1.2，1.1，1（已经出队列）</p><p>队列存储一层一层的节点信息，然后使用list数组保存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;<span class="comment">//不判断会出错</span></span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//queue取出一个元素，还要把左右孩子加入队列</span></span><br><span class="line">            TreeNode node=queue.remove();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.length;i++)&#123;</span><br><span class="line">            res[i]=list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从上到下打印二叉树-II"><a href="#从上到下打印二叉树-II" class="headerlink" title="从上到下打印二叉树 II"></a>从上到下打印二叉树 II</h2><h3 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h3><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p>算法流程：</p><ol><li>特例处理： 当根节点为空，则返回空列表 [] ；</li><li>初始化： 打印结果列表 res = [] ，包含根节点的队列 queue = [root] ；</li><li>BFS 循环： 当队列 queue 为空时跳出；<ul><li>新建一个临时列表 tmp ，用于存储当前层打印结果；</li><li>当前层打印循环： 循环次数为当前层节点数（即队列 queue 长度）；<ul><li>出队： 队首元素出队，记为 node；</li><li>打印： 将 node.val 添加至 tmp 尾部；</li><li>添加子节点： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；</li></ul></li><li>将当前层结果 tmp 添加入 res 。</li></ul></li><li>返回值： 返回打印结果列表 res 即可。</li></ol><h3 id="解题思路-24"><a href="#解题思路-24" class="headerlink" title="解题思路"></a>解题思路</h3><p>大部分tree的题目<br>ProOrder先序遍历和postOrder后序遍历-&gt;DFS</p><p>少部分1：inOrder中序遍历-&gt;二叉搜索树</p><p>少部分2：leverOrder层序遍历-&gt;利用数据结构：队列实现</p><p>队列 先进先出 适合层序遍历，父节点在队列中，然后下一层子节点才能进队列</p><p>解决方案：从queue出去一个节点的时候，把左右节点加入queue，出来的节点数值使用一个Arraylist保存，最后转为int[]返回；</p><p>当每层单独输出一行，只需最开始记录每层的queue.size大小，然后每层输出即可</p><p>当交叉输出，把原来的Arraylist的尾部追加插入改为尾部插入/头部插入交叉即可，使用Linkedlist</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两种数据结构: Queue +  ArrayList</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心方案: queue中取出一个元素, 再把其左右孩子加入queue</span></span><br><span class="line">    queue.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> size = queue.size(); <span class="comment">//一定要先获得, 防止fast fail</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            TreeNode node = queue.remove(); <span class="comment">//queue中取出一个节点</span></span><br><span class="line"></span><br><span class="line">            temp.add(node.val); <span class="comment">//把节点值加入list</span></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)   queue.add(node.left); <span class="comment">//左孩子不空, 加入queue</span></span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)  queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲解视频:<a href="https://www.bilibili.com/video/BV1vQ4y1M7wv/" target="_blank" rel="noopener"> Queue + ArrayList</a></p><h2 id="从上到下打印二叉树-III"><a href="#从上到下打印二叉树-III" class="headerlink" title="从上到下打印二叉树 III"></a>从上到下打印二叉树 III</h2><h3 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><h3 id="解题思路-25"><a href="#解题思路-25" class="headerlink" title="解题思路"></a>解题思路</h3><p>和上一个差不多，多了个头插</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        List&lt;Integer&gt; temp=<span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//头插效率更高</span></span><br><span class="line">        <span class="keyword">int</span> size=queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            TreeNode node=queue.remove();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(flag) temp.add(node.val);</span><br><span class="line">            <span class="keyword">else</span> temp.add(<span class="number">0</span>,node.val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        flag=!flag;</span><br><span class="line">        res.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树的第k大节点"><a href="#二叉搜索树的第k大节点" class="headerlink" title="二叉搜索树的第k大节点"></a>二叉搜索树的第k大节点</h2><h3 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><h3 id="解题思路-26"><a href="#解题思路-26" class="headerlink" title="解题思路"></a>解题思路</h3><p>二叉搜索树：</p><ul><li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li><li>没有键值相等的节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ans=<span class="number">0</span>,count=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        dfs(root,k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        dfs(root.right,k);</span><br><span class="line">        <span class="keyword">if</span>(++count==k)&#123;</span><br><span class="line">            ans=root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><h3 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉树的根节点，求该树的深度。</p><h3 id="解题思路-27"><a href="#解题思路-27" class="headerlink" title="解题思路"></a>解题思路</h3><p>此树的深度和其左（右）子树的深度之间的关系。显然，此树的深度 等于左子树的深度与右子树的深度 中的 最大值 +1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><h3 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><h3 id="解题思路-28"><a href="#解题思路-28" class="headerlink" title="解题思路"></a>解题思路</h3><p>先写二叉树的深度函数，对于本题，使用DFS,不断判断左右子树是否满足条件，最后返回根节点的左右节点是否满足深度条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> leftHeight=getHeight(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightHeight=getHeight(root.right);</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(rightHeight-leftHeight)&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isBalanced(root.left)&amp;&amp;isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftHeight=getHeight(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightHeight=getHeight(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftHeight,rightHeight)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><h3 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><h3 id="解题思路-29"><a href="#解题思路-29" class="headerlink" title="解题思路"></a>解题思路</h3><p>解析：<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/" target="_blank" rel="noopener">题目解析</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = matrix[<span class="number">0</span>].length - <span class="number">1</span>, t = <span class="number">0</span>, b = matrix.length - <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[(r + <span class="number">1</span>) * (b + <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++) res[x++] = matrix[t][i]; <span class="comment">// left to right.</span></span><br><span class="line">            <span class="keyword">if</span>(++t &gt; b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i &lt;= b; i++) res[x++] = matrix[i][r]; <span class="comment">// top to bottom.</span></span><br><span class="line">            <span class="keyword">if</span>(l &gt; --r) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i &gt;= l; i--) res[x++] = matrix[b][i]; <span class="comment">// right to left.</span></span><br><span class="line">            <span class="keyword">if</span>(t &gt; --b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = b; i &gt;= t; i--) res[x++] = matrix[i][l]; <span class="comment">// bottom to top.</span></span><br><span class="line">            <span class="keyword">if</span>(++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">import java.util.ArrayList;</span></span><br><span class="line"><span class="comment">public class Solution &#123;</span></span><br><span class="line"><span class="comment">    public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123;</span></span><br><span class="line"><span class="comment">        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span></span><br><span class="line"><span class="comment">        //定义四个边界</span></span><br><span class="line"><span class="comment">        int low = 0;</span></span><br><span class="line"><span class="comment">        int high = matrix.length -1;</span></span><br><span class="line"><span class="comment">        int left = 0;</span></span><br><span class="line"><span class="comment">        int right = matrix[0].length -1;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        while(low &lt;= high &amp;&amp; left &lt;= right)&#123;</span></span><br><span class="line"><span class="comment">            for(int i = left; i &lt;= right; i++)&#123;</span></span><br><span class="line"><span class="comment">                list.add(matrix[low][i]);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            for(int i = low+1; i &lt;= high; i++)&#123;</span></span><br><span class="line"><span class="comment">                list.add(matrix[i][right]);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(low &lt; high)&#123;</span></span><br><span class="line"><span class="comment">               for(int i = right-1; i &gt;= left; i--)&#123;</span></span><br><span class="line"><span class="comment">                    list.add(matrix[high][i]);</span></span><br><span class="line"><span class="comment">                &#125; </span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(left &lt; right)&#123;</span></span><br><span class="line"><span class="comment">                for(int i = high-1; i &gt;= low+1; i--)&#123;</span></span><br><span class="line"><span class="comment">                    list.add(matrix[i][left]);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            low++;</span></span><br><span class="line"><span class="comment">            high--;</span></span><br><span class="line"><span class="comment">            left++;</span></span><br><span class="line"><span class="comment">            right--;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return list;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h2><h3 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><h3 id="解题思路-30"><a href="#解题思路-30" class="headerlink" title="解题思路"></a>解题思路</h3><p>java 递归解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"null,"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String res = root.val + <span class="string">","</span>;</span><br><span class="line">    res += serialize(root.left);</span><br><span class="line">    res += serialize(root.right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    String[] arr = data.split(<span class="string">","</span>);</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        queue.offer(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> help(queue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">help</span><span class="params">(Queue&lt;String&gt; queue)</span></span>&#123;</span><br><span class="line">    String val = queue.poll();</span><br><span class="line">    <span class="keyword">if</span>(val.equals(<span class="string">"null"</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(Integer.valueOf(val));</span><br><span class="line">    root.left = help(queue);</span><br><span class="line">    root.right = help(queue);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他解法：<a href="https://www.bilibili.com/video/BV1HE411J7xm?from=search&seid=1024036032281247729" target="_blank" rel="noopener">b站解析</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder(<span class="string">"["</span>);</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>; <span class="comment">// 用来记录当前节点及其后面非空节点的个数</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                ans.append(<span class="string">"null"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.append(node.val);</span><br><span class="line">                sum--;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum != <span class="number">0</span>) &#123;</span><br><span class="line">                ans.append(<span class="string">","</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.append(<span class="string">"]"</span>);</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        String s = data.substring(<span class="number">1</span>, data.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">""</span>.equals(s)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// data = "[]"</span></span><br><span class="line">        &#125;</span><br><span class="line">        String[] a = s.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(change(a[index++]));</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; index &lt; a.length) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">"null"</span>.equals(a[index])) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> TreeNode(change(a[index++]));</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; a.length &amp;&amp; !<span class="string">"null"</span>.equals(a[index])) &#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> TreeNode(change(a[index++]));</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(<span class="number">0</span>) == <span class="string">'-'</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            flag = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; s.length(); i++) &#123;</span><br><span class="line">            res = res * <span class="number">10</span> + s.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res * flag;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h2><h3 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><h3 id="解题思路-31"><a href="#解题思路-31" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实就是维护两个栈，首先第一个栈是普通的数据栈，跟我们平常的栈一样，存储入栈数据；第二个栈就是建立在第一个栈的基础之上，他是维护第一个栈，就是去维护第一个栈中元素的最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; datastack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minstack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        datastack.push(x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(minstack.isEmpty()||minstack.peek()&gt;x)&#123;</span><br><span class="line">            minstack.push(datastack.peek());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            minstack.push(minstack.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//栈的获取栈顶元素pop函数为peek()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!datastack.isEmpty())&#123;</span><br><span class="line">            datastack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!minstack.isEmpty())&#123;</span><br><span class="line">            minstack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> datastack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minstack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他解法：<a href="https://www.bilibili.com/video/BV1Ga4y1t7nG?from=search&seid=2204680535616609379" target="_blank" rel="noopener">b站up主解析</a></p><h2 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a>最长不含重复字符的子字符串</h2><h3 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h3><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><h3 id="解题思路-32"><a href="#解题思路-32" class="headerlink" title="解题思路"></a>解题思路</h3><p>双指针+哈希表</p><ul><li>哈希表 dis 统计： 指针 j 遍历字符 s ，哈希表统计字符 s[j] 最后一次出现的索引 。</li><li>更新左指针 i ： 根据上轮左指针 i 和 dic[s[j]] ，每轮更新左边界 i ，保证区间 [i + 1, j] 内无重复字符且最大。<br>i=max(dic[s[j]],i)</li><li>更新结果 res ： 取上轮 res 和本轮双指针区间 [i + 1,j] 的宽度（即 j - i ）中的最大值。<br>res=max(res,j−i)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i=-<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(j)))</span><br><span class="line">                i=Math.max(map.get(s.charAt(j)),i);<span class="comment">//map里的内容与即将放入的j对比，更新i的值</span></span><br><span class="line">            map.put(s.charAt(j),j);</span><br><span class="line">            res=Math.max(res,j-i);<span class="comment">//放入j，更新结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="把数字翻译成字符串"><a href="#把数字翻译成字符串" class="headerlink" title="把数字翻译成字符串"></a>把数字翻译成字符串</h2><h3 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><h3 id="解题思路-33"><a href="#解题思路-33" class="headerlink" title="解题思路"></a>解题思路</h3><p>动态规划问题，考虑bp[i]=bp[i-1]还是bp[i]=bp[i-1]+bp[i-2],<br>如果新加入的数字和前一个数字可以组合，就加上bp[i-2]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String s=String.valueOf(num);</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">int</span>[] bp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        bp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        bp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            bp[i]=bp[i-<span class="number">1</span>];</span><br><span class="line">            String tmp=s.substring(i-<span class="number">2</span>,i);</span><br><span class="line">            <span class="keyword">if</span>(tmp.compareTo(<span class="string">"10"</span>)&gt;=<span class="number">0</span>&amp;&amp;tmp.compareTo(<span class="string">"25"</span>)&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                bp[i]+=bp[i-<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><h3 id="题目描述-34"><a href="#题目描述-34" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p><h3 id="解题思路-34"><a href="#解题思路-34" class="headerlink" title="解题思路"></a>解题思路</h3><p>s:abc<br>p:.bc或者abc<br>s[i]=p[i]||p[i]=’.’</p><p>有：</p><p><em>表示出现零次<br>s:bc<br>p:a</em>bc<br>保持s不变，p前两个元素去除</p><p><em>表示出现一次或者多次<br>s:aabc<br>p:a</em>bc<br>保持p不变，s不断减去一个元素</p><p>有<em>的两个路要全试一遍<br>比如出现s:<br>s:abb<br>p:a</em>abb这种情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s.length()==<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> fristmatch=(s.length()!=<span class="number">0</span>)&amp;&amp;(s.charAt(<span class="number">0</span>)==p.charAt(<span class="number">0</span>)||p.charAt(<span class="number">0</span>)==<span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">if</span>(p.length()&gt;=<span class="number">2</span>&amp;&amp;p.charAt(<span class="number">1</span>)==<span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> isMatch(s,p.substring(<span class="number">2</span>))||(fristmatch&amp;&amp;isMatch(s.substring(<span class="number">1</span>),p));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fristmatch&amp;&amp;isMatch(s.substring(<span class="number">1</span>),p.substring(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他解法：<a href="https://blog.csdn.net/qq_28410301/article/details/100182901" target="_blank" rel="noopener">动态规划DP</a></p><p><a href="https://www.bilibili.com/video/BV13441117i4?p=1" target="_blank" rel="noopener">视频解析</a></p><h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><h3 id="题目描述-35"><a href="#题目描述-35" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><h3 id="解题思路-35"><a href="#解题思路-35" class="headerlink" title="解题思路"></a>解题思路</h3><p>前序遍历的第一个节点是根节点，只要找到根节点在中序遍历中的位置，在根节点之前被访问的节点都位于左子树，在根节点之后被访问的节点都位于右子树，由此可知左子树和右子树分别有多少个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder==<span class="keyword">null</span>||preorder.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> index=findIndex(preorder,inorder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建左子树，右子树</span></span><br><span class="line">        root.left=buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>,index+<span class="number">1</span>),</span><br><span class="line">        Arrays.copyOfRange(inorder,<span class="number">0</span>,index));</span><br><span class="line"></span><br><span class="line">        root.right=buildTree(Arrays.copyOfRange(preorder,index+<span class="number">1</span>,preorder.length),</span><br><span class="line">        Arrays.copyOfRange(inorder,index+<span class="number">1</span>,inorder.length));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findIndex</span><span class="params">(<span class="keyword">int</span>[] preorder,<span class="keyword">int</span>[] inorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]==preorder[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：<a href="https://www.bilibili.com/video/BV1f741197Rx?from=search&seid=16504896464128155223" target="_blank" rel="noopener">up主讲解</a></p><h2 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h2><h3 id="题目描述-36"><a href="#题目描述-36" class="headerlink" title="题目描述"></a>题目描述</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。</p><p>示例：</p><p>输入：board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCCED”</p><p>输出：true</p><h3 id="解题思路-36"><a href="#解题思路-36" class="headerlink" title="解题思路"></a>解题思路</h3><p>深搜+回溯，深搜的过程其实就是对四个方向的一个递归调用的过程，回溯的话是为了消除某一次递归调用所产生的路径不能匹配模式串所产生的影响要被消除掉，消除的结果就是对这条路径上的每一个位置进行状态初始化，即标记为未被遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[i].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(solve(board,word,i,j,visit,<span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="comment">//找到一种情况即可</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board,String word,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">boolean</span>[][] vis,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;=board.length||y&lt;<span class="number">0</span>||y&gt;=board[<span class="number">0</span>].length||vis[x][y])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(word.charAt(index)!=board[x][y])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index==word.length()-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vis[x][y]=<span class="keyword">true</span>;<span class="comment">//位置标记</span></span><br><span class="line">        <span class="keyword">boolean</span> flag=solve(board,word,x+<span class="number">1</span>,y,vis,index+<span class="number">1</span>)||</span><br><span class="line">                     solve(board,word,x-<span class="number">1</span>,y,vis,index+<span class="number">1</span>)||</span><br><span class="line">                     solve(board,word,x,y+<span class="number">1</span>,vis,index+<span class="number">1</span>)||</span><br><span class="line">                     solve(board,word,x,y-<span class="number">1</span>,vis,index+<span class="number">1</span>);</span><br><span class="line">        vis[x][y]=<span class="keyword">false</span>; <span class="comment">//回溯，bfs关键步骤</span></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h2><h3 id="题目描述-37"><a href="#题目描述-37" class="headerlink" title="题目描述"></a>题目描述</h3><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><h3 id="解题思路-37"><a href="#解题思路-37" class="headerlink" title="解题思路"></a>解题思路</h3><p>可以剪枝，向左和向上的不用遍历，只用遍历向右和向下的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,m,n,k,visit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">            sum+=i%<span class="number">10</span>;</span><br><span class="line">            i/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j!=<span class="number">0</span>)&#123;</span><br><span class="line">            sum+=j%<span class="number">10</span>;</span><br><span class="line">            j/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">boolean</span>[][] vis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||i&gt;=m||j&gt;=n||sum(i,j)&gt;k||vis[i][j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[i][j]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+dfs(i+<span class="number">1</span>,j,m,n,k,vis)</span><br><span class="line">        <span class="comment">//+dfs(i-1,j,m,n,k,vis)</span></span><br><span class="line">        +dfs(i,j+<span class="number">1</span>,m,n,k,vis);</span><br><span class="line">        <span class="comment">//+dfs(i,j-1,m,n,k,vis);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h2><h3 id="题目描述-38"><a href="#题目描述-38" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><h3 id="解题思路-38"><a href="#解题思路-38" class="headerlink" title="解题思路"></a>解题思路</h3><p>不难发现，将长度为n的绳子剪成m段。满足每段都是n/m时，乘积最大。但n/m可能不是整数。把剩下的left长度分给num，left段，即有left段长度为num+1,有m-left段长度为num。然后遍历段数从2到n找到最大值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            ans=Math.max(ans,mylength(n,i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mylength</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num=n/m;</span><br><span class="line">        <span class="keyword">int</span> remain=n%m;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.pow(num,m-remain))*(<span class="keyword">int</span>)(Math.pow(num+<span class="number">1</span>,remain));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剪绳子-II"><a href="#剪绳子-II" class="headerlink" title="剪绳子 II"></a>剪绳子 II</h2><h3 id="题目描述-39"><a href="#题目描述-39" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m] 。请问 k[0]<em>k[1]</em>…*k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><h3 id="解题思路-39"><a href="#解题思路-39" class="headerlink" title="解题思路"></a>解题思路</h3><p>5：2+3  6：3+3 &gt;6的数可以切分为2或者3，优先考虑3（递推得出结论）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if(n==2) return 1;</span></span><br><span class="line">        <span class="comment">//if(n==3) return 2;</span></span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">3</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">4</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">long</span> ans=<span class="number">1</span>; <span class="comment">//一定是long类型</span></span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">4</span>)&#123;</span><br><span class="line">            ans*=<span class="number">3</span>;</span><br><span class="line">            ans%=<span class="number">1000000007</span>;</span><br><span class="line">            n-=<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(ans*n%<span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h2><h3 id="题目描述-40"><a href="#题目描述-40" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”、”-1E-16”及”12e+5.4”都不是。</p><h3 id="解题思路-40"><a href="#解题思路-40" class="headerlink" title="解题思路"></a>解题思路</h3><p>模拟题，练习意义不大，所以使用了库函数Double.parseDouble转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.endsWith(<span class="string">"f"</span>) || s.endsWith(<span class="string">"d"</span>) || s.endsWith(<span class="string">"F"</span>) || s.endsWith(<span class="string">"D"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Double.parseDouble(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class Solution &#123;</span></span><br><span class="line"><span class="comment">    public boolean isNumeric(char[] str) &#123;</span></span><br><span class="line"><span class="comment">        // 标志小数点和指数</span></span><br><span class="line"><span class="comment">        boolean point = false, exp = false;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; str.length; i++) &#123;</span></span><br><span class="line"><span class="comment">            if (str[i] == '+' || str[i] == '-') &#123;</span></span><br><span class="line"><span class="comment">                // +-号后面必定为数字 或 后面为.（-.123 = -0.123）</span></span><br><span class="line"><span class="comment">                //如果没有下一位或者下一位部位数字或者下一位为小数点，直接返回</span></span><br><span class="line"><span class="comment">                if (i + 1 == str.length </span></span><br><span class="line"><span class="comment">                    || !(str[i + 1] &gt;= '0' &amp;&amp; str[i + 1] &lt;= '9' </span></span><br><span class="line"><span class="comment">                         || str[i + 1] == '.')) &#123; </span></span><br><span class="line"><span class="comment">                    return false;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                // +-号只出现在第一位或eE的后一位</span></span><br><span class="line"><span class="comment">                if (!(i == 0 || str[i-1] == 'e' || str[i-1] == 'E')) &#123;</span></span><br><span class="line"><span class="comment">                    return false;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125; else if (str[i] == '.') &#123;</span></span><br><span class="line"><span class="comment">                // .后面必定为数字 或为最后一位（233. = 233.0）</span></span><br><span class="line"><span class="comment">                if (point || exp </span></span><br><span class="line"><span class="comment">                    || !(i+1 &lt; str.length &amp;&amp; str[i+1] &gt;= '0' &amp;&amp; str[i+1] &lt;= '9')) &#123; </span></span><br><span class="line"><span class="comment">                    return false;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                point = true;</span></span><br><span class="line"><span class="comment">            &#125; else if (str[i] == 'e' || str[i] == 'E') &#123;</span></span><br><span class="line"><span class="comment">                // eE后面必定为数字或+-号</span></span><br><span class="line"><span class="comment">                if (exp || i + 1 == str.length </span></span><br><span class="line"><span class="comment">                        || !(str[i + 1] &gt;= '0' &amp;&amp; str[i + 1] &lt;= '9' </span></span><br><span class="line"><span class="comment">                        || str[i + 1] == '+' </span></span><br><span class="line"><span class="comment">                        || str[i + 1] == '-')) &#123; </span></span><br><span class="line"><span class="comment">                    return false;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                exp = true;</span></span><br><span class="line"><span class="comment">            &#125; else if (str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') &#123;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">                return false;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return true;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="数组中数字出现的次数"><a href="#数组中数字出现的次数" class="headerlink" title="数组中数字出现的次数"></a>数组中数字出现的次数</h2><h3 id="题目描述-41"><a href="#题目描述-41" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><h3 id="解题思路-41"><a href="#解题思路-41" class="headerlink" title="解题思路"></a>解题思路</h3><p>所有值异或出来的结果会有某一位数字为1，根据这个1所在的位置把数组分为两部分，两个不相等的数字肯定被分为两个不同组，然后分别异或就可以得到这个数字。</p><p>1&lt;&lt;n相当于1*2^n</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            sum^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> y=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((y&amp;sum)==<span class="number">0</span>)&#123;</span><br><span class="line">            y=y&lt;&lt;<span class="number">1</span>; <span class="comment">//找到第y位异或为1的位置,y数字保存这个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((y&amp;nums[i])==<span class="number">0</span>)&#123;</span><br><span class="line">                res[<span class="number">0</span>]^=nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[<span class="number">1</span>]^=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组中数字出现的次数-II"><a href="#数组中数字出现的次数-II" class="headerlink" title="数组中数字出现的次数 II"></a>数组中数字出现的次数 II</h2><h3 id="题目描述-42"><a href="#题目描述-42" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><h3 id="解题思路-42"><a href="#解题思路-42" class="headerlink" title="解题思路"></a>解题思路</h3><p>排序，有点偷懒的做法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>||nums[<span class="number">0</span>]!=nums[<span class="number">1</span>])  <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums[len-<span class="number">2</span>]!=nums[len-<span class="number">1</span>])  <span class="keyword">return</span> nums[len-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(((nums[i]^nums[i-<span class="number">1</span>])!=<span class="number">0</span>)&amp;&amp;((nums[i]^nums[i+<span class="number">1</span>])!=<span class="number">0</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他解法：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/solution/mian-shi-ti-56-ii-shu-zu-zhong-shu-zi-chu-xian-d-4/" target="_blank" rel="noopener">自动机+位运算</a></p><h2 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a>和为s的两个数字</h2><h3 id="题目描述-43"><a href="#题目描述-43" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><h3 id="解题思路-43"><a href="#解题思路-43" class="headerlink" title="解题思路"></a>解题思路</h3><p>递增数组，所以使用双指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum=nums[left]+nums[right];</span><br><span class="line">            <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[left],nums[right]&#125;;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h2><h3 id="题目描述-44"><a href="#题目描述-44" class="headerlink" title="题目描述"></a>题目描述</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><h3 id="解题思路-44"><a href="#解题思路-44" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum; <span class="comment">// 用来去统计逆序对的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span> [] nums)</span> </span>&#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = nums.length - <span class="number">1</span>;</span><br><span class="line">        divide(l ,r, nums);</span><br><span class="line">        <span class="keyword">return</span>  sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            divide(l, mid, array);</span><br><span class="line">            divide(mid + <span class="number">1</span>, r, array);</span><br><span class="line">            merge(l, r, mid, array);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> mid, <span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = l; <span class="comment">// 左区间的起点</span></span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>; <span class="comment">// 右区间的起点</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; array[j]) &#123;</span><br><span class="line">                temp[index++] = array[j++];</span><br><span class="line">                sum += mid - i + <span class="number">1</span>; <span class="comment">// 这一行是核心，去统计逆序对个数</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[index++] = array[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            temp[index++] = array[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= r) &#123;</span><br><span class="line">            temp[index++] = array[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; k++) &#123;</span><br><span class="line">            array[k] = temp[index++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.arraycopy(temp,0,array,0,r-l+1); 将temp数组里从索引为0的元素开始, 复制到数组array里的索引为0的位置, 复制的元素个数为length个. </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法讲解：<a href="https://www.bilibili.com/video/BV1S7411G7Mg?from=search&seid=12482759876812943200" target="_blank" rel="noopener">b站up主解析</a></p><h2 id="队列的最大值"><a href="#队列的最大值" class="headerlink" title="队列的最大值"></a>队列的最大值</h2><h3 id="题目描述-45"><a href="#题目描述-45" class="headerlink" title="题目描述"></a>题目描述</h3><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。若队列为空，pop_front 和 max_value 需要返回 -1。</p><h3 id="解题思路-45"><a href="#解题思路-45" class="headerlink" title="解题思路"></a>解题思路</h3><p>使用Deque记录队列最大值，当一个元素加进队列中把之前比deque中比它小的最大记录值去除；当一个元素出队列判断该元素是否为最大值，是的话更新Queue中的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    Deque&lt;Integer&gt; deque;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        deque=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(deque.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> deque.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        queue.add(value);</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty()&amp;&amp;deque.getLast()&lt;value)&#123;</span><br><span class="line">            deque.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.add(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(queue.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(ans==deque.peek())&#123;</span><br><span class="line">            deque.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目解析: <a href="https://www.bilibili.com/video/BV1Zc411h7b5?from=search&seid=9506675113429161345" target="_blank" rel="noopener">up主xmmmm</a></p><h2 id="在排序数组中查找数字-I"><a href="#在排序数组中查找数字-I" class="headerlink" title="在排序数组中查找数字 I"></a>在排序数组中查找数字 I</h2><h3 id="题目描述-46"><a href="#题目描述-46" class="headerlink" title="题目描述"></a>题目描述</h3><p>统计一个数字在排序数组中出现的次数。</p><h3 id="解题思路-46"><a href="#解题思路-46" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于排序过的数组使用二分，水题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;nums.length&amp;&amp;nums[left++]==target)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0～n-1中缺失的数字"><a href="#0～n-1中缺失的数字" class="headerlink" title="0～n-1中缺失的数字"></a>0～n-1中缺失的数字</h2><h3 id="题目描述-47"><a href="#题目描述-47" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><h3 id="解题思路-47"><a href="#解题思路-47" class="headerlink" title="解题思路"></a>解题思路</h3><p>递增数组查找数字，二分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==mid)&#123; </span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a>和为s的连续正数序列</h2><h3 id="题目描述-48"><a href="#题目描述-48" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><h3 id="解题思路-48"><a href="#解题思路-48" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题当前可以用等差数列的求和公式来计算滑动窗口的和。不过我这里没有使用求和公式，是为了展示更通用的解题思路。实际上，把题目中的正整数序列换成任意的递增整数序列，这个方法都可以解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;<span class="comment">//双指针（滑动窗口）初始都为1</span></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=target/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;target)&#123;</span><br><span class="line">                sum+=j;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">                sum-=i;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[j-i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)&#123;</span><br><span class="line">                    arr[k-i]=k;</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(arr);</span><br><span class="line">                sum-=i;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h2><h3 id="题目描述-49"><a href="#题目描述-49" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><h3 id="解题思路-49"><a href="#解题思路-49" class="headerlink" title="解题思路"></a>解题思路</h3><p>双指针做法,实际思想是快排.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> left =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=nums[left];</span><br><span class="line">                nums[left]=nums[right];</span><br><span class="line">                nums[right]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><h3 id="题目描述-50"><a href="#题目描述-50" class="headerlink" title="题目描述"></a>题目描述</h3><p>我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p><h3 id="解题思路-50"><a href="#解题思路-50" class="headerlink" title="解题思路"></a>解题思路</h3><p>假设当前存在 3 个数组 nums2, nums3, nums5 分别代表丑数序列从 1 开始分别乘以 2, 3, 5 的序列， 即</p><p>nums2 = {1<em>2, 2</em>2, 3<em>2, 4</em>2, 5<em>2, 6</em>2,…}</p><p>nums3 = {1<em>3, 2</em>3, 3<em>3, 4</em>3, 5<em>3, 6</em>3,…}</p><p>nums5 = {1<em>5, 2</em>5, 3<em>5, 4</em>5, 5<em>5, 6</em>5,…}</p><p>那么， 最终的丑数序列实际上就是这 3 个有序序列对的合并结果， 计算丑数序列也就是相当于 合并 3 个有序序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>; <span class="comment">// 遍历丑数*2的队列</span></span><br><span class="line">        <span class="keyword">int</span> index2 = <span class="number">0</span>; <span class="comment">// 遍历丑数*3的队列</span></span><br><span class="line">        <span class="keyword">int</span> index3 = <span class="number">0</span>; <span class="comment">// 遍历丑数*5的队列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            a[i]=Math.min(a[index1]*<span class="number">2</span>,Math.min(a[index2]*<span class="number">3</span>,a[index3]*<span class="number">5</span>));</span><br><span class="line">            <span class="keyword">if</span>(a[i]==a[index1]*<span class="number">2</span>)&#123;</span><br><span class="line">                index1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==a[index2]*<span class="number">3</span>)&#123;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==a[index3]*<span class="number">5</span>)&#123;</span><br><span class="line">                index3++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a>礼物的最大价值</h2><h3 id="题目描述-51"><a href="#题目描述-51" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><h3 id="解题思路-51"><a href="#解题思路-51" class="headerlink" title="解题思路"></a>解题思路</h3><p>f(i, j) = max{f(i - 1, j), f(i, j - 1)} + grid[i][j].</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) grid[i][j] += grid[i][j - <span class="number">1</span>] ;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) grid[i][j] += grid[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> grid[i][j] += Math.max(grid[i][j - <span class="number">1</span>], grid[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) <span class="comment">// 初始化第一行</span></span><br><span class="line">            grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) <span class="comment">// 初始化第一列</span></span><br><span class="line">            grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) </span><br><span class="line">                grid[i][j] += Math.max(grid[i][j - <span class="number">1</span>], grid[i - <span class="number">1</span>][j]);</span><br><span class="line">        <span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">多开一行一列的空间能够让代码更简洁</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int maxValue(int[][] grid) &#123;</span></span><br><span class="line"><span class="comment">        int row=grid.length,col=grid[0].length;</span></span><br><span class="line"><span class="comment">        int[][] dp=new int[row+1][col+1];</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;=row;i++)&#123;</span></span><br><span class="line"><span class="comment">            for(int j=1;j&lt;=col;j++)&#123;</span></span><br><span class="line"><span class="comment">                dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1])+grid[i-1][j-1];</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return dp[row][col];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h2><h3 id="题目描述-52"><a href="#题目描述-52" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><h3 id="解题思路-52"><a href="#解题思路-52" class="headerlink" title="解题思路"></a>解题思路</h3><p>快慢指针，先让快指针走k步，然后两个指针同步走，当快指针走到头时，慢指针就是链表倒数第k个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode frontNode=head;</span><br><span class="line">        ListNode behindNode=head;</span><br><span class="line">        <span class="keyword">while</span>(frontNode!=<span class="keyword">null</span>&amp;&amp;k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            frontNode=frontNode.next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(frontNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            frontNode=frontNode.next;</span><br><span class="line">            behindNode=behindNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> behindNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><h3 id="题目描述-53"><a href="#题目描述-53" class="headerlink" title="题目描述"></a>题目描述</h3><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><h3 id="解题思路-53"><a href="#解题思路-53" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>定义两个指针： pre 和 cur ；pre 在前 cur 在后。</li><li>每次让 pre 的 next 指向 cur ，实现一次局部反转</li><li>局部反转完成之后， pre 和 cur 同时往前移动一个位置</li><li>循环上述过程，直至 pre 到达链表尾部.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode cur=<span class="keyword">null</span>;</span><br><span class="line">        ListNode pre=head;</span><br><span class="line">        ListNode tmp=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(pre!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            tmp=pre.next;</span><br><span class="line">            pre.next=cur;</span><br><span class="line">            cur=pre;</span><br><span class="line">            pre=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>其他解法:<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/fan-zhuan-lian-biao-yi-dong-de-shuang-zhi-zhen-jia/" target="_blank" rel="noopener">递归</a></li></ul><h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><h3 id="题目描述-54"><a href="#题目描述-54" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构).B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><h3 id="解题思路-54"><a href="#解题思路-54" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先在isSubStructure()函数中进行判断：</p><ul><li>（1）利用fun判断以根节点为开始的结构是否为真；</li><li>（2）若不为真，同样利用fun对其左子树判断；</li><li>（3）都不为真，再对其右子树判断。<br>只要三者有一个为真，则结果为真。</li></ul><p>以上是主体部分，接下来再对fun进行分析：<br>fun是一个工具函数，用来判断当前结构与B是否完全相同，所以必须满足三个条件：</p><ul><li>（1）首先当前节点值必须与B的节点值相同；</li><li>（2）当前节点的左子树结构必须与B的左子树结构完全相同（递归调用fun工具函数）；</li><li>（3）当前节点的右子树结构必须与B的右子树结构完全相同（递归调用fun工具函数）；</li></ul><p>接下来分析边界条件：</p><ul><li>对于isSubStructure（）函数中，如果刚开始传进来的A,B只要有一个为空，则结果为false；</li><li>对于fun（）函数，在比较过程中，如果B比完了，则说明存在该子结构，如果B还有节点，而A没有了，则说明A中不存在该子结构，返回false。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span>||B==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(A,B)||isSubStructure(A.left,B)||isSubStructure(A.right,B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode a,TreeNode b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//必须先判断b边界条件</span></span><br><span class="line">        <span class="keyword">if</span>(a==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> (a.val==b.val)&amp;&amp;dfs(a.left,b.left)&amp;&amp;dfs(a.right,b.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h2><h3 id="题目描述-55"><a href="#题目描述-55" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><h3 id="解题思路-55"><a href="#解题思路-55" class="headerlink" title="解题思路"></a>解题思路</h3><p>递归解法,非递归就按正常思路往cur指针加数然后往后更新cur指针,最后把其中一个剩下的非空加入cur就行.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">            l1.next=mergeTwoLists(l1.next,l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next=mergeTwoLists(l1,l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/solution/mian-shi-ti-25-he-bing-liang-ge-pai-xu-de-lian-b-2/" target="_blank" rel="noopener">解析</a></p><h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h2><h3 id="题目描述-56"><a href="#题目描述-56" class="headerlink" title="题目描述"></a>题目描述</h3><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><h3 id="解题思路-56"><a href="#解题思路-56" class="headerlink" title="解题思路"></a>解题思路</h3><p>左右子树调换,使用递归简单解答,边界条件为root为空.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode tmp=root.left;</span><br><span class="line">        root.left=mirrorTree(root.right);</span><br><span class="line">        root.right=mirrorTree(tmp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h2><h3 id="题目描述-57"><a href="#题目描述-57" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><h3 id="解题思路-57"><a href="#解题思路-57" class="headerlink" title="解题思路"></a>解题思路</h3><p>对称二叉树定义： 对于树中 任意两个对称节点 L 和 R ，一定有：</p><ul><li>L.val = R.val ：即此两对称节点值相等。</li><li>L.left.val = R.right.val ：即 L 的 左子节点 和 R 的 右子节点 对称；</li><li>L.right.val = R.left.val ：即 L 的 右子节点 和 R 的 左子节点 对称。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> help(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">help</span><span class="params">(TreeNode l,TreeNode r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="keyword">null</span>&amp;&amp;r==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="keyword">null</span>||r==<span class="keyword">null</span>||l.val!=r.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> help(l.left,r.right)&amp;&amp;help(l.right,r.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h2><h3 id="题目描述-58"><a href="#题目描述-58" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p><h3 id="解题思路-58"><a href="#解题思路-58" class="headerlink" title="解题思路"></a>解题思路</h3><p>队列尾部进头部出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[n-k+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//dq里面存的是数组的index, 不是数组的值</span></span><br><span class="line">        Deque&lt;Integer&gt; deque=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//移除头部,保证窗口长度</span></span><br><span class="line">            <span class="keyword">if</span>(!deque.isEmpty()&amp;&amp;deque.getFirst()&lt;(i-k+<span class="number">1</span>))&#123;</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//移除尾部比当前要加入的值小的元素(不可能答案)</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty()&amp;&amp;nums[i]&gt;=nums[deque.getLast()])&#123;</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//尾部加入,窗口滑动</span></span><br><span class="line">            deque.addLast(i);</span><br><span class="line">            <span class="comment">//保证滑动窗口长度,并记录最大值</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=k-<span class="number">1</span>)&#123;</span><br><span class="line">                res[i-k+<span class="number">1</span>]=nums[deque.getFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解题思路:<a href="https://www.bilibili.com/video/BV1YV411o7Gr?from=search&seid=9705276703749479461" target="_blank" rel="noopener">up主xmmmmmm</a></p><h2 id="n个骰子的点数"><a href="#n个骰子的点数" class="headerlink" title="n个骰子的点数"></a>n个骰子的点数</h2><h3 id="题目描述-59"><a href="#题目描述-59" class="headerlink" title="题目描述"></a>题目描述</h3><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p><h3 id="解题思路-59"><a href="#解题思路-59" class="headerlink" title="解题思路"></a>解题思路</h3><p>嗯这道题算是简单题我晕了,ac后以后再看吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] twoSum(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][n*<span class="number">6</span>+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//一个骰子能摇出点数的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)</span><br><span class="line">            dp[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//骰子个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=<span class="number">6</span>*i;j++)<span class="comment">//i个骰子能要出的点数</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">6</span>;k++)&#123;<span class="comment">//第i个骰子要出的点数</span></span><br><span class="line">                    <span class="keyword">if</span>(j&lt;k)<span class="keyword">break</span>;</span><br><span class="line">                    dp[i][j]+=dp[i-<span class="number">1</span>][j-k];<span class="comment">//前i-1个骰子摇出的点数加上本次摇出的点数</span></span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> total=Math.pow(<span class="number">6</span>,n);</span><br><span class="line">        <span class="keyword">double</span>[] res=<span class="keyword">new</span>  <span class="keyword">double</span>[<span class="number">5</span>*n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> ind=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;=n*<span class="number">6</span>;i++)&#123;</span><br><span class="line">            res[ind++]=dp[n][i]/total;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h2><h3 id="题目描述-60"><a href="#题目描述-60" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><h3 id="解题思路-60"><a href="#解题思路-60" class="headerlink" title="解题思路"></a>解题思路</h3><p>把压栈的元素按顺序压入，当栈顶元素和出栈的第一个元素相同，则将该元素弹出，出栈列表指针后移并继续判断。最后判断出栈列表指针是否指向出栈列表的末尾即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">      Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">      <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> num:pushed)&#123;</span><br><span class="line">          stack.push(num);</span><br><span class="line">          <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;stack.peek()==popped[i])&#123;</span><br><span class="line">              stack.pop();</span><br><span class="line">              i++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h2><h3 id="题目描述-61"><a href="#题目描述-61" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p><h3 id="解题思路-61"><a href="#解题思路-61" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于二叉搜索树,后序遍历</p><p>思路就是左节点-右节点-跟节点,然后找到左右子树边界判断根节点的右子树是否满足二叉搜索树.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postorder.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(postorder,<span class="number">0</span>,postorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] postorder,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 当前区域不合法的时候直接返回true就好</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> root=postorder[r]; <span class="comment">// 当前树的根节点的值</span></span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k&lt;r&amp;&amp;postorder[k]&lt;root)&#123;  <span class="comment">//找到右节点</span></span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;r;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(postorder[i]&lt;root)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(postorder,l,k-<span class="number">1</span>)&amp;&amp;dfs(postorder,k,r-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.bilibili.com/video/BV12p4y1C7ks?from=search&seid=18233201467498089376" target="_blank" rel="noopener">解析</a></p><h2 id="1～n整数中1出现的次数"><a href="#1～n整数中1出现的次数" class="headerlink" title="1～n整数中1出现的次数"></a>1～n整数中1出现的次数</h2><h3 id="题目描述-62"><a href="#题目描述-62" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p><h3 id="解题思路-62"><a href="#解题思路-62" class="headerlink" title="解题思路"></a>解题思路</h3><p>暴力解决,超时QAQ,不管了,先贴一个大佬的方案:</p><p>求高位以及不断乘10取当前位的i需要用long表示，因为取一些很大的int的高位就溢出了.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int countDigitOne(int n) &#123;</span></span><br><span class="line"><span class="comment">        int sum=0;</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">            int x=i;</span></span><br><span class="line"><span class="comment">            while(x!=0)&#123;</span></span><br><span class="line"><span class="comment">                if(x%10==1)&#123;</span></span><br><span class="line"><span class="comment">                    sum++;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                x/=10;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return sum;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> i = <span class="number">1</span>;        <span class="comment">// 从个位开始遍历到最高位</span></span><br><span class="line"><span class="keyword">while</span>(n / i != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">long</span> high = n / (<span class="number">10</span> * i);  <span class="comment">// 高位</span></span><br><span class="line"><span class="keyword">long</span> cur = (n / i) % <span class="number">10</span>;   <span class="comment">// 当前位</span></span><br><span class="line"><span class="keyword">long</span> low = n - (n / i) * i;</span><br><span class="line"><span class="keyword">if</span>(cur == <span class="number">0</span>) &#123;</span><br><span class="line">count += high * i;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur == <span class="number">1</span>) &#123;</span><br><span class="line">count += high * i + (low + <span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">count += (high + <span class="number">1</span>) * i;</span><br><span class="line">&#125;</span><br><span class="line">i = i * <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h2><h3 id="题目描述-63"><a href="#题目描述-63" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p><h3 id="解题思路-63"><a href="#解题思路-63" class="headerlink" title="解题思路"></a>解题思路</h3><p>根节点遍历每条路径,符合的加入,然后递归遍历左右子树.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;(); </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        recur(root, sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode root, <span class="keyword">int</span> tar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        tar -= root.val;</span><br><span class="line">        <span class="keyword">if</span>(tar == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList(path));</span><br><span class="line">        recur(root.left, tar);</span><br><span class="line">        recur(root.right, tar);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, sum, <span class="number">0</span>, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, <span class="keyword">int</span> count, LinkedList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count += root.val;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == sum) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(list));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left, sum, count, list);</span><br><span class="line">        dfs(root.right, sum, count, list);</span><br><span class="line">        list.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="题目描述-64"><a href="#题目描述-64" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-64"><a href="#解题思路-64" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h3 id="题目描述-65"><a href="#题目描述-65" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-65"><a href="#解题思路-65" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h3 id="题目描述-66"><a href="#题目描述-66" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-66"><a href="#解题思路-66" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><h3 id="题目描述-67"><a href="#题目描述-67" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-67"><a href="#解题思路-67" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><h3 id="题目描述-68"><a href="#题目描述-68" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-68"><a href="#解题思路-68" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-5"><a href="#-5" class="headerlink" title=""></a></h2><h3 id="题目描述-69"><a href="#题目描述-69" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-69"><a href="#解题思路-69" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-6"><a href="#-6" class="headerlink" title=""></a></h2><h3 id="题目描述-70"><a href="#题目描述-70" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-70"><a href="#解题思路-70" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="-7"><a href="#-7" class="headerlink" title=""></a></h2><h3 id="题目描述-71"><a href="#题目描述-71" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-71"><a href="#解题思路-71" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;求职在即，《剑指offer》作为大家都推荐的一本应试宝典算法相关资料，确实也有刷一刷的必要。很多题目都比较经典，也涵盖了大多数的算法和数据结构。把自己刷题的过程做一个总结，权当是一个笔记。当前还处在未完成状态，希望自己能坚持做完。&lt;/p&gt;
&lt;p&gt;本人在LeetCode上面刷的题目，给出所有代码为本人提交Accepted后记录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://yoursite.com/2020/06/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2020/06/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-06-02T02:30:56.764Z</published>
    <updated>2020-06-05T16:49:08.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="一、基本特征"><a href="#一、基本特征" class="headerlink" title="一、基本特征"></a>一、基本特征</h3><h4 id="1-并发"><a href="#1-并发" class="headerlink" title="1. 并发"></a>1. 并发</h4><p><strong>并发</strong>是指宏观上在一段时间内能同时运行多个程序，而<strong>并行</strong>则指同一时刻能运行多个指令。</p><p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</p><p>操作系统通过引入进程和线程，使得程序能够并发运行。</p><a id="more"></a><h4 id="2-共享"><a href="#2-共享" class="headerlink" title="2. 共享"></a>2. 共享</h4><p>共享是指系统中的资源可以被多个并发进程共同使用。</p><p>有两种共享方式：<strong>互斥共享</strong>和<strong>同时共享</strong>。</p><p>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</p><h4 id="3-虚拟"><a href="#3-虚拟" class="headerlink" title="3. 虚拟"></a>3. 虚拟</h4><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p><p>主要有两种虚拟技术：<strong>时（时间）分复用技术</strong>和<strong>空（空间）分复用技术</strong>。</p><p>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p><p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p><h4 id="4-异步"><a href="#4-异步" class="headerlink" title="4. 异步"></a>4. 异步</h4><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p><h3 id="二、基本功能"><a href="#二、基本功能" class="headerlink" title="二、基本功能"></a>二、基本功能</h3><h4 id="1-进程管理"><a href="#1-进程管理" class="headerlink" title="1. 进程管理"></a>1. 进程管理</h4><p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p><h4 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h4><p>内存分配、地址映射、内存保护与共享、虚拟内存等。</p><h4 id="3-文件管理"><a href="#3-文件管理" class="headerlink" title="3. 文件管理"></a>3. 文件管理</h4><p>文件存储空间的管理、目录管理、文件读写管理和保护等。</p><h4 id="4-设备管理"><a href="#4-设备管理" class="headerlink" title="4. 设备管理"></a>4. 设备管理</h4><p>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</p><p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p><h3 id="三、系统调用"><a href="#三、系统调用" class="headerlink" title="三、系统调用"></a>三、系统调用</h3><p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5tzwoa1bj30kx0cu0uv.jpg" alt="img"></p><p>Linux 的系统调用主要有以下这些：</p><table><thead><tr><th>Task</th><th>Commands</th></tr></thead><tbody><tr><td>进程控制</td><td>fork(); exit(); wait();</td></tr><tr><td>进程通信</td><td>pipe(); shmget(); mmap();</td></tr><tr><td>文件操作</td><td>open(); read(); write();</td></tr><tr><td>设备操作</td><td>ioctl(); read(); write();</td></tr><tr><td>信息维护</td><td>getpid(); alarm(); sleep();</td></tr><tr><td>安全</td><td>chmod(); umask(); chown();</td></tr></tbody></table><h3 id="四、大内核和微内核"><a href="#四、大内核和微内核" class="headerlink" title="四、大内核和微内核"></a>四、大内核和微内核</h3><h4 id="1-大内核"><a href="#1-大内核" class="headerlink" title="1. 大内核"></a>1. 大内核</h4><p>大内核是将操作系统功能作为一个紧密结合的整体放到内核。</p><p>由于各模块共享信息，因此有很高的性能。</p><h4 id="2-微内核"><a href="#2-微内核" class="headerlink" title="2. 微内核"></a>2. 微内核</h4><p>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。</p><p>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。</p><p>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5tzxjpyyj30gx0870v1.jpg" alt="img"></p><h3 id="五、中断分类"><a href="#五、中断分类" class="headerlink" title="五、中断分类"></a>五、中断分类</h3><h4 id="1-外中断"><a href="#1-外中断" class="headerlink" title="1. 外中断"></a>1. 外中断</h4><p>由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p><h4 id="2-异常"><a href="#2-异常" class="headerlink" title="2. 异常"></a>2. 异常</h4><p>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p><h4 id="3-陷入"><a href="#3-陷入" class="headerlink" title="3. 陷入"></a>3. 陷入</h4><p>在用户程序中使用系统调用。</p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="一、进程与线程"><a href="#一、进程与线程" class="headerlink" title="一、进程与线程"></a>一、进程与线程</h3><h4 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h4><p><strong>进程是资源分配的基本单位。</strong></p><p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p><p>下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5tzy18jvj30mb0840t3.jpg" alt="img"></p><h4 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h4><p><strong>线程是独立调度的基本单位。</strong></p><p>一个进程中可以有多个线程，它们共享进程资源。</p><p>QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5tzyx7vnj30a708g0sm.jpg" alt="img"></p><h4 id="3-进程与线程的区别"><a href="#3-进程与线程的区别" class="headerlink" title="3. 进程与线程的区别"></a>3. 进程与线程的区别</h4><p>线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。</p><ul><li><strong>根本区别：</strong>进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</li><li><strong>资源开销：</strong>每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</li><li><strong>包含关系：</strong>如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</li><li><strong>内存分配：</strong>同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的</li><li><strong>影响关系：</strong>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</li><li><strong>执行过程：</strong>每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</li></ul><h4 id="4-多进程和多线程的选择"><a href="#4-多进程和多线程的选择" class="headerlink" title="4. 多进程和多线程的选择"></a>4. 多进程和多线程的选择</h4><p><img src="C:/Users/Slimshady/AppData/Roaming/Typora/typora-user-images/image-20200420104050516.png" alt="image-20200420104050516"></p><ol><li><p>需要频繁创建销毁的优先用线程</p><p>原因请看上面的对比。</p><p>这种原则最常见的应用就是Web服务器了，来一个连接建立一个线程，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的</p></li><li><p>需要进行大量计算的优先使用线程</p><p>所谓大量计算，当然就是要耗费很多CPU，切换频繁了，这种情况下线程是最合适的。</p><p>这种原则最常见的是图像处理、算法处理。</p></li><li><p>强相关的处理用线程，弱相关的处理用进程</p><p>什么叫强相关、弱相关？理论上很难定义，给个简单的例子就明白了。</p><p>一般的Server需要完成如下任务：消息收发、消息处理。“消息收发”和“消息处理”就是弱相关的任务，而“消息处理”里面可能又分为“消息解码”、“业务处理”，这两个任务相对来说相关性就要强多了。因此“消息收发”和“消息处理”可以分进程设计，“消息解码”、“业务处理”可以分线程设计。</p><p>当然这种划分方式不是一成不变的，也可以根据实际情况进行调整。</p></li><li><p>可能要扩展到多机分布的用进程，多核分布的用线程</p><p>原因请看上面对比。</p></li><li><p>都满足需求的情况下，用你最熟悉、最拿手的方式</p><p>至于“数据共享、同步”、“编程、调试”、“可靠性”这几个维度的所谓的“复杂、简单”应该怎么取舍，我只能说：没有明确的选择方法。但我可以告诉你一个选择原则：如果多进程和多线程都能够满足要求，那么选择你最熟悉、最拿手的那个。</p></li></ol><h3 id="二、进程状态的切换"><a href="#二、进程状态的切换" class="headerlink" title="二、进程状态的切换"></a>二、进程状态的切换</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5tzztfmzj30iv0c60t1.jpg" alt="img"></p><ul><li>就绪状态（ready）：等待被调度</li><li>运行状态（running）</li><li>阻塞状态（waiting）：等待资源</li></ul><p>应该注意以下内容：</p><ul><li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li><li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li></ul><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p><h4 id="1-批处理系统"><a href="#1-批处理系统" class="headerlink" title="1. 批处理系统"></a>1. 批处理系统</h4><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p><p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong></p><p><strong>非抢占式</strong>的调度算法，按照请求的顺序进行调度。</p><p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p><p><strong>1.2 短作业优先 shortest job first（SJF）</strong></p><p><strong>非抢占式</strong>的调度算法，按估计运行时间最短的顺序进行调度。</p><p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p><p><strong>1.3 最短剩余时间优先 shortest remaining time next（SRTN）</strong></p><p>最短作业优先的<strong>抢占式</strong>版本，按剩余运行时间的顺序进行调度。</p><p>当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p><h4 id="2-交互式系统"><a href="#2-交互式系统" class="headerlink" title="2. 交互式系统"></a>2. 交互式系统</h4><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p><p><strong>2.1 时间片轮转</strong></p><p>将所有就绪进程按 <strong>FCFS</strong> 的原则排成一个<strong>队列</strong>，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p><p>时间片轮转算法的效率和时间片的大小有很大关系：</p><ul><li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li><li>而如果时间片过长，那么实时性就不能得到保证。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u008u0zj309x03f0sm.jpg" alt="img"></p><p><strong>2.2 优先级调度</strong></p><p>为每个进程分配一个<strong>优先级</strong>，按优先级进行调度。</p><p>为了防止低优先级的进程永远等不到调度，可以<strong>随着时间的推移增加等待进程的优先级</strong>。</p><p><strong>2.3 多级反馈队列</strong></p><p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p><p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u016h4tj30c60860t5.jpg" alt="img"></p><h4 id="3-实时系统"><a href="#3-实时系统" class="headerlink" title="3. 实时系统"></a>3. 实时系统</h4><p>实时系统要求一个请求在一个确定时间内得到响应。</p><p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p><h3 id="三、进程同步"><a href="#三、进程同步" class="headerlink" title="三、进程同步"></a>三、进程同步</h3><h4 id="1-临界区"><a href="#1-临界区" class="headerlink" title="1. 临界区"></a>1. 临界区</h4><p><strong>对临界资源进行访问</strong>的那段代码称为临界区。</p><p>为了互斥访问临界资源，<strong>每个进程在进入临界区之前，需要先进行检查</strong>。</p><h4 id="2-同步与互斥"><a href="#2-同步与互斥" class="headerlink" title="2. 同步与互斥"></a>2. 同步与互斥</h4><ul><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li></ul><h4 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h4><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p><ul><li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li><li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li></ul><p>down 和 up 操作需要被设计成<strong>原语</strong>，不可分割，通常的做法是在<strong>执行这些操作的时候屏蔽中断</strong>。</p><p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用信号量实现生产者-消费者问题</strong></p><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p><p>因为缓冲区属于临界资源，因此需要使用一个互斥量 <code>mutex</code> 来控制对缓冲区的互斥访问。</p><p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p><p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="keyword">int</span> item = produce_item();</span><br><span class="line">        down(&amp;empty);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;full);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        <span class="keyword">int</span> item = remove_item();</span><br><span class="line">        consume_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-管程"><a href="#4-管程" class="headerlink" title="4. 管程"></a>4. 管程</h4><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p><p>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    integer i;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">remove</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br></pre></td></tr></table></figure><p>管程有一个重要特性：<strong>在一个时刻只能有一个进程使用管程</strong>。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p><p>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p><p><strong>使用管程实现生产者-消费者问题</strong></p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管程</span></span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;</span><br><span class="line">    integer count := <span class="number">0</span>;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(item: integer)</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = N <span class="keyword">then</span> wait(full);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count := count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">1</span> <span class="keyword">then</span> signal(empty);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>:</span> integer;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">0</span> <span class="keyword">then</span> wait(empty);</span><br><span class="line">        remove = remove_item;</span><br><span class="line">        count := count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = N -<span class="number">1</span> <span class="keyword">then</span> signal(full);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">producer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">produce_item</span>;</span></span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">ProducerConsumer</span>.<span class="title">remove</span>;</span></span><br><span class="line">        consume_item(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h3 id="四、经典同步问题"><a href="#四、经典同步问题" class="headerlink" title="四、经典同步问题"></a>四、经典同步问题</h3><h4 id="1-生产者消费者问题"><a href="#1-生产者消费者问题" class="headerlink" title="1. 生产者消费者问题"></a>1. 生产者消费者问题</h4><p>生产者和消费者问题前面已经讨论过了。</p><h4 id="2-哲学家进餐问题"><a href="#2-哲学家进餐问题" class="headerlink" title="2. 哲学家进餐问题"></a>2. 哲学家进餐问题</h4><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a9077f06-7584-4f2b-8c20-3a8e46928820.jpg" alt="img" style="zoom:50%;" /><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p><p>下面是一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think();</span><br><span class="line">        take(i);       <span class="comment">// 拿起左边的筷子</span></span><br><span class="line">        take((i+<span class="number">1</span>)%N); <span class="comment">// 拿起右边的筷子</span></span><br><span class="line">        eat();</span><br><span class="line">        <span class="built_in">put</span>(i);</span><br><span class="line">        <span class="built_in">put</span>((i+<span class="number">1</span>)%N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止死锁的发生，可以设置两个条件：</p><ul><li>必须同时拿起左右两根筷子；</li><li>只有在两个邻居都没有进餐的情况下才允许进餐。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT (i + N - 1) % N <span class="comment">// 左邻居</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT (i + 1) % N    <span class="comment">// 右邻居</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUNGRY   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EATING   2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line"><span class="keyword">int</span> state[N];                <span class="comment">// 跟踪每个哲学家的状态</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;         <span class="comment">// 临界区的互斥，临界区是 state 数组，对其修改需要互斥</span></span><br><span class="line">semaphore s[N];              <span class="comment">// 每个哲学家一个信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think(i);</span><br><span class="line">        take_two(i);</span><br><span class="line">        eat(i);</span><br><span class="line">        put_two(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take_two</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = HUNGRY;</span><br><span class="line">    check(i);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">    down(&amp;s[i]); <span class="comment">// 只有收到通知之后才可以开始吃，否则会一直等下去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_two</span><span class="params">(i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = THINKING;</span><br><span class="line">    check(LEFT); <span class="comment">// 尝试通知左右邻居，自己吃完了，你们可以开始吃了</span></span><br><span class="line">    check(RIGHT);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = EATING;</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查两个邻居是否都没有用餐，如果是的话，就 up(&amp;s[i])，使得 down(&amp;s[i]) 能够得到通知并继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(i)</span> </span>&#123;         </span><br><span class="line">    <span class="keyword">if</span>(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123;</span><br><span class="line">        state[i] = EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-读者-写者问题"><a href="#3-读者-写者问题" class="headerlink" title="3. 读者-写者问题"></a>3. 读者-写者问题</h4><p>允许多个进程同时对数据进行读操作，但是不允许<strong>读和写</strong>以及<strong>写和写</strong>操作同时发生。</p><p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore count_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) down(&amp;data_mutex); <span class="comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span></span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">        <span class="built_in">read</span>();</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) up(&amp;data_mutex);</span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;data_mutex);</span><br><span class="line">        <span class="built_in">write</span>();</span><br><span class="line">        up(&amp;data_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、进程通信"><a href="#五、进程通信" class="headerlink" title="五、进程通信"></a>五、进程通信</h3><p>进程同步与进程通信很容易混淆，它们的区别在于：</p><ul><li>进程同步：控制多个进程按一定顺序执行；</li><li>进程通信：进程间传输信息。</li></ul><p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p><h4 id="1-管道"><a href="#1-管道" class="headerlink" title="1. 管道"></a>1. 管道</h4><p>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>它具有以下限制：</p><ul><li>只支持半双工通信（单向交替传输）；</li><li>只能在父子进程或者兄弟进程中使用。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u029s7pj30e907t0sr.jpg" alt="img"></p><h4 id="2-FIFO"><a href="#2-FIFO" class="headerlink" title="2. FIFO"></a>2. FIFO</h4><p>也称为命名管道，去除了管道只能在父子进程中使用的限制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifoat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u032b2mj30hr0cc0sz.jpg" alt="img"></p><h4 id="3-消息队列"><a href="#3-消息队列" class="headerlink" title="3. 消息队列"></a>3. 消息队列</h4><p>相比于 FIFO，消息队列具有以下优点：</p><ul><li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li><li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li><li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li></ul><h4 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4. 信号量"></a>4. 信号量</h4><p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p><h4 id="5-共享存储"><a href="#5-共享存储" class="headerlink" title="5. 共享存储"></a>5. 共享存储</h4><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p><p>需要使用信号量用来同步对共享存储的访问。</p><p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。</p><h4 id="6-套接字"><a href="#6-套接字" class="headerlink" title="6. 套接字"></a>6. 套接字</h4><p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="一、必要条件"><a href="#一、必要条件" class="headerlink" title="一、必要条件"></a>一、必要条件</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u03lmccj30fk0730t2.jpg" alt="img"></p><ul><li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li><li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li><li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li><li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li></ul><h3 id="二、处理方法"><a href="#二、处理方法" class="headerlink" title="二、处理方法"></a>二、处理方法</h3><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p><p><strong>破坏互斥条件</strong></p><p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p><p><strong>破坏请求与保持条件</strong></p><p>一次性申请所有的资源。</p><p><strong>破坏不剥夺条件</strong></p><p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p><strong>破坏循环等待条件</strong></p><p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p><p>主要有以下四种方法：</p><ul><li>鸵鸟策略</li><li>死锁检测与死锁恢复</li><li>死锁预防</li><li>死锁避免</li></ul><h3 id="三、鸵鸟策略"><a href="#三、鸵鸟策略" class="headerlink" title="三、鸵鸟策略"></a>三、鸵鸟策略</h3><p>把头埋在沙子里，假装根本没发生问题。</p><p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p><p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p><p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p><h3 id="四、死锁检测与死锁恢复"><a href="#四、死锁检测与死锁恢复" class="headerlink" title="四、死锁检测与死锁恢复"></a>四、死锁检测与死锁恢复</h3><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p><h4 id="1-每种类型一个资源的死锁检测"><a href="#1-每种类型一个资源的死锁检测" class="headerlink" title="1. 每种类型一个资源的死锁检测"></a>1. 每种类型一个资源的死锁检测</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u04g7o6j30gl08h0t5.jpg" alt="img"></p><p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p><p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p><p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p><h4 id="2-每种类型多个资源的死锁检测"><a href="#2-每种类型多个资源的死锁检测" class="headerlink" title="2. 每种类型多个资源的死锁检测"></a>2. 每种类型多个资源的死锁检测</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u05ff8aj30cg0640sy.jpg" alt="img"></p><p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p><ul><li>E 向量：资源总量</li><li>A 向量：资源剩余量</li><li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li><li>R 矩阵：每个进程请求的资源数量</li></ul><p>进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。</p><p>算法总结如下：</p><p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p><ol><li>寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。</li><li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li><li>如果没有这样一个进程，算法终止。</li></ol><h4 id="3-死锁恢复"><a href="#3-死锁恢复" class="headerlink" title="3. 死锁恢复"></a>3. 死锁恢复</h4><ul><li>利用抢占恢复</li><li>利用回滚恢复</li><li>通过杀死进程恢复</li></ul><h3 id="五、死锁预防"><a href="#五、死锁预防" class="headerlink" title="五、死锁预防"></a>五、死锁预防</h3><p>在程序运行之前预防发生死锁。</p><h4 id="1-破坏互斥条件"><a href="#1-破坏互斥条件" class="headerlink" title="1. 破坏互斥条件"></a>1. 破坏互斥条件</h4><p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p><h4 id="2-破坏占有和等待条件"><a href="#2-破坏占有和等待条件" class="headerlink" title="2. 破坏占有和等待条件"></a>2. 破坏占有和等待条件</h4><p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p><h4 id="3-破坏不可抢占条件"><a href="#3-破坏不可抢占条件" class="headerlink" title="3. 破坏不可抢占条件"></a>3. 破坏不可抢占条件</h4><h4 id="4-破坏环路等待"><a href="#4-破坏环路等待" class="headerlink" title="4. 破坏环路等待"></a>4. 破坏环路等待</h4><p>给资源统一编号，进程只能按编号顺序来请求资源。</p><h3 id="六、死锁避免"><a href="#六、死锁避免" class="headerlink" title="六、死锁避免"></a>六、死锁避免</h3><p>在程序运行时避免发生死锁。</p><h4 id="1-安全状态"><a href="#1-安全状态" class="headerlink" title="1. 安全状态"></a>1. 安全状态</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u06cwtmj30hz04y0t3.jpg" alt="img"></p><p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p><p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p><p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p><h4 id="2-单个资源的银行家算法"><a href="#2-单个资源的银行家算法" class="headerlink" title="2. 单个资源的银行家算法"></a>2. 单个资源的银行家算法</h4><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u06weo9j30fr06f0t3.jpg" alt="img"></p><p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p><h4 id="3-多个资源的银行家算法"><a href="#3-多个资源的银行家算法" class="headerlink" title="3. 多个资源的银行家算法"></a>3. 多个资源的银行家算法</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u07vflaj30e707m0tb.jpg" alt="img"></p><p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。</p><p>检查一个状态是否安全的算法如下：</p><ul><li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li><li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li><li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li></ul><p>如果一个状态不是安全的，需要拒绝进入这个状态。</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="一、虚拟内存"><a href="#一、虚拟内存" class="headerlink" title="一、虚拟内存"></a>一、虚拟内存</h3><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p><p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p><p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u08o06yj30dn0c90to.jpg" alt="img"></p><h3 id="二、分页系统地址映射"><a href="#二、分页系统地址映射" class="headerlink" title="二、分页系统地址映射"></a>二、分页系统地址映射</h3><p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p><p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p><p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u0952b7j30hv0jc0uh.jpg" alt="img"></p><h3 id="三、页面置换算法"><a href="#三、页面置换算法" class="headerlink" title="三、页面置换算法"></a>三、页面置换算法</h3><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p><p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p><p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p><h4 id="1-最佳OPT"><a href="#1-最佳OPT" class="headerlink" title="1. 最佳OPT"></a>1. 最佳OPT</h4><blockquote><p>  OPT, Optimal replacement algorithm</p></blockquote><p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p><p>是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p><p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1</span><br></pre></td></tr></table></figure><p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</p><h4 id="2-最近最久未使用LRU"><a href="#2-最近最久未使用LRU" class="headerlink" title="2. 最近最久未使用LRU"></a>2. 最近最久未使用LRU</h4><blockquote><p>  LRU, Least Recently Used</p></blockquote><p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p><p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p><p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4，7，0，7，1，0，1，2，1，2，6</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u0a3qujj30ex04m0su.jpg" alt="img"></p><h4 id="3-最近未使用NRU"><a href="#3-最近未使用NRU" class="headerlink" title="3. 最近未使用NRU"></a>3. 最近未使用NRU</h4><blockquote><p>  NRU, Not Recently Used</p></blockquote><p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：</p><ul><li>R=0，M=0</li><li>R=0，M=1</li><li>R=1，M=0</li><li>R=1，M=1</li></ul><p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p><p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p><h4 id="4-先进先出FIFO"><a href="#4-先进先出FIFO" class="headerlink" title="4. 先进先出FIFO"></a>4. 先进先出FIFO</h4><blockquote><p>  FIFO, First In First Out</p></blockquote><p>选择换出的页面是最先进入的页面。</p><p>该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。</p><h4 id="5-第二次机会算法"><a href="#5-第二次机会算法" class="headerlink" title="5. 第二次机会算法"></a>5. 第二次机会算法</h4><p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p><p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u0b2nzuj30k008o0t1.jpg" alt="img"></p><h4 id="6-时钟"><a href="#6-时钟" class="headerlink" title="6. 时钟"></a>6. 时钟</h4><blockquote><p>  Clock</p></blockquote><p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u0bzbdnj30fp08w0ta.jpg" alt="img"></p><h3 id="四、分段"><a href="#四、分段" class="headerlink" title="四、分段"></a>四、分段</h3><p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p><p>下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u0chstcj30ck09n0t8.jpg" alt="img"></p><p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u0cwm4rj30g507y0t0.jpg" alt="img"></p><h3 id="五、段页式"><a href="#五、段页式" class="headerlink" title="五、段页式"></a>五、段页式</h3><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p><h3 id="六、分页与分段的比较"><a href="#六、分页与分段的比较" class="headerlink" title="六、分页与分段的比较"></a>六、分页与分段的比较</h3><ul><li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</li><li>地址空间的维度：分页是一维地址空间，分段是二维的。</li><li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li><li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li></ul><h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h3 id="一、磁盘结构"><a href="#一、磁盘结构" class="headerlink" title="一、磁盘结构"></a>一、磁盘结构</h3><ul><li>盘面（Platter）：一个磁盘有多个盘面；</li><li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li><li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</li><li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li><li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li><li>主轴（Spindle）：使整个盘面转动。</li></ul><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/014fbc4d-d873-4a12-b160-867ddaed9807.jpg" alt="img" style="zoom:67%;" /><h3 id="二、磁盘调度算法"><a href="#二、磁盘调度算法" class="headerlink" title="二、磁盘调度算法"></a>二、磁盘调度算法</h3><p>读写一个磁盘块的时间的影响因素有：</p><ul><li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li><li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li><li>实际的数据传输时间</li></ul><p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p><h4 id="1-先来先服务FCFS"><a href="#1-先来先服务FCFS" class="headerlink" title="1. 先来先服务FCFS"></a>1. 先来先服务FCFS</h4><blockquote><p>  FCFS, First Come First Served</p></blockquote><p>按照磁盘<strong>请求的顺序</strong>进行调度。</p><p>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p><h4 id="2-最短寻道时间优先SSTF"><a href="#2-最短寻道时间优先SSTF" class="headerlink" title="2. 最短寻道时间优先SSTF"></a>2. 最短寻道时间优先SSTF</h4><blockquote><p>  SSTF, Shortest Seek Time First</p></blockquote><p>优先调度与当前磁头所在磁道距离最近的磁道。</p><p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，<strong>两端的磁道请求更容易出现饥饿现象</strong>。</p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4e2485e4-34bd-4967-9f02-0c093b797aaa.png" alt="img" style="zoom:67%;" /><h4 id="3-电梯算法SCAN"><a href="#3-电梯算法SCAN" class="headerlink" title="3. 电梯算法SCAN"></a>3. 电梯算法SCAN</h4><blockquote><p>  SCAN</p></blockquote><p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p><p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p><p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/271ce08f-c124-475f-b490-be44fedc6d2e.png" alt="img" style="zoom: 67%;" /><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="一、编译系统"><a href="#一、编译系统" class="headerlink" title="一、编译系统"></a>一、编译系统</h3><p>以下是一个 <code>hello.c</code> 程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Unix 系统上，由编译器把源文件转换为目标文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br></pre></td></tr></table></figure><p>这个过程大致如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u0duo29j30uk05o0tu.jpg" alt="img"></p><ul><li>预处理阶段：处理以 # 开头的预处理命令；</li><li>编译阶段：翻译成汇编文件；</li><li>汇编阶段：将汇编文件翻译成可重定位目标文件；</li><li>链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得 <a href="..\网络\Socket.md">Socket.md</a> 到最终的可执行目标文件。</li></ul><h3 id="二、静态链接"><a href="#二、静态链接" class="headerlink" title="二、静态链接"></a>二、静态链接</h3><p>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p><ul><li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li><li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u0fay7mj30cc09b0td.jpg" alt="img"></p><h3 id="三、目标文件"><a href="#三、目标文件" class="headerlink" title="三、目标文件"></a>三、目标文件</h3><ul><li>可执行目标文件：可以直接在内存中执行；</li><li>可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；</li><li>共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；</li></ul><h3 id="四、动态链接"><a href="#四、动态链接" class="headerlink" title="四、动态链接"></a>四、动态链接</h3><p>静态库有以下两个问题：</p><ul><li>当静态库更新时那么整个程序都要重新进行链接；</li><li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li></ul><p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p><ul><li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li><li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u0gml0uj30cp0di0tl.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;h3 id=&quot;一、基本特征&quot;&gt;&lt;a href=&quot;#一、基本特征&quot; class=&quot;headerlink&quot; title=&quot;一、基本特征&quot;&gt;&lt;/a&gt;一、基本特征&lt;/h3&gt;&lt;h4 id=&quot;1-并发&quot;&gt;&lt;a href=&quot;#1-并发&quot; class=&quot;headerlink&quot; title=&quot;1. 并发&quot;&gt;&lt;/a&gt;1. 并发&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;并发&lt;/strong&gt;是指宏观上在一段时间内能同时运行多个程序，而&lt;strong&gt;并行&lt;/strong&gt;则指同一时刻能运行多个指令。&lt;/p&gt;
&lt;p&gt;并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。&lt;/p&gt;
&lt;p&gt;操作系统通过引入进程和线程，使得程序能够并发运行。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java集合</title>
    <link href="http://yoursite.com/2020/05/31/java%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2020/05/31/java%E9%9B%86%E5%90%88/</id>
    <published>2020-05-31T00:53:32.644Z</published>
    <updated>2020-06-08T01:03:10.022Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集合分类"><a href="#集合分类" class="headerlink" title="集合分类"></a>集合分类</h2><p>Java 容器分为 Collection 和 Map 两大类：</p><p>Collection集合主要有List和Set两大接口</p><ul><li>Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</li><li>List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList。<br>Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</li></ul><a id="more"></a><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul><li><p>Arraylist： Object数组</p></li><li><p>Vector： Object数组</p></li><li><p>LinkedList： 双向循环链表</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3></li><li><p>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</p></li><li><p>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。</p></li><li><p>TreeSet（有序，唯一）： 红黑树（自平衡的排序二叉树）。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3></li><li><p>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为<strong>红黑树</strong>，以减少搜索时间。</p></li><li><p>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，<strong>增加了一条双向链表</strong>，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</p></li><li><p>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。</p></li><li><p>TreeMap： 红黑树（自平衡的排序二叉树）</p><h2 id="线程安全的集合类"><a href="#线程安全的集合类" class="headerlink" title="线程安全的集合类"></a>线程安全的集合类</h2></li><li><p>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。</p></li><li><p>stack：堆栈类，先进后出。</p></li><li><p>hashtable：就比hashmap多了个线程安全。</p></li><li><p>enumeration：枚举，相当于迭代器。</p><h2 id="快速失败-fail-fast-和安全失败-fail-safe"><a href="#快速失败-fail-fast-和安全失败-fail-safe" class="headerlink" title="快速失败(fail-fast)和安全失败(fail-safe)"></a>快速失败(fail-fast)和安全失败(fail-safe)</h2><h3 id="快速失败（fail—fast）"><a href="#快速失败（fail—fast）" class="headerlink" title="快速失败（fail—fast）"></a>快速失败（fail—fast）</h3></li></ul><p>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。</p><p>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p>注意：这里异常的抛出条件是检测到 modCount != expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</p><p>场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</p><h3 id="安全失败（fail—safe）"><a href="#安全失败（fail—safe）" class="headerlink" title="安全失败（fail—safe）"></a>安全失败（fail—safe）</h3><p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p><p>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p><p>缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p><p>场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p><h2 id="集合和数组的区别"><a href="#集合和数组的区别" class="headerlink" title="集合和数组的区别"></a>集合和数组的区别</h2><ul><li>数组是固定长度的；集合可变长度的。</li><li>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</li><li>数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。<h2 id="使用集合框架的好处"><a href="#使用集合框架的好处" class="headerlink" title="使用集合框架的好处"></a>使用集合框架的好处</h2></li></ul><ol><li>容量自增长；</li><li>提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量；</li><li>允许不同 API 之间的互操作，API之间可以来回传递集合；</li><li>可以方便地扩展或改写集合，提高代码复用性和可操作性;</li><li>通过使用JDK自带的集合类，可以降低代码维护和学习新API成本。<h2 id="确保一个集合不能被修改"><a href="#确保一个集合不能被修改" class="headerlink" title="确保一个集合不能被修改"></a>确保一个集合不能被修改</h2>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java.lang. UnsupportedOperationException 异常：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list. add(<span class="string">"x"</span>);</span><br><span class="line">Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);</span><br><span class="line">clist. add(<span class="string">"y"</span>); <span class="comment">// 运行时此行报错</span></span><br><span class="line">System. out. println(list. size());</span><br></pre></td></tr></table></figure><h2 id="comparable-和-comparator"><a href="#comparable-和-comparator" class="headerlink" title="comparable 和 comparator"></a>comparable 和 comparator</h2><ul><li>comparable接口出自java.lang包，它有一个compareTo(Object obj)方法用来排序</li><li>comparator接口出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序<br>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort()。</li></ul><h2 id="Collection-和-Collections"><a href="#Collection-和-Collections" class="headerlink" title="Collection 和 Collections"></a>Collection 和 Collections</h2><ul><li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li><li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。<br>Collections 工具类的 sort 方法有两种重载的形式，</li></ul><ol><li><p>第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较。</p></li><li><p>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。</p></li></ol><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><h3 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器 Iterator"></a>迭代器 Iterator</h3><p>Iterator 接口提供遍历任何 <strong>Collection</strong> 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p><h4 id="单向遍历"><a href="#单向遍历" class="headerlink" title="单向遍历"></a>单向遍历</h4><p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    String obj = it.next();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Iterator-和-ListIterator"><a href="#Iterator-和-ListIterator" class="headerlink" title="Iterator 和 ListIterator"></a>Iterator 和 ListIterator</h4><ul><li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li><li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历。</li><li>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。<h3 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h3><h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4></li></ul><ol><li><p>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。</p></li><li><p>迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。</p></li><li><p>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</p></li></ol><p><strong>RandomAccess</strong></p><p>Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。</p><ul><li><p>如果一个数据集合实现了该接口，就意味着它支持 RandomAccess，按位置读取元素的平均时间复杂度为 <strong>O(1)</strong>，如ArrayList。</p></li><li><p>如果没有实现该接口，表示不支持 RandomAccess，如LinkedList。</p></li><li><p>推荐的做法就是，支持 RandomAccess 的列表可用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。</p><h4 id="ArrayList-的优缺点"><a href="#ArrayList-的优缺点" class="headerlink" title="ArrayList 的优缺点"></a>ArrayList 的优缺点</h4><p>ArrayList的优点如下：</p></li><li><p>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。</p></li><li><p>ArrayList 在顺序添加一个元素的时候非常方便。<br>ArrayList 的缺点如下：</p></li><li><p>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。</p></li><li><p>插入元素的时候，也需要做一次元素复制操作，缺点同上。<br>ArrayList 比较适合<strong>顺序添加、随机访问</strong>的场景。</p></li></ul><h4 id="数组和-List-的转换"><a href="#数组和-List-的转换" class="headerlink" title="数组和 List 的转换"></a>数组和 List 的转换</h4><ul><li>数组转 List：使用 Arrays. asList(array) 进行转换。</li><li>List 转数组：使用 List 自带的 toArray() 方法。<h4 id="ArrayList-和-LinkedList-区别"><a href="#ArrayList-和-LinkedList-区别" class="headerlink" title="ArrayList 和 LinkedList 区别"></a>ArrayList 和 LinkedList 区别</h4></li><li>数据结构实现：ArrayList 是<strong>动态数组</strong>的数据结构实现，而 LinkedList 是<strong>双向链表</strong>的数据结构实现。</li><li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li><li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li><li>内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li><li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全。<br>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</li></ul><h4 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h4><p>ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。transient 的作用是说不希望 elementData 数组被序列化，每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。</p><h3 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h3><h4 id="HashSet-的实现原理"><a href="#HashSet-的实现原理" class="headerlink" title="HashSet 的实现原理"></a>HashSet 的实现原理</h4><p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p><h4 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复"></a>HashSet 如何检查重复</h4><p>向HashSet 中add()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equals()方法比较。 HashSet 中的add()方法会使用HashMap 的put()方法。</p><p>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V，所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span></span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode() 与 equals()"></a>hashCode() 与 equals()</h4><ul><li>如果两个对象相等，则hashcode()一定也是相同的</li><li>两个对象相等,对两个equals()方法返回true</li><li>两个对象有相同的hashcode()值，它们不一定是相等的<h4 id="HashSet与HashMap的区别"><a href="#HashSet与HashMap的区别" class="headerlink" title="HashSet与HashMap的区别"></a>HashSet与HashMap的区别</h4><table><thead><tr><th>HashMap</th><th>HashSet</th></tr></thead><tbody><tr><td>实现了Map接口</td><td>实现Set接口</td></tr><tr><td>存储键值对</td><td>仅存储对象</td></tr><tr><td>调用put()向map中添加元素</td><td>调用add()方法向Set中添加元素</td></tr><tr><td>HashMap使用键(Key)计算hashcode</td><td>hashSet使用成员对象来计算hashcode值</td></tr><tr><td>较快，因为它是使用唯一的键获取对象</td><td>HashSet较HashMap来说比较慢</td></tr><tr><td>### Queue</td><td></td></tr><tr><td>#### 阻塞队列BlockingQueue</td><td></td></tr><tr><td>Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现==生产者-消费者模式==。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</td><td></td></tr></tbody></table></li></ul><h4 id="poll-和-remove-区别"><a href="#poll-和-remove-区别" class="headerlink" title="poll()和 remove()区别"></a>poll()和 remove()区别</h4><p>0相同点：都是返回第一个元素，并在队列中删除返回的对象。<br>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</p><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><h4 id="HashMap-的实现原理"><a href="#HashMap-的实现原理" class="headerlink" title="HashMap 的实现原理"></a>HashMap 的实现原理</h4><p>put元素时，利用key的hashCode值计算出当前对象的元素在数组中的下标存储时，如果出现hash值相同的key，此时有两种情况：</p><ol><li>如果key相同，则覆盖原始值；</li><li>如果key不同（出现冲突），则将当前的key-value放入链表中<br>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</li></ol><h4 id="put方法的具体流程"><a href="#put方法的具体流程" class="headerlink" title="put方法的具体流程"></a>put方法的具体流程</h4><p>put的时候，首先计算 key的hash值，这里调用了 hash方法，hash方法实际是让key.hashCode()与key.hashCode()&gt;&gt;&gt;16进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：==高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞==。按照函数注释，因为bucket数组大小是2的幂，计算下标index = (table.length - 1) &amp; hash，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。</p><h4 id="HashMap的扩容操作"><a href="#HashMap的扩容操作" class="headerlink" title="HashMap的扩容操作"></a>HashMap的扩容操作</h4><ul><li><p>在jdk1.8中，在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；</p></li><li><p>每次扩展的时候，都是扩展2倍；</p></li><li><p>扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。<br>resize() 方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12)，这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方：</p></li><li><p>在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发；</p></li><li><p>在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上。</p><h4 id="Hash冲突"><a href="#Hash冲突" class="headerlink" title="Hash冲突"></a>Hash冲突</h4></li></ul><p><strong>哈希的概念</strong></p><p>Hash，一般翻译为“散列”，也有直接音译为“哈希”的，就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p><p>所有散列函数都有如下一个基本特性：<strong>根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同</strong>。</p><p><strong>HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</strong></p><p>hashCode()方法返回的是int整数类型，其范围为-(2 ^ 31)(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过hashCode()计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</p><p>所以HashMap自己实现了自己的hash()方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均。</p><p>在保证数组长度为2的幂次方的时候，使用hash()运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；</p><p><strong>HashMap 的长度为什么是2的幂次方</strong></p><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</p><p>这个算法应该如何设计呢？</p><p>我们首先可能会想到采用取余的操作来实现。但是，重点来了：取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方）， 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</p><p><strong>那为什么是两次扰动呢？</strong></p><p>这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性和均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的。</p><p><strong>解决hash冲突的方式</strong></p><p><em>JDK1.8之前</em></p><p>JDK1.8之前采用的是拉链法。</p><p>拉链法：将链表和数组相结合。创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p>相比于hashCode返回的int类型，我们HashMap初始的容量大小 DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4（即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的下标将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，所以我们还需要对hashCode作一定的优化。</p><p><em>JDK1.8之后</em></p><p><strong>优化hash函数</strong></p><p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于==参与运算的只有hashCode的低位，高位是没有起到任何作用的==，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为扰动，在JDK 1.8中的hash()函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// 与自己右移16位进行异或运算（高低位异或）</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这比在JDK 1.7中，更为简洁，相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）。</p><p><strong>新增红黑树</strong></p><p>当链表长度大于阈值（默认为8）且数组长度大于64时，将链表转化为红黑树，以减少搜索时间，从原来的O(n)到O(logn)。（链表长度大于阈值，但是数组长度小于64时会首先进行扩容）</p><h4 id="链表成环（死循环）"><a href="#链表成环（死循环）" class="headerlink" title="链表成环（死循环）"></a>链表成环（死循环）</h4><p>多线程操作HashMap时可能引起死循环。</p><p>我先举个例子吧，我们现在往一个容量大小为2的put两个值，负载因子是0.75，2*0.75 = 1 所以插入第二个就要resize了，我们要在容量为2的容器里面用不同线程插入A，B，C，假如我们在resize之前打个短点，那意味着数据都插入了但是还没resize那扩容前可能是这样的。</p><p>因为resize的赋值方式，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置，==在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。==一旦几个线程都调整完成，就可能出现环形链表。</p><p>使用头插会改变链表的上的顺序，但是如果使用尾插，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。</p><ul><li>Java7在多线程操作HashMap时可能引起死循环，原因是扩容转移后前后链表顺序倒置，在转移过程中修改了原来链表中节点的引用关系。</li><li>Java8在同样的前提下并不会引起死循环，原因是扩容转移后前后链表顺序不变，保持之前节点的引用关系。<br>我认为即使不会出现死循环，但是通过源码看到put/get方法都没有加同步锁，多线程情况最容易出现的就是：无法保证上一秒put的值，下一秒get的时候还是原值，所以线程安全还是无法保证。</li></ul><h4 id="类作为key的条件"><a href="#类作为key的条件" class="headerlink" title="类作为key的条件"></a>类作为key的条件</h4><p>可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：</p><ul><li>如果类重写了 equals() 方法，也应该重写 hashCode() 方法。</li><li>类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。</li><li>如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。</li><li>用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</li></ul><p><strong>为什么HashMap中String、Integer这样的包装类适合作为K？</strong></p><p>String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p><ul><li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况。</li><li>内部已重写了equals()、hashCode()等方法，遵守了HashMap内部的规范，不容易出现Hash值计算错误的情况。</li></ul><p><strong>如果使用Object作为HashMap的Key，应该怎么办呢？</strong></p><p>重写hashCode()和equals()方法</p><ul><li>重写hashCode()是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</li><li>重写equals()方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性；<h4 id="HashMap-与-HashTable-区别"><a href="#HashMap-与-HashTable-区别" class="headerlink" title="HashMap 与 HashTable 区别"></a>HashMap 与 HashTable 区别</h4></li></ul><ol><li><p>线程安全： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 synchronized 修饰。（如果要保证线程安全的话就使用 ConcurrentHashMap 吧！）</p></li><li><p>效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</p></li><li><p>对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。</p></li><li><p>初始容量大小和每次扩充容量大小的不同 ：</p><ul><li>创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。</li><li>创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 <strong>HashMap 总是使用2的幂作为哈希表的大小</strong>。</li></ul></li><li><p>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p></li></ol><p>在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</p><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p><strong>底层数据结构</strong></p><p>JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表实现，JDK1.8 采用的数据结构跟HashMap的结构一样，数组+链表/红黑二叉树。HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</p><p><strong>实现线程安全的方式</strong></p><p><em>JDK1.7</em></p><p>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现。</p><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</p><p><em>JDK1.8</em></p><p>JDK1.8 的时候已经摒弃了Segment的概念，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现。synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发。</p><h4 id="TreeMap-和-TreeSet"><a href="#TreeMap-和-TreeSet" class="headerlink" title="TreeMap 和 TreeSet"></a>TreeMap 和 TreeSet</h4><ul><li>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。</li><li>TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口，从而根据键对元素进行排序。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;集合分类&quot;&gt;&lt;a href=&quot;#集合分类&quot; class=&quot;headerlink&quot; title=&quot;集合分类&quot;&gt;&lt;/a&gt;集合分类&lt;/h2&gt;&lt;p&gt;Java 容器分为 Collection 和 Map 两大类：&lt;/p&gt;
&lt;p&gt;Collection集合主要有List和Set两大接口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。&lt;/li&gt;
&lt;li&gt;List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList。&lt;br&gt;Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>力扣</title>
    <link href="http://yoursite.com/2020/05/30/%E5%88%B7%E9%A2%98/%E5%8A%9B%E6%89%A3/"/>
    <id>http://yoursite.com/2020/05/30/%E5%88%B7%E9%A2%98/%E5%8A%9B%E6%89%A3/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2020-06-08T00:54:29.910Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题-08-11-硬币凑整"><a href="#面试题-08-11-硬币凑整" class="headerlink" title="面试题 08.11. 硬币凑整"></a>面试题 08.11. 硬币凑整</h2><p>给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p><a id="more"></a><blockquote><p>  示例1:</p><p>  输入: n = 5 </p><p>  输出：2 </p><p>  解释: 有两种方式可以凑成总金额: 5=5 5=1+1+1+1+1</p><p>  示例2:</p><p>  输入: n = 10 </p><p>  输出：4 </p><p>  解释: 有四种方式可以凑成总金额: 10=10 10=5+5 10=5+1+1+1+1+1 10=1+1+1+1+1+1+1+1+1+1</p><p>  说明：</p><p>  你可以假设：0 &lt;= n (总金额) &lt;= 1000000</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;       </span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];      </span><br><span class="line">        <span class="keyword">int</span>[] coins = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>&#125;;</span><br><span class="line">        <span class="comment">//刚好可以用一个硬币凑成的情况，是一种情况</span></span><br><span class="line">        <span class="comment">// while i == coin :</span></span><br><span class="line">        <span class="comment">//dp[i] = dp[i - coin] =&gt; dp[0]</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * dp方程：dp[i] += dp[i - coin];</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = coin; i &lt;= n; i++) &#123;</span><br><span class="line">                dp[i] = (dp[i] + dp[i - coin]) % <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题51-数组中的逆序对"><a href="#面试题51-数组中的逆序对" class="headerlink" title="面试题51. 数组中的逆序对"></a>面试题51. 数组中的逆序对</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><blockquote><p>  示例 1:</p><p>  输入: [7,5,6,4]</p><p>  输出: 5</p><p>  限制：0 &lt;= 数组长度 &lt;= 50000</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> merge(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> count = merge(arr, start, mid) + merge(arr, mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = start, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= end) &#123;</span><br><span class="line">            count += arr[i] &lt;= arr[j] ? j - (mid + <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">            temp[k++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            count += j - (mid + <span class="number">1</span>);</span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= end)&#123;</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        &#125;  </span><br><span class="line">        System.arraycopy(temp, <span class="number">0</span>, arr, start, end - start + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h2><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><blockquote><p>  示例 1:</p><p>  输入: “abcabcbb”</p><p>  输出: 3 </p><p>  解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><p>  示例 2:</p><p>  输入: “bbbbb”</p><p>  输出: 1</p><p>  解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p><p>  示例 3:</p><p>  输入: “pwwkew”</p><p>  输出: 3</p><p>  解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。</p><p>  请注意，你的答案必须是 <code>子串</code> 的长度，”pwke” 是一个子序列，不是子串。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="comment">//记录最大长度</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录最左开始字母下标</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                <span class="comment">//更新最左开始字母下标</span></span><br><span class="line">                left = Math.max(left,map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(i),i);</span><br><span class="line">            max = Math.max(max,i-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h2><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。</p><p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p><blockquote><p>  示例 1:</p><p>  nums1 = [1, 3]</p><p>  nums2 = [2]</p><p>  则中位数是 2.0</p><p>  示例 2:</p><p>  nums1 = [1, 2]</p><p>  nums2 = [3, 4]</p><p>  则中位数是 (2 + 3)/2 = 2.5</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="comment">//分配新数组</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[m + n];</span><br><span class="line">        <span class="comment">//nums1为空</span></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//判断奇偶性，分类求中位数</span></span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> (nums2[n / <span class="number">2</span> - <span class="number">1</span>] + nums2[n / <span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[n / <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//nums2为空</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//判断奇偶性，分类求中位数</span></span><br><span class="line">            <span class="keyword">if</span> (m % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> (nums1[m / <span class="number">2</span> - <span class="number">1</span>] + nums1[m / <span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[m / <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新数组指针</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//nums1和nums2的指针</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历复制</span></span><br><span class="line">        <span class="keyword">while</span> (count != (m + n)) &#123;</span><br><span class="line">            <span class="comment">//nums1数组遍历完，直接复制nums2数组</span></span><br><span class="line">            <span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">                <span class="keyword">while</span> (j != n) &#123;</span><br><span class="line">                    nums[count++] = nums2[j++];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//nums2数组遍历完，直接复制nums1数组</span></span><br><span class="line">            <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">                <span class="keyword">while</span> (i != m) &#123;</span><br><span class="line">                    nums[count++] = nums1[i++];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//选择nums1中和nums2中小的加入</span></span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">                nums[count++] = nums1[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[count++] = nums2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回中位数</span></span><br><span class="line">        <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (nums[count / <span class="number">2</span> - <span class="number">1</span>] + nums[count / <span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[count / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><blockquote><p>  示例 1：</p><p>  输入: “babad”</p><p>  输出: “bab”</p><p>  注意: “aba” 也是一个有效答案。</p><p>  示例 2：</p><p>  输入: “cbbd”</p><p>  输出: “bb”</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.equals(<span class="string">""</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//字符串s[i⋯j]是否为回文子串，如果是，dp[i][j]=true，如果不是，dp[i][j]=false</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录最长回文字串的左右下标</span></span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化，单个字符都是回文子串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//开始遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; s.length(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    <span class="comment">//考虑“cbba”这种情况</span></span><br><span class="line">                    <span class="keyword">if</span>(j - i == <span class="number">1</span>)&#123;</span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//只要dp[i+1][j-1]是回文子串，那么dp[i][j]也就是回文子串</span></span><br><span class="line">                        dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>]; </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j])&#123;</span><br><span class="line">                    <span class="comment">//找到更长字串，则更新</span></span><br><span class="line">                    <span class="keyword">if</span>(max - min &lt;= j - i)&#123;</span><br><span class="line">                        min = i;</span><br><span class="line">                        max = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(min, max + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h2><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfa9qwtom2j30m90anwep.jpg" alt="img"></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><blockquote><p>  说明：你不能倾斜容器，且 n 的值至少为 2。</p><p>  示例：</p><p>  输入：[1,8,6,2,5,4,8,3,7]</p><p>  输出：49</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在每一个状态下，无论长板或短板收窄1格，都会导致水槽底边宽度−1：</span></span><br><span class="line"><span class="comment">若向内移动短板，水槽的短板 min(h[i], h[j])min(h[i],h[j]) 可能变大，因此水槽面积 S(i, j)S(i,j) 可能增大。</span></span><br><span class="line"><span class="comment">若向内移动长板，水槽的短板 min(h[i], h[j])min(h[i],h[j]) 不变或变小，下个水槽的面积一定小于当前水槽面积。</span></span><br><span class="line"><span class="comment">因此，向内收窄短板可以获取面积最大值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, j = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i] &lt;= height[j])&#123;</span><br><span class="line">                res = Math.max(res, height[i] * (j - i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res = Math.max(res, height[j] * (j - i));</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23-合并K个排序链表"><a href="#23-合并K个排序链表" class="headerlink" title="23. 合并K个排序链表"></a>23. 合并K个排序链表</h2><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><blockquote><p>  示例:</p><p>  输入:<br>  [<br>    1-&gt;4-&gt;5,<br>    1-&gt;3-&gt;4,<br>    2-&gt;6<br>  ]</p><p>  输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p></blockquote><p><strong>利用堆做排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists==<span class="keyword">null</span> || lists.length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个堆，并设置元素的排序方式</span></span><br><span class="line">        PriorityQueue&lt;ListNode&gt; queue = <span class="keyword">new</span> PriorityQueue(<span class="keyword">new</span> Comparator&lt;ListNode&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode o1, ListNode o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (o1.val - o2.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历链表数组，然后将每个链表的每个节点都放入堆中</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lists.length; i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(lists[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">queue.add(lists[i]);</span><br><span class="line">lists[i] = lists[i].next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;   </span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode head = dummy;</span><br><span class="line">        <span class="comment">//从堆中不断取出元素，并将取出的元素串联起来</span></span><br><span class="line">        <span class="keyword">while</span>( !queue.isEmpty() ) &#123;</span><br><span class="line">            dummy.next = queue.poll();</span><br><span class="line">            dummy = dummy.next;</span><br><span class="line">        &#125;</span><br><span class="line">        dummy.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>堆排序优化</strong></p><p>我们建立完k个大小的堆后，就不断的从堆中获取节点，如果获取到的节点不为空，即还有下一个节点，那么就将下一个节点放到堆中。利用这个特点我们就可以优化空间了，将原先的O(N)的空间复杂度优化到O(k)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists==<span class="keyword">null</span> || lists.length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个小根堆，并定义好排序函数</span></span><br><span class="line">        PriorityQueue&lt;ListNode&gt; queue = <span class="keyword">new</span> PriorityQueue(<span class="keyword">new</span> Comparator&lt;ListNode&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode o1, ListNode o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (o1.val - o2.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="comment">//这里跟上一版不一样，不再是一股脑全部放到堆中</span></span><br><span class="line">        <span class="comment">//而是只把k个链表的第一个节点放入到堆中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">            ListNode head = lists[i];</span><br><span class="line">            <span class="keyword">if</span>(head!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(head);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//之后不断从堆中取出节点，如果这个节点还有下一个节点，</span></span><br><span class="line">        <span class="comment">//就将下个节点也放入堆中</span></span><br><span class="line">        <span class="keyword">while</span>(queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ListNode node = queue.poll();</span><br><span class="line">            cur.next = node;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="keyword">if</span>(node.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>两两合并</strong></p><p>对于这四个链表，我们先合并A1和A2，将这两个链表变成A1-A2，然后再按照两两合并的方式，合并A1-A2和A3，这三个链表就合并成了A1-A2-A3，最后将A1-A2-A3跟A4两两合并，四个链表就合并完了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists==<span class="keyword">null</span> || lists.length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将lists[0]作为最终合并的链表，然后将list[0]和lists[1]合并成lists[0-1]</span></span><br><span class="line">        <span class="comment">//再将lists[0-1]和lists[2]合并，如此反复最终lists[0]就是最终结果</span></span><br><span class="line">        ListNode res = lists[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;lists.length;i++) &#123;</span><br><span class="line">            res = merge(res,lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并两个有序链表</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode a, ListNode b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="keyword">null</span> || b==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (a==<span class="keyword">null</span>) ? b : a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a.val&lt;=b.val) &#123;</span><br><span class="line">            a.next = merge(a.next,b);</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            b.next = merge(a,b.next);</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><blockquote><p>  示例 1:</p><p>  输入: [1,3,5,6], 5</p><p>  输出: 2</p><p>  示例 2:</p><p>  输入: [1,3,5,6], 2</p><p>  输出: 1</p><p>  示例 3:</p><p>  输入: [1,3,5,6], 7</p><p>  输出: 4</p><p>  示例 4:</p><p>  输入: [1,3,5,6], 0</p><p>  输出: 0</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//下标小于low的值都小于target</span></span><br><span class="line">        <span class="keyword">int</span> low = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//下标大于high的值都大于target</span></span><br><span class="line">        <span class="keyword">int</span> high = nums.length;</span><br><span class="line">        <span class="comment">//当low和high之间有值时不断循环</span></span><br><span class="line">        <span class="keyword">while</span>(low + <span class="number">1</span> &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target)&#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h2><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><blockquote><p>  示例:</p><p>  输入: [1,2,3]</p><p>  输出:<br>  [<br>    [1,2,3],<br>    [1,3,2],<br>    [2,1,3],<br>    [2,3,1],<br>    [3,1,2],<br>    [3,2,1]<br>  ]</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 记录「路径」</span></span><br><span class="line">        LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        backtrack(nums, track);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 路径：记录在 track 中</span></span><br><span class="line">    <span class="comment">// 选择列表：nums 中不存在于 track 的那些元素</span></span><br><span class="line">    <span class="comment">// 结束条件：nums 中的元素全都在 track 中出现</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 触发结束条件</span></span><br><span class="line">        <span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList(track));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 排除不合法的选择</span></span><br><span class="line">            <span class="keyword">if</span> (track.contains(nums[i]))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            <span class="comment">// 进入下一层决策树</span></span><br><span class="line">            backtrack(nums, track);</span><br><span class="line">            <span class="comment">// 取消选择</span></span><br><span class="line">            track.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个位置。</p><blockquote><p>  示例 1:</p><p>  输入: [2,3,1,1,4]</p><p>  输出: true</p><p>  解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p><p>  示例 2:</p><p>  输入: [3,2,1,0,4]</p><p>  输出: false</p><p>  解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//记录当前最大跳跃距离</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//如果当前坐标大于最大跳跃距离，则当前坐标不可达，返回false</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; maxLen)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则更新最大跳跃距离</span></span><br><span class="line">            maxLen = Math.max(maxLen, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a>76. 最小覆盖子串</h2><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p><blockquote><p>  示例：</p><p>  输入: S = “ADOBECODEBANC”, T = “ABC”</p><p>  输出: “BANC”</p><p>  说明：</p><p>  如果 S 中不存这样的子串，则返回空字符串 “”。</p><p>  如果 S 中存在这样的子串，我们保证它是唯一的答案。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s == <span class="string">""</span> || t == <span class="keyword">null</span> || t == <span class="string">""</span> </span><br><span class="line">        || s.length() &lt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用来统计t中每个字符出现次数</span></span><br><span class="line">        <span class="keyword">int</span>[] needs = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用来统计滑动窗口中每个字符出现次数</span></span><br><span class="line">        <span class="keyword">int</span>[] window = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            needs[t.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//滑动窗口左右边界</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//目前有多少个字符</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用来记录最短需要多少个字符。</span></span><br><span class="line">        <span class="keyword">int</span> minLength = s.length() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(right);</span><br><span class="line">            window[ch]++;</span><br><span class="line">            <span class="keyword">if</span> (needs[ch] &gt; <span class="number">0</span> &amp;&amp; needs[ch] &gt;= window[ch]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//移动到不满足条件为止</span></span><br><span class="line">            <span class="keyword">while</span> (count == t.length()) &#123;</span><br><span class="line">                ch = s.charAt(left);</span><br><span class="line">                <span class="keyword">if</span> (needs[ch] &gt; <span class="number">0</span> &amp;&amp; needs[ch] &gt;= window[ch]) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; minLength) &#123;</span><br><span class="line">                    minLength = right - left + <span class="number">1</span>;</span><br><span class="line">                    res = s.substring(left, right + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                window[ch]--;</span><br><span class="line">                left++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a>84. 柱状图中最大的矩形</h2><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfa9z1nt7vj305805o0it.jpg" alt="img"></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfa9y9gpiyj305805ogld.jpg" alt="img"></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p><blockquote><p>  示例:</p><p>  输入: [2,1,5,6,2,3]</p><p>  输出: 10</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过观察，可以发现，最大面积矩形存在于以下几种情况：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.确定了最矮柱子以后，矩形的宽尽可能往两边延伸。</span></span><br><span class="line"><span class="comment">2.在最矮柱子左边的最大面积矩形（子问题）。</span></span><br><span class="line"><span class="comment">3.在最矮柱子右边的最大面积矩形（子问题）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> largestRectangleArea(heights, <span class="number">0</span>, heights.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right == left) &#123;</span><br><span class="line">            <span class="keyword">return</span> heights[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存储最小高度</span></span><br><span class="line">        <span class="keyword">int</span> minHeight = heights[left];</span><br><span class="line">        <span class="comment">//存储最小高度下标</span></span><br><span class="line">        <span class="keyword">int</span> minHeightIndex = left;</span><br><span class="line">        <span class="comment">//遍历找出最小高度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heights[i] &lt; minHeight) &#123;</span><br><span class="line">                minHeight = heights[i];</span><br><span class="line">                minHeightIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归求解最大值</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(</span><br><span class="line">            minHeight * (right - left + <span class="number">1</span>), </span><br><span class="line">            Math.max(largestRectangleArea(heights, left, minHeightIndex - <span class="number">1</span>),                           largestRectangleArea(heights, minHeightIndex + <span class="number">1</span>, right)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p><blockquote><p>  例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><blockquote><p>  但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 2   2</span><br><span class="line">  \   \</span><br><span class="line">  3    3</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isMirrorBTree(root.left, root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isMirrorBTree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == root1 &amp;&amp; <span class="keyword">null</span> == root2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">null</span> == root1 || <span class="keyword">null</span> == root2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1.val != root2.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此处注意相反比较</span></span><br><span class="line">        <span class="keyword">return</span> isMirrorBTree(root1.left,root2.right)</span><br><span class="line">            &amp;&amp; isMirrorBTree(root1.right,root2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h2><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p>注意：你可以假设树中没有重复的元素。</p><blockquote><p>  例如，给出</p><p>  前序遍历 preorder = [3,9,20,15,7]</p><p>  中序遍历 inorder = [9,3,15,20,7]</p><p>  返回如下的二叉树：</p><p>  [3,9,20,15,7]</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.length == <span class="number">0</span> || in.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//前序遍历的第一个节点为根节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++)&#123;</span><br><span class="line">            <span class="comment">//找到中序遍历中根节点的位置</span></span><br><span class="line">            <span class="keyword">if</span>(pre[<span class="number">0</span>] == in[i])&#123;</span><br><span class="line">                root.left = buildTree</span><br><span class="line">                    (Arrays.copyOfRange(pre, <span class="number">1</span>, i+<span class="number">1</span>), </span><br><span class="line">                     Arrays.copyOfRange(in, <span class="number">0</span>, i));</span><br><span class="line">                root.right = buildTree</span><br><span class="line">                    (Arrays.copyOfRange(pre, i+<span class="number">1</span>, pre.length), </span><br><span class="line">                     Arrays.copyOfRange(in, i+<span class="number">1</span>, in.length));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146. LRU缓存机制"></a>146. LRU缓存机制</h2><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><ul><li><p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。</p></li><li><p>写入数据 put(key, value) - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p></li></ul><p>进阶:</p><p>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><blockquote><p>  示例:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache = <span class="keyword">new</span> LRUCache( <span class="number">2</span> <span class="comment">/* 缓存容量 */</span> );</span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// 返回  1</span></span><br><span class="line">cache.put(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// 该操作会使得密钥 2 作废</span></span><br><span class="line">cache.get(<span class="number">2</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.put(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// 该操作会使得密钥 1 作废</span></span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.get(<span class="number">3</span>);       <span class="comment">// 返回  3</span></span><br><span class="line">cache.get(<span class="number">4</span>);       <span class="comment">// 返回  4</span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Node类用于抽象链表的节点</span></span><br><span class="line"><span class="comment">     * key、value存储键、值，</span></span><br><span class="line"><span class="comment">     * before、after分别指向当前节点的前后Node节点；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        Node before;</span><br><span class="line">        Node after;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用HashMap缓存Node节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; cache = <span class="keyword">new</span> HashMap&lt;Integer, Node&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大容量，超过capacity时继续插入会触发删除最老未被使用的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头节点、尾节点（注意这两个节点不存储实际的数据）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head, tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line"></span><br><span class="line">        head = <span class="keyword">new</span> Node();</span><br><span class="line">        head.before = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        tail = <span class="keyword">new</span> Node();</span><br><span class="line">        tail.after = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        head.after = tail;</span><br><span class="line">        tail.before = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        Node node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果获取到数据，则将获取到的节点移动到队列头部;</span></span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将节点移动到有效数据头部</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除队列中的一个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node before = node.before;</span><br><span class="line">        Node after = node.after;</span><br><span class="line">        before.after = after;</span><br><span class="line">        after.before = before;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将节点插入队列头部</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        node.before = head;</span><br><span class="line">        node.after = head.after;</span><br><span class="line">        head.after.before = node;</span><br><span class="line">        head.after = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node();</span><br><span class="line">            newNode.key = key;</span><br><span class="line">            newNode.value = value;</span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            <span class="keyword">if</span> (cache.size() &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 删除队尾有效数据节点</span></span><br><span class="line">                Node tail = <span class="keyword">this</span>.popTail();</span><br><span class="line">                <span class="keyword">this</span>.cache.remove(tail.key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            <span class="comment">// 在使用get方法获取值之后，需要将当前获取的节点移动到队列头部</span></span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除有效数据尾节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 尾节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">popTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node res = tail.before;</span><br><span class="line">        <span class="keyword">this</span>.removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a>152. 乘积最大子数组</h2><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><blockquote><p>  示例 1:</p><p>  输入: [2,3,-2,4]</p><p>  输出: 6</p><p>  解释: 子数组 [2,3] 有最大乘积 6。</p><p>  示例 2:</p><p>  输入: [-2,0,-1]</p><p>  输出: 0</p><p>  解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>], min = nums[<span class="number">0</span>], result = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//由于数组中含有负数，需要同时维护max和min</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = max;</span><br><span class="line">            <span class="comment">//max 取 max * nums[i]、min * nums[i]、nums[i]中的最大值</span></span><br><span class="line">            max = Math.max(Math.max(max * nums[i], min * nums[i]), nums[i]);</span><br><span class="line">            <span class="comment">//min 取 temp * nums[i]、min * nums[i]、nums[i]中的最小值</span></span><br><span class="line">            min = Math.min(Math.min(temp * nums[i], min * nums[i]), nums[i]);</span><br><span class="line">            <span class="comment">//记录最大值</span></span><br><span class="line">            <span class="keyword">if</span> (max &gt; result) result = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. 打家劫舍</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><blockquote><p>  示例 1:</p><p>  输入: [1,2,3,1]</p><p>  输出: 4</p><p>  解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>           偷窃到的最高金额 = 1 + 3 = 4 。</p><p>  示例 2:</p><p>  输入: [2,7,9,3,1]</p><p>  输出: 12</p><p>  解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>           偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="comment">//动态规划方程：dp[n] = MAX( dp[n-1], dp[n-2] + num )</span></span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>] + nums[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a>210. 课程表 II</h2><p>现在你总共有 n 门课需要选，记为 0 到 n-1。在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p><p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p><p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p><blockquote><p>  示例 1:</p><p>  输入: 2, [[1,0]] </p><p>  输出: [0,1]</p><p>  解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</p><p>  示例 2:</p><p>  输入: 4, [[1,0],[2,0],[3,1],[3,2]]</p><p>  输出: [0,1,2,3] or [0,2,1,3]</p><p>  解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="comment">//课程数为0，直接返回空数组</span></span><br><span class="line">        <span class="keyword">if</span> (numCourses == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 建立入度表</span></span><br><span class="line">        <span class="keyword">int</span>[] inDegrees = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="comment">// 对于有先修课的课程，计算有几门先修课</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] p : prerequisites) &#123; </span><br><span class="line">            inDegrees[p[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 入度为0的节点,加入队列，表示可以直接学习</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inDegrees.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegrees[i] == <span class="number">0</span>) queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录学完的课程数量</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录学完的课程</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="comment">// 根据提供的先修课列表，删除入度为0的节点</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//将可以学完的课程加入结果当中</span></span><br><span class="line">            <span class="keyword">int</span> curr = queue.poll();</span><br><span class="line">            res[count++] = curr;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] p : prerequisites) &#123;</span><br><span class="line">                <span class="comment">//将先修课程为curr的节点入度减1</span></span><br><span class="line">                <span class="keyword">if</span> (p[<span class="number">1</span>] == curr)&#123;</span><br><span class="line">                    inDegrees[p[<span class="number">0</span>]]--;</span><br><span class="line">                    <span class="comment">//如果节点入度为0，则加入队列，代表可以直接学习</span></span><br><span class="line">                    <span class="keyword">if</span> (inDegrees[p[<span class="number">0</span>]] == <span class="number">0</span>) queue.offer(p[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果已学习课程数count等于总数numCourses，则返回结果res</span></span><br><span class="line">        <span class="keyword">if</span> (count == numCourses) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//否则返回空数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a>287. 寻找重复数</h2><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><blockquote><p>  示例 1:</p><p>  输入: [1,3,4,2,2]</p><p>  输出: 2</p><p>  示例 2:</p><p>  输入: [3,1,3,4,2]</p><p>  输出: 3</p><p>  说明：</p><ol><li>不能更改原数组（假设数组是只读的）。</li><li>只能使用额外的 O(1) 的空间。</li><li>时间复杂度小于 O(n2) 。</li><li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(nums[i]) == <span class="keyword">null</span>)&#123;</span><br><span class="line">                map.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a>394. 字符串解码</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><blockquote><p>  示例:</p><p>  s = “3[a]2[bc]”, 返回 “aaabcbc”.</p><p>  s = “3[a2[c]]”, 返回 “accaccacc”.</p><p>  s = “2[abc]3[cd]ef”, 返回 “abcabccdcdcdef”.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">① 找到第一对匹配的括号开始和结束的索引位置</span></span><br><span class="line"><span class="comment">② 从"["括号的开始位置向前扫描，找到数字出现的起始坐标</span></span><br><span class="line"><span class="comment">③ 把出现在数字之前的字符复制到StringBuilder中</span></span><br><span class="line"><span class="comment">④ 复制括号中的字符到StringBuilder中</span></span><br><span class="line"><span class="comment">⑤ 复制"]"括号后的字符到StringBuilder中</span></span><br><span class="line"><span class="comment">⑥ s赋值为StringBuilder中的字符串，并将StringBuilder清空，重复上述过程，指导s字符串中找不到括号为止；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (s.contains(<span class="string">"["</span>)) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//记录第一对括号的起始位置和结束位置</span></span><br><span class="line">            <span class="keyword">int</span> startEqual = <span class="number">0</span>, endEqual = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == <span class="string">'['</span>) &#123;</span><br><span class="line">                    startEqual = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == <span class="string">']'</span>) &#123;</span><br><span class="line">                    endEqual = i; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//括号中的字符串sub</span></span><br><span class="line">            String sub = s.substring(startEqual + <span class="number">1</span>, endEqual);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//向前扫描，找到数字开始的位置;</span></span><br><span class="line">            <span class="keyword">int</span> numIndex = startEqual - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (numIndex &gt;= <span class="number">0</span> &amp;&amp; Character.isDigit(s.charAt(numIndex)))&#123;</span><br><span class="line">                numIndex--;</span><br><span class="line">            &#125;                          </span><br><span class="line"></span><br><span class="line">            <span class="comment">//需要重复的次数，求出数字的值</span></span><br><span class="line">            <span class="keyword">int</span> times = Integer.parseInt(s.substring(numIndex + <span class="number">1</span>, startEqual));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将"["括号数字之前的字符添加到sb中</span></span><br><span class="line">            sb.append(s, <span class="number">0</span>, numIndex + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (times-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                sb.append(sub);</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">//将"]"右括号之后的字符添加到sb中</span></span><br><span class="line">            sb.append(s, endEqual + <span class="number">1</span>, s.length());</span><br><span class="line"></span><br><span class="line">            s = sb.toString();</span><br><span class="line">            sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="402-移掉K位数字"><a href="#402-移掉K位数字" class="headerlink" title="402. 移掉K位数字"></a>402. 移掉K位数字</h2><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。</p><p>注意:</p><p>num 的长度小于 10002 且 ≥ k。</p><p>num 不会包含任何前导零。</p><blockquote><p>  示例 1 :</p><p>  输入: num = “1432219”, k = 3</p><p>  输出: “1219”</p><p>  解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。</p><p>  示例 2 :</p><p>  输入: num = “10200”, k = 1</p><p>  输出: “200”</p><p>  解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</p><p>  示例 3 :</p><p>  输入: num = “10”, k = 2</p><p>  输出: “0”</p><p>  解释: 从原数字移除所有的数字，剩余为空就是0。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeKdigits</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num.length() == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder(num);</span><br><span class="line">        <span class="comment">//共删除k次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//找到持续增加的区间最后的数字，也就是最大的数字下标idx</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; s.length() &amp;&amp; s.charAt(j) &gt;= s.charAt(j - <span class="number">1</span>); j++) &#123;</span><br><span class="line">                idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//删除idx</span></span><br><span class="line">            s.delete(idx, idx + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//特殊情况：删除最大数后第一位为0</span></span><br><span class="line">            <span class="keyword">while</span> (s.length() &gt; <span class="number">1</span> &amp;&amp; s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>)&#123;</span><br><span class="line">                s.delete(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="680-验证回文字符串-Ⅱ"><a href="#680-验证回文字符串-Ⅱ" class="headerlink" title="680. 验证回文字符串 Ⅱ"></a>680. 验证回文字符串 Ⅱ</h2><p>给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</p><blockquote><p>  示例 1:</p><p>  输入: “aba”</p><p>  输出: True</p><p>  示例 2:</p><p>  输入: “abca”</p><p>  输出: True</p><p>  解释: 你可以删除c字符。</p><p>  注意:</p><p>  字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将字符串转换为字符数组</span></span><br><span class="line">        array = s.toCharArray();</span><br><span class="line">        <span class="comment">//双指针</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> low = <span class="number">0</span>, high = array.length - <span class="number">1</span>; low &lt; high; low++, high--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (array[low] != array[high])&#123;</span><br><span class="line">                <span class="keyword">return</span> isSub(low + <span class="number">1</span>, high) || isSub(low, high - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这种情况是没有删除字符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSub</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">if</span> (array[low++] != array[high--])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="974-和可被-K-整除的子数组"><a href="#974-和可被-K-整除的子数组" class="headerlink" title="974. 和可被 K 整除的子数组"></a>974. 和可被 K 整除的子数组</h2><p>给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。</p><blockquote><p>  示例：</p><p>  输入：A = [4,5,0,-2,-3,1], K = 5</p><p>  输出：7</p><p>  解释：</p><p>  有 7 个子数组满足其元素之和可被 K = 5 整除：</p><p>  [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]</p><p>  提示：</p><p>  1 &lt;= A.length &lt;= 30000</p><p>  -10000 &lt;= A[i] &lt;= 10000</p><p>  2 &lt;= K &lt;= 10000</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraysDivByK</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.length, sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[K];</span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="comment">//前缀和</span></span><br><span class="line">            sum = sum + A[i-<span class="number">1</span>]; </span><br><span class="line">            <span class="comment">//将key定义为sum[i]%K</span></span><br><span class="line">            <span class="keyword">int</span> key = (sum % K + K) % K;</span><br><span class="line">            ans += map[key];</span><br><span class="line">            map[key]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面试题-08-11-硬币凑整&quot;&gt;&lt;a href=&quot;#面试题-08-11-硬币凑整&quot; class=&quot;headerlink&quot; title=&quot;面试题 08.11. 硬币凑整&quot;&gt;&lt;/a&gt;面试题 08.11. 硬币凑整&lt;/h2&gt;&lt;p&gt;给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://yoursite.com/2020/05/30/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git/"/>
    <id>http://yoursite.com/2020/05/30/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2020-06-08T00:55:51.498Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  参考文档：<a href="https://snailclimb.gitee.io/javaguide/#/docs/tools/Git" target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/docs/tools/Git</a></p></blockquote><h2 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h2><p>Git 有三种状态，你的文件可能处于其中之一：</p><ol><li><strong>已提交（committed）</strong>：数据已经安全的保存在本地数据库中。</li><li><strong>已修改（modified）</strong>：已修改表示修改了文件，但还没保存到数据库中。</li><li><strong>已暂存（staged）</strong>：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li></ol><p>由此引入 Git 项目的三个工作区域的概念：<strong>Git 仓库(.git directoty)</strong>、<strong>工作目录(Working Directory)</strong> 以及 <strong>暂存区域(Staging Area)</strong> 。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4qcxem9oj30m80c90sy.jpg" alt="img" style="zoom:67%;" /><a id="more"></a><p><strong>基本的 Git 工作流程如下：</strong></p><ol><li>在工作目录中修改文件。</li><li>暂存文件，将文件的快照放入暂存区域。</li><li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</li></ol><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h3><p>有两种取得 Git 项目仓库的方法。</p><ol><li>在现有目录中初始化仓库: 进入项目目录运行 <code>git init</code> 命令,该命令将创建一个名为 <code>.git</code> 的子目录。</li><li>从一个服务器克隆一个现有的 Git 仓库: <code>git clone [url]</code> 自定义本地仓库的名字: <code>git clone [url]</code> directoryname</li></ol><h3 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h3><ol><li><strong>检测当前文件状态</strong> : <code>git status</code></li><li><strong>提出更改（把它们添加到暂存区</strong>）：<code>git add filename</code> (针对特定文件)、<code>git add *</code>(所有文件)、<code>git add *.txt</code>（支持通配符，所有 .txt 文件）</li><li><strong>忽略文件</strong>：<code>.gitignore</code> 文件</li><li><strong>提交更新:</strong> <code>git commit -m &quot;代码提交信息&quot;</code> （每次准备提交前，先用 <code>git status</code> 看下，是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>）</li><li><strong>跳过使用暂存区域更新的方式</strong> : <code>git commit -a -m &quot;代码提交信息&quot;</code>。 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤。</li><li><strong>移除文件</strong> ：<code>git rm filename</code> （从暂存区域移除，然后提交。）</li><li><strong>对文件重命名</strong> ：<code>git mv README.md README</code>(这个命令相当于<code>mv README.md README</code>、<code>git rm README.md</code>、<code>git add README</code> 这三条命令的集合)</li></ol><h3 id="推送改动到远程仓库"><a href="#推送改动到远程仓库" class="headerlink" title="推送改动到远程仓库"></a>推送改动到远程仓库</h3><ul><li><p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：<code>git remote add origin &lt;server&gt;</code> ,比如我们要让本地的一个仓库和 Github 上创建的一个仓库关联可以这样<code>git remote add origin https://github.com/xxx/test.git</code></p></li><li><p>将这些改动提交到远端仓库：<code>git push origin master</code> (可以把 <em>master</em> 换成你想要推送的任何分支)</p><p>如此就能够将你的改动推送到所添加的服务器上去了。</p></li></ul><h3 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h3><ul><li>将 test 重命名为 test1：<code>git remote rename test test1</code></li><li>移除远程仓库 test1: <code>git remote rm test1</code></li></ul><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。<code>git log</code> 会按提交时间列出所有的更新，最近的更新排在最上面。</p><p><strong>可以添加一些参数来查看自己希望看到的内容：</strong></p><p>只看某个人的提交记录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author=slimshady</span><br></pre></td></tr></table></figure><h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>取消暂存的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset filename</span><br></pre></td></tr></table></figure><p>撤消对文件的修改:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- filename</span><br></pre></td></tr></table></figure><p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，<em>master</em> 是“默认的”分支。可以在其他分支上进行开发，完成后再将它们合并到主分支上。</p><p>我们通常在开发新功能、修复一个紧急 bug 等等时候会选择创建分支。单分支开发好还是多分支开发好，还是要看具体场景来说。</p><p>创建一个名字叫做 test 的分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch test</span><br></pre></td></tr></table></figure><p>切换当前分支到 test（当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout test</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4qv777vdj30f8032q2w.jpg" alt="img"></p><p>你也可以直接这样创建分支并切换过去(上面两条命令的合写)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b test</span><br></pre></td></tr></table></figure><p>切换到主分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>合并分支(可能会有冲突)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge test</span><br></pre></td></tr></table></figure><p>把新建的分支删掉</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d test</span><br></pre></td></tr></table></figure><p>将分支推送到远端仓库（推送成功后其他人可见）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;  参考文档：&lt;a href=&quot;https://snailclimb.gitee.io/javaguide/#/docs/tools/Git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://snailclimb.gitee.io/javaguide/#/docs/tools/Git&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三种状态&quot;&gt;&lt;a href=&quot;#三种状态&quot; class=&quot;headerlink&quot; title=&quot;三种状态&quot;&gt;&lt;/a&gt;三种状态&lt;/h2&gt;&lt;p&gt;Git 有三种状态，你的文件可能处于其中之一：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;已提交（committed）&lt;/strong&gt;：数据已经安全的保存在本地数据库中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;已修改（modified）&lt;/strong&gt;：已修改表示修改了文件，但还没保存到数据库中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;已暂存（staged）&lt;/strong&gt;：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由此引入 Git 项目的三个工作区域的概念：&lt;strong&gt;Git 仓库(.git directoty)&lt;/strong&gt;、&lt;strong&gt;工作目录(Working Directory)&lt;/strong&gt; 以及 &lt;strong&gt;暂存区域(Staging Area)&lt;/strong&gt; 。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4qcxem9oj30m80c90sy.jpg&quot; alt=&quot;img&quot; style=&quot;zoom:67%;&quot; /&gt;
    
    </summary>
    
    
      <category term="常用工具" scheme="http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://yoursite.com/2020/05/30/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Docker/"/>
    <id>http://yoursite.com/2020/05/30/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Docker/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2020-06-08T00:55:44.939Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  参考文档：<a href="https://snailclimb.gitee.io/javaguide/#/docs/tools/Docker-Image" target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/docs/tools/Docker-Image</a></p></blockquote><h2 id="Docker-下载镜像"><a href="#Docker-下载镜像" class="headerlink" title="Docker 下载镜像"></a>Docker 下载镜像</h2><p>如果我们想要在本地运行容器，就必须保证本地存在对应的镜像。所以，第一步，我们需要下载镜像。当我们尝试下载镜像时，Docker 会尝试先从默认的镜像仓库（默认使用 Docker Hub 公共仓库）去下载，当然了，用户也可以自定义配置想要下载的镜像仓库。</p><a id="more"></a><h3 id="1-1-下载镜像"><a href="#1-1-下载镜像" class="headerlink" title="1.1 下载镜像"></a>1.1 下载镜像</h3><p>镜像是运行容器的前提，我们可以使用 <code>docker pull[IMAGE_NAME]:[TAG]</code>命令来下载镜像，其中 <code>IMAGE_NAME</code> 表示的是镜像的名称，而 <code>TAG</code> 是镜像的标签，也就是说我们需要通过 “<strong>镜像 + 标签</strong>” 的方式来下载镜像。</p><p><strong>注意：</strong> 您也可以不显式地指定 TAG, 它会默认下载 latest 标签，也就是下载仓库中最新版本的镜像。这里并不推荐您下载 latest 标签，因为该镜像的内容会跟踪镜像的最新版本，并随之变化，所以它是不稳定的。在生产环境中，可能会出现莫名其妙的 bug, 推荐您最好还是显示的指定具体的 TAG。</p><p>举个例子，如我们想要下载一个 Mysql 5.7 镜像，可以通过命令来下载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 由于官方 DockerHub 仓库服务器在国外，下载速度较慢</p><h3 id="1-2-验证"><a href="#1-2-验证" class="headerlink" title="1.2 验证"></a>1.2 验证</h3><p>让我们来验证一下，本地是否存在 Mysql5.7 的镜像，运行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>可以看到本地的确存在该镜像，则确实是下载成功了！</p><h3 id="1-3-下载镜像相关细节"><a href="#1-3-下载镜像相关细节" class="headerlink" title="1.3 下载镜像相关细节"></a>1.3 下载镜像相关细节</h3><p>通过下载过程，可以看到，一个镜像一般是由多个层（ <code>layer</code>） 组成，类似 <code>f7e2b70d04ae</code>这样的串表示层的唯一 ID（实际上完整的 ID 包括了 256 个 bit, 64 个十六进制字符组成）。</p><p><strong>您可能会想，如果多个不同的镜像中，同时包含了同一个层（ layer）,这样重复下载，岂不是导致了存储空间的浪费么?</strong></p><p>实际上，Docker 并不会这么傻会去下载重复的层（ <code>layer</code>）,Docker 在下载之前，会去检测本地是否会有同样 ID 的层，如果本地已经存在了，就直接使用本地的就好了。</p><p><strong>另一个问题，不同仓库中，可能也会存在镜像重名的情况发生, 这种情况咋办？</strong></p><p>严格意义上，我们在使用 <code>docker pull</code> 命令时，还需要在镜像前面指定仓库地址( <code>Registry</code>), 如果不指定，则 Docker 会使用您默认配置的仓库地址。例如配置的是国内 <code>docker.io</code> 的仓库地址，我在 <code>pull</code> 的时候，docker 会默认为我加上 <code>docker.io/library</code> 的前缀。</p><p>如：当我执行 <code>docker pull mysql:5.7</code> 命令时，实际上相当于 <code>docker pull docker.io/mysql:5.7</code>，如果您未自定义配置仓库，则默认在下载的时候，会在镜像前面加上 DockerHub 的地址。</p><p>Docker 通过前缀地址的不同，来保证不同仓库中，重名镜像的唯一性。</p><h3 id="1-4-PULL-子命令"><a href="#1-4-PULL-子命令" class="headerlink" title="1.4 PULL 子命令"></a>1.4 PULL 子命令</h3><p>命令行中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull --help</span><br></pre></td></tr></table></figure><p>会得到如下信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">slimshady@MacBook-Pro ~ % docker pull --help</span><br><span class="line"></span><br><span class="line">Usage:docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br><span class="line"></span><br><span class="line">Pull an image or a repository from a registry</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --all-tags                Download all tagged images in the repository</span><br><span class="line">      --disable-content-trust   Skip image verification (default true)</span><br><span class="line">  -q, --quiet                   Suppress verbose output</span><br></pre></td></tr></table></figure><p>我们可以看到主要支持的子命令有：</p><ol><li><code>-a,--all-tags=true|false</code>: 是否获取仓库中所有镜像，默认为否；</li><li><code>--disable-content-trust</code>: 跳过镜像内容的校验，默认为 true;</li></ol><h2 id="查看镜像信息"><a href="#查看镜像信息" class="headerlink" title="查看镜像信息"></a>查看镜像信息</h2><h3 id="2-1-images-命令列出镜像"><a href="#2-1-images-命令列出镜像" class="headerlink" title="2.1 images 命令列出镜像"></a>2.1 images 命令列出镜像</h3><p>通过使用如下两个命令，列出本机已有的镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4sejxos4j31ma054td9.jpg" alt="image-20200525164236760"></p><p>解释：</p><ul><li><strong>REPOSITORY</strong>: 来自于哪个仓库；</li><li><strong>TAG</strong>: 镜像的标签信息，比如 5.7、latest 表示不同的版本信息；</li><li><strong>IMAGE ID</strong>: 镜像的 ID, 如果您看到两个 ID 完全相同，那么实际上，它们指向的是同一个镜像，只是标签名称不同罢了；</li><li><strong>CREATED</strong>: 镜像最后的更新时间；</li><li><strong>SIZE</strong>: 镜像的大小，优秀的镜像一般体积都比较小，这也是我更倾向于使用轻量级的 alpine 版本的原因；</li></ul><blockquote><p>  注意：图中的镜像大小信息只是逻辑上的大小信息，因为一个镜像是由多个镜像层（ <code>layer</code>）组成的，而相同的镜像层本地只会存储一份，所以，真实情况下，占用的物理存储空间大小，可能会小于逻辑大小。</p></blockquote><h3 id="2-2-使用-tag-命令为镜像添加标签"><a href="#2-2-使用-tag-命令为镜像添加标签" class="headerlink" title="2.2 使用 tag 命令为镜像添加标签"></a>2.2 使用 tag 命令为镜像添加标签</h3><p>通常情况下，为了方便在后续工作中，快速地找到某个镜像，我们可以使用 <code>docker tag</code> 命令，为本地镜像添加一个新的标签。<code>docker tag</code> 命令功能更像是, 为指定镜像添加快捷方式一样。</p><p>标签和原镜像的镜像 ID 是一模一样的，说明它们是同一个镜像，只是别名不同而已。</p><h3 id="2-3-使用-inspect-命令查看镜像详细信息"><a href="#2-3-使用-inspect-命令查看镜像详细信息" class="headerlink" title="2.3 使用 inspect 命令查看镜像详细信息"></a>2.3 使用 inspect 命令查看镜像详细信息</h3><p>通过 <code>docker inspect</code> 命令，我们可以获取镜像的详细信息，其中，包括创建者，各层的数字摘要等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect IMAGE ID</span><br></pre></td></tr></table></figure><p><code>docker inspect</code> 返回的是 <code>JSON</code> 格式的信息，如果您想获取其中指定的一项内容，可以通过 <code>-f</code> 来指定，如获取镜像大小：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f &#123;&#123;".Size"&#125;&#125; IMAGE ID</span><br></pre></td></tr></table></figure><h3 id="2-4-使用-history-命令查看镜像历史"><a href="#2-4-使用-history-命令查看镜像历史" class="headerlink" title="2.4 使用 history 命令查看镜像历史"></a>2.4 使用 history 命令查看镜像历史</h3><p>前面的小节中，我们知道了，一个镜像是由多个层（layer）组成的，那么，我们要如何知道各个层的具体内容呢？</p><p>通过 <code>docker history</code> 命令，可以列出各个层（layer）的创建信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker history IMAGE ID</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4t03poegj31mm0kw4kn.jpg" alt="image-20200525170130201"></p><p>可以看到，上面过长的信息，为了方便展示，后面都省略了，如果您想要看具体信息，可以通过添加 <code>--no-trunc</code> 选项，如下面命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker history --no-trunc IMAGE ID</span><br></pre></td></tr></table></figure><h2 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h2><h3 id="3-1-search-命令"><a href="#3-1-search-命令" class="headerlink" title="3.1 search 命令"></a>3.1 search 命令</h3><p>您可以通过下面命令进行搜索：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search [option] keyword</span><br></pre></td></tr></table></figure><p>比如，您想搜索仓库中 <code>mysql</code> 相关的镜像，可以输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure><h3 id="3-2-search-子命令"><a href="#3-2-search-子命令" class="headerlink" title="3.2 search 子命令"></a>3.2 search 子命令</h3><p>命令行输入 <code>docker search --help</code>, 输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">slimshady@MacBook-Pro ~ % docker search --help</span><br><span class="line"></span><br><span class="line">Usage:docker search [OPTIONS] TERM</span><br><span class="line"></span><br><span class="line">Search the Docker Hub for images</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Pretty-print search using a Go template</span><br><span class="line">      --limit int       Max number of search results (default 25)</span><br><span class="line">      --no-trunc        Don't truncate output</span><br></pre></td></tr></table></figure><p>可以看到 <code>search</code> 支持的子命令有：</p><ul><li><code>-f,--filter filter</code>: 过滤输出的内容；</li><li><code>--limit int</code>：指定搜索内容展示个数;</li><li><code>--no-trunc</code>：不截断输出内容；</li></ul><p>举个列子，比如我们想搜索官方提供的 mysql 镜像，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search --filter&#x3D;is-official&#x3D;true mysql</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4t3o28nsj31nk042n0v.jpg" alt="image-20200525170645573"></p><p>再比如，我们想搜索 Stars 数超过 100 的 mysql 镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search --filter&#x3D;stars&#x3D;100 mysql</span><br></pre></td></tr></table></figure><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><h3 id="4-1-通过标签删除镜像"><a href="#4-1-通过标签删除镜像" class="headerlink" title="4.1 通过标签删除镜像"></a>4.1 通过标签删除镜像</h3><p>通过如下两个都可以删除镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [image]</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm [image]</span><br></pre></td></tr></table></figure><p>支持的子命令如下：</p><ul><li><code>-f,-force</code>: 强制删除镜像，即便有容器引用该镜像；</li><li><code>-no-prune</code>: 不要删除未带标签的父镜像；</li></ul><p>对于带有标签的镜像：</p><p><strong>实际上，当同一个镜像拥有多个标签时，执行 <code>docker rmi</code> 命令，只是会删除了该镜像众多标签中，您指定的标签而已，并不会影响原始的那个镜像文件。</strong>如果某个镜像不存在多个标签，当且仅当只有一个标签时，执行删除命令时，您就要小心了，这会彻底删除镜像。</p><h3 id="4-2-通过-ID-删除镜像"><a href="#4-2-通过-ID-删除镜像" class="headerlink" title="4.2 通过 ID 删除镜像"></a>4.2 通过 ID 删除镜像</h3><p>除了通过标签名称来删除镜像，我们还可以通过制定镜像 ID, 来删除镜像，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi IMAGE ID</span><br></pre></td></tr></table></figure><p><strong>一旦制定了通过 ID 来删除镜像，它会先尝试删除所有指向该镜像的标签，然后在删除镜像本身。</strong></p><h3 id="4-3-删除镜像的限制"><a href="#4-3-删除镜像的限制" class="headerlink" title="4.3 删除镜像的限制"></a>4.3 删除镜像的限制</h3><p>删除镜像很简单，但也不是我们何时何地都能删除的，它存在一些限制条件。</p><p>当通过该镜像创建的容器未被销毁时，镜像是无法被删除的。因为有容器正在引用他。同时，可以通过添加 <code>-f</code> 子命令，也就是强制删除，才能移除掉该镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f IMAGE ID</span><br></pre></td></tr></table></figure><p>但是，我们一般不推荐这样暴力的做法，正确的做法应该是：</p><ol><li>先删除引用这个镜像的容器；</li><li>再删除这个镜像；</li></ol><h3 id="4-4-清理镜像"><a href="#4-4-清理镜像" class="headerlink" title="4.4 清理镜像"></a>4.4 清理镜像</h3><p>我们在使用 Docker 一段时间后，系统一般都会残存一些临时的、没有被使用的镜像文件，可以通过以下命令进行清理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure><p>它支持的子命令有：</p><ul><li><code>-a,--all</code>: 删除所有没有用的镜像，而不仅仅是临时文件；</li><li><code>-f,--force</code>：强制删除镜像文件，无需弹出提示确认；</li></ul><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p>Docker 创建镜像主要有三种：</p><ol><li>基于已有的镜像创建；</li><li>基于 Dockerfile 来创建；</li><li>基于本地模板来导入；</li></ol><p>我们将主要介绍常用的 1，2 两种。</p><h3 id="5-1-基于已有的镜像创建"><a href="#5-1-基于已有的镜像创建" class="headerlink" title="5.1 基于已有的镜像创建"></a>5.1 基于已有的镜像创建</h3><p>通过如下命令来创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container commit</span><br></pre></td></tr></table></figure><p>支持的子命令如下：</p><ul><li><code>-a,--author</code>=””: 作者信息；</li><li><code>-c,--change</code>=[]: 可以在提交的时候执行 Dockerfile 指令，如 CMD、ENTRYPOINT、ENV、EXPOSE、LABEL、ONBUILD、USER、VOLUME、WORIR 等；</li><li><code>-m,--message</code>=””: 提交信息；</li><li><code>-p,--pause</code>=true: 提交时，暂停容器运行。</li></ul><h3 id="5-2-基于-Dockerfile-创建"><a href="#5-2-基于-Dockerfile-创建" class="headerlink" title="5.2 基于 Dockerfile 创建"></a>5.2 基于 Dockerfile 创建</h3><p>通过 Dockerfile 的方式来创建镜像，是最常见的一种方式了，也是比较推荐的方式。Dockerfile 是一个文本指令文件，它描述了是如何基于一个父镜像，来创建一个新镜像的过程。</p><h2 id="导出-amp-加载镜像"><a href="#导出-amp-加载镜像" class="headerlink" title="导出&amp;加载镜像"></a>导出&amp;加载镜像</h2><p>通常我们会有下面这种需求，需要将镜像分享给别人，这个时候，我们可以将镜像导出成 tar 包，别人直接通过加载这个 tar 包，快速地将镜像引入到本地镜像库。</p><p>要想使用这两个功能，主要是通过如下两个命令：</p><ol><li><code>docker save</code></li><li><code>docker load</code></li></ol><h3 id="6-1-导出镜像"><a href="#6-1-导出镜像" class="headerlink" title="6.1 导出镜像"></a>6.1 导出镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o IMAGE ID</span><br></pre></td></tr></table></figure><h3 id="6-2-加载镜像"><a href="#6-2-加载镜像" class="headerlink" title="6.2 加载镜像"></a>6.2 加载镜像</h3><p>别人拿到了这个 <code>tar</code> 包后，要如何导入到本地的镜像库呢？</p><p>通过执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i xxx.tar</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; xxx.tar</span><br></pre></td></tr></table></figure><p>导入成功后，查看本地镜像信息，你就可以获得别人分享的镜像了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;  参考文档：&lt;a href=&quot;https://snailclimb.gitee.io/javaguide/#/docs/tools/Docker-Image&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://snailclimb.gitee.io/javaguide/#/docs/tools/Docker-Image&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Docker-下载镜像&quot;&gt;&lt;a href=&quot;#Docker-下载镜像&quot; class=&quot;headerlink&quot; title=&quot;Docker 下载镜像&quot;&gt;&lt;/a&gt;Docker 下载镜像&lt;/h2&gt;&lt;p&gt;如果我们想要在本地运行容器，就必须保证本地存在对应的镜像。所以，第一步，我们需要下载镜像。当我们尝试下载镜像时，Docker 会尝试先从默认的镜像仓库（默认使用 Docker Hub 公共仓库）去下载，当然了，用户也可以自定义配置想要下载的镜像仓库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="常用工具" scheme="http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="http://yoursite.com/2020/05/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    <id>http://yoursite.com/2020/05/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2020-06-08T00:57:51.991Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  参考文档：<a href="https://snailclimb.gitee.io/javaguide/#/docs/operating-system/linux" target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/docs/operating-system/linux</a></p></blockquote><h2 id="初探Linux"><a href="#初探Linux" class="headerlink" title="初探Linux"></a>初探Linux</h2><h3 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a>Linux简介</h3><ul><li><strong>类Unix系统：</strong> Linux是一种自由、开放源码的类似Unix的操作系统</li><li><strong>Linux内核：</strong> 严格来说，Linux这个词本身只表示Linux内核。</li></ul><a id="more"></a><h3 id="Linux的分类"><a href="#Linux的分类" class="headerlink" title="Linux的分类"></a>Linux的分类</h3><p><strong>Linux根据原生程度，分为两种：</strong></p><ol><li><strong>内核版本：</strong> Linux不是一个操作系统，严格来讲，Linux只是一个操作系统中的内核。内核是建立了计算机软件与硬件之间通讯的平台，内核提供系统服务，比如文件管理、虚拟内存、设备I/O等；</li><li><strong>发行版本：</strong> 一些组织或公司在内核版基础上进行二次开发而重新发行的版本。Linux发行版本有很多种（ubuntu和CentOS用的都很多，初学建议选择CentOS）</li></ol><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p><strong>在Linux操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</strong></p><p>也就是说在LINUX系统中有一个重要的概念：<strong>一切都是文件</strong>。其实这是UNIX哲学的一个体现，而Linux是重写UNIX而来，所以这个概念也就传承了下来。在UNIX系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。</p><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p><strong>Linux支持5种文件类型 ：</strong> </p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4h5yg9rcj30p10f7wg6.jpg" alt="文件类型" style="zoom:67%;" /><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p><strong>Linux的目录结构如下：</strong></p><p>Linux文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录： </p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4h5ydygyj30mv08rt8u.jpg" alt="Linux的目录结构" style="zoom:67%;" /><p><strong>常见目录说明：</strong></p><ul><li><strong>/bin：</strong> 存放二进制可执行文件(ls、cat、mkdir等)，常用命令一般都在这里；</li><li><strong>/etc：</strong> 存放系统管理和配置文件；</li><li><strong>/home：</strong> 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示；</li><li><strong>/usr ：</strong> 用于存放系统应用程序；</li><li><strong>/opt：</strong> 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里；</li><li><strong>/proc：</strong> 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li><li><strong>/root：</strong> 超级用户（系统管理员）的主目录（特权阶级^o^）；</li><li><strong>/sbin:</strong>   存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等；</li><li><strong>/dev：</strong> 用于存放设备文件；</li><li><strong>/mnt：</strong> 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li><li><strong>/boot：</strong> 存放用于系统引导时使用的各种文件；</li><li><strong>/lib ：</strong> 存放着和系统运行相关的库文件 ；</li><li><strong>/tmp：</strong> 用于存放各种临时文件，是公用的临时文件存储点；</li><li><strong>/var：</strong> 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li><li><strong>/lost+found：</strong> 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里。</li></ul><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>下面只是给出了一些比较常用的命令。推荐一个Linux命令快查网站，非常不错，大家如果遗忘某些命令或者对某些命令不理解都可以在这里得到解决。</p><p>Linux命令大全：<a href="http://man.linuxde.net/" target="_blank" rel="noopener">http://man.linuxde.net/</a></p><h3 id="目录切换命令"><a href="#目录切换命令" class="headerlink" title="目录切换命令"></a>目录切换命令</h3><ul><li><strong><code>cd usr</code>：</strong> 切换到该目录下usr目录</li><li><strong><code>cd ..（或cd../）</code>：</strong> 切换到上一层目录</li><li><strong><code>cd /</code>：</strong> 切换到系统根目录</li><li><strong><code>cd ~</code>：</strong> 切换到用户主目录</li><li><strong><code>cd -</code>：</strong> 切换到上一个操作所在目录</li></ul><h3 id="目录的操作命令-增删改查"><a href="#目录的操作命令-增删改查" class="headerlink" title="目录的操作命令(增删改查)"></a>目录的操作命令(增删改查)</h3><ol><li><p><strong><code>mkdir 目录名称</code>：</strong> 增加目录</p></li><li><p><strong><code>ls或者ll</code></strong>（ll是ls -l的别名，ll命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息</p></li><li><p><strong><code>find 目录 参数</code>：</strong> 寻找目录（查）</p><blockquote><p>  示例：</p><ul><li>列出当前目录及子目录下所有文件和文件夹: <code>find .</code></li><li>在<code>/home</code>目录下查找以.txt结尾的文件名:<code>find /home -name &quot;*.txt&quot;</code></li><li>同上，但忽略大小写: <code>find /home -iname &quot;*.txt&quot;</code></li><li>当前目录及子目录下查找所有以.txt和.pdf结尾的文件:<code>find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</code>或<code>find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</code></li></ul></blockquote></li><li><p><strong><code>mv 目录名称 新目录名称</code>：</strong> 修改目录的名称（改）</p><p>注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行重命名的操作。mv命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。</p></li><li><p><strong><code>mv 目录名称 目录的新位置</code>：</strong> 移动目录的位置—剪切（改）</p><p>注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外mv与cp的结果不同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。</p></li><li><p><strong><code>cp -r 目录名称 目录拷贝的目标位置</code>：</strong> 拷贝目录（改），-r代表递归拷贝</p><p>注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r递归</p></li><li><p><strong><code>rm [-rf] 目录</code>:</strong> 删除目录（删）</p><p>注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用<code>rm -rf</code> 目录/文件/压缩包</p></li></ol><h3 id="文件的操作命令-增删改查"><a href="#文件的操作命令-增删改查" class="headerlink" title="文件的操作命令(增删改查)"></a>文件的操作命令(增删改查)</h3><ol><li><p><strong><code>touch 文件名称</code>:</strong> 文件的创建（增）</p></li><li><p><strong><code>cat/more/less/tail 文件名称</code></strong> 文件的查看（查）</p><ul><li><strong><code>cat</code>：</strong> 查看显示文件内容</li><li><strong><code>more</code>：</strong> 可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看</li><li><strong><code>less</code>：</strong> 可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看</li><li><strong><code>tail-10</code> ：</strong> 查看文件的后10行，Ctrl+C结束</li></ul><p>注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件， 会随着程序的运行，日志会变化，可以使用tail -f catalina-2016-11-11.log 监控 文 件的变化</p></li><li><p><strong><code>vim 文件</code>：</strong> 修改文件的内容（改）</p><p>vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。</p><p><strong>在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤：</strong></p><p>vim 文件——&gt;进入文件—–&gt;命令模式——&gt;按i进入编辑模式—–&gt;编辑文件 ——-&gt;按Esc进入底行模式—–&gt;输入：wq/q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。）</p></li><li><p><strong><code>rm -rf 文件</code>：</strong> 删除文件（删）</p><p>同目录删除：熟记 <code>rm -rf</code> 文件 即可</p></li></ol><h3 id="压缩文件的操作命令"><a href="#压缩文件的操作命令" class="headerlink" title="压缩文件的操作命令"></a>压缩文件的操作命令</h3><p><strong>1）打包并压缩文件：</strong></p><p>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。</p><p>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。 </p><p>命令：<strong><code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code></strong>  其中：</p><ul><li>z：调用gzip压缩命令进行压缩</li><li>c：打包文件</li><li>v：显示运行过程</li><li>f：指定文件名</li></ul><p>比如：假如test目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包test目录并指定压缩后的压缩包名称为test.tar.gz可以使用命令：<strong><code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code>或：<code>tar -zcvf test.tar.gz       /test/</code></strong></p><p><strong>2）解压压缩包：</strong></p><p>命令：<strong><code>tar [-xvf] 压缩文件</code></strong></p><p>其中：</p><ul><li>x：代表解压</li></ul><p>示例：</p><ol><li><p>将/test下的test.tar.gz解压到当前目录下可以使用命令：<strong><code>tar -xvf test.tar.gz</code></strong></p></li><li><p>将/test下的test.tar.gz解压到根目录/usr下:<strong><code>tar -xvf test.tar.gz -C /usr</code></strong>（- C代表指定解压的位置）</p></li></ol><h3 id="权限命令"><a href="#权限命令" class="headerlink" title="权限命令"></a>权限命令</h3><p>操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在Linux中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。分别对应文件的属主(owner)，属组(group)和其他用户(other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。通过 <strong><code>ls -l</code></strong> 命令我们可以 查看某个目录下的文件或目录的权限</p><p>示例：在随意某个目录下<code>ls -l</code></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5tzujt2nj30gd06ct9u.jpg" alt="img"></p><p>第一列的内容的信息解释如下：</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4hogpjsnj30dl05tt9i.jpg" alt="img" style="zoom:67%;" /><p><strong>文件的类型：</strong></p><ul><li>d： 代表目录</li><li>-： 代表文件</li><li>l： 代表软链接（可以认为是window中的快捷方式）</li></ul><p><strong>Linux中权限分为以下几种：</strong></p><ul><li>r： 代表权限是可读，r也可以用数字4表示</li><li>w：代表权限是可写，w也可以用数字2表示</li><li>x： 代表权限是可执行，x也可以用数字1表示</li></ul><p><strong>文件和目录权限的区别：</strong></p><p>对文件和目录而言，读写执行表示不同的意义。</p><p>对于文件：</p><table><thead><tr><th>权限名称</th><th>可执行操作</th></tr></thead><tbody><tr><td>r</td><td>可以使用cat查看文件的内容</td></tr><tr><td>w</td><td>可以修改文件的内容</td></tr><tr><td>x</td><td>可以将其运行为二进制文件</td></tr></tbody></table><p>对于目录：</p><table><thead><tr><th>权限名称</th><th>可执行操作</th></tr></thead><tbody><tr><td>r</td><td>可以查看目录下列表</td></tr><tr><td>w</td><td>可以创建和删除目录下文件</td></tr><tr><td>x</td><td>可以使用cd进入目录</td></tr></tbody></table><p><strong>需要注意的是超级用户可以无视普通用户的权限，即使文件目录权限是000，依旧可以访问。</strong> <strong>在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。</strong></p><ul><li><p><strong>所有者</strong></p><p>一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用ls ‐ahl命令可以看到文件的所有者 也可以使用chown 用户名 文件名来修改文件的所有者 。</p></li><li><p><strong>文件所在组</strong></p><p>当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组，用<code>ls ‐ahl</code>命令可以看到文件的所有组，也可以使用 <code>chgrp 组名 文件名</code> 来修改文件所在的组。</p></li><li><p><strong>其它组</strong></p><p>除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组</p></li></ul><p><strong>修改文件/目录的权限的命令：<code>chmod</code></strong></p><p>示例：修改/test下的aaa.txt的权限为属主有全部权限，属主所在的组有读写权限， 其他用户只有读的权限</p><p><strong><code>chmod u=rwx,g=rw,o=r aaa.txt</code></strong></p><p><strong><code>chmod -R u=rwx,g=rwx,o=rwx ./log</code></strong>     // 递归给log目录下的所有文件授权</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5tzvbeb2j30el06u0tf.jpg" alt="img"></p><p>上述示例还可以使用数字表示：</p><p><strong><code>chmod 764 aaa.txt</code></strong></p><blockquote><p>  <strong>补充一个比较常用的东西</strong>:</p><p>  假如我们装了一个zookeeper，我们每次开机到要求其自动启动该怎么办？</p><ol><li>新建一个脚本zookeeper</li><li>为新建的脚本zookeeper添加可执行权限，命令是:<code>chmod +x zookeeper</code></li><li>把zookeeper这个脚本添加到开机启动项里面，命令是：<code>chkconfig --add zookeeper</code></li><li>如果想看看是否添加成功，命令是：<code>chkconfig --list</code></li></ol></blockquote><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p><strong>Linux用户管理相关命令:</strong></p><ul><li><code>useradd 选项 用户名</code>: 添加用户账号</li><li><code>userdel 选项 用户名</code>: 删除用户帐号</li><li><code>usermod 选项 用户名</code>: 修改帐号</li><li><code>passwd 用户名</code>: 更改或创建用户的密码</li><li><code>passwd -S 用户名</code> : 显示用户账号密码信息</li><li><code>passwd -d 用户名</code>:  清除用户密码</li></ul><p><code>useradd</code>命令用于Linux中创建的新的系统用户。<code>useradd</code>可用来建立用户帐号。帐号建好之后，再用<code>passwd</code>设定帐号的密码。而可用<code>userdel</code>删除帐号。使用<code>useradd</code>指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。</p><p><code>passwd</code>命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。</p><h3 id="用户组的管理"><a href="#用户组的管理" class="headerlink" title="用户组的管理"></a>用户组的管理</h3><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p><p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。</p><p><strong>Linux系统用户组的管理相关命令:</strong></p><ul><li><code>groupadd 选项 用户组</code> :增加一个新的用户组</li><li><code>groupdel 用户组</code>:要删除一个已有的用户组</li><li><code>groupmod 选项 用户组</code> : 修改用户组的属性</li></ul><h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><ul><li><p><strong><code>pwd</code>：</strong> 显示当前所在位置</p></li><li><p><strong><code>sudo + 其他命令</code></strong>：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。</p></li><li><p><strong><code>grep 要搜索的字符串 要搜索的文件 --color</code>：</strong> 搜索命令，–color代表高亮显示</p></li><li><p><strong><code>ps -ef</code>/<code>ps -aux</code>：</strong> 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：<strong><code>ps aux|grep redis</code></strong> （查看包括redis字符串的进程），也可使用 <strong><code>pgrep redis -a</code></strong>。</p><p>注意：如果直接用ps（Process Status）命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。</p></li><li><p><strong><code>kill -9 进程的pid</code>：</strong> 杀死进程（-9 表示强制终止。）</p><p>先用ps查找进程，然后用kill杀掉</p></li><li><p><strong>网络通信命令：</strong></p><ul><li>查看当前系统的网卡信息：ifconfig</li><li>查看与某台机器的连接情况：ping</li><li>查看当前系统的端口使用：netstat -an</li></ul></li><li><p><strong><code>shutdown</code>：</strong> <code>shutdown -h now</code>： 指定现在立即关机；<code>shutdown +5 &quot;System will shutdown after 5 minutes&quot;</code>：指定5分钟后关机，同时送出警告信息给登入用户。</p></li><li><p><strong><code>reboot</code>：</strong>重开机。<strong><code>reboot -w</code>：</strong> 做个重开机的模拟（只有纪录并不会真的重开机）。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;  参考文档：&lt;a href=&quot;https://snailclimb.gitee.io/javaguide/#/docs/operating-system/linux&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://snailclimb.gitee.io/javaguide/#/docs/operating-system/linux&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;初探Linux&quot;&gt;&lt;a href=&quot;#初探Linux&quot; class=&quot;headerlink&quot; title=&quot;初探Linux&quot;&gt;&lt;/a&gt;初探Linux&lt;/h2&gt;&lt;h3 id=&quot;Linux简介&quot;&gt;&lt;a href=&quot;#Linux简介&quot; class=&quot;headerlink&quot; title=&quot;Linux简介&quot;&gt;&lt;/a&gt;Linux简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;类Unix系统：&lt;/strong&gt; Linux是一种自由、开放源码的类似Unix的操作系统&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Linux内核：&lt;/strong&gt; 严格来说，Linux这个词本身只表示Linux内核。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://yoursite.com/2020/05/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2020/05/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2020-06-08T00:57:51.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="一、基本特征"><a href="#一、基本特征" class="headerlink" title="一、基本特征"></a>一、基本特征</h3><h4 id="1-并发"><a href="#1-并发" class="headerlink" title="1. 并发"></a>1. 并发</h4><p><strong>并发</strong>是指宏观上在一段时间内能同时运行多个程序，而<strong>并行</strong>则指同一时刻能运行多个指令。</p><p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</p><p>操作系统通过引入进程和线程，使得程序能够并发运行。</p><h4 id="2-共享"><a href="#2-共享" class="headerlink" title="2. 共享"></a>2. 共享</h4><p>共享是指系统中的资源可以被多个并发进程共同使用。</p><p>有两种共享方式：<strong>互斥共享</strong>和<strong>同时共享</strong>。</p><p>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</p><a id="more"></a><h4 id="3-虚拟"><a href="#3-虚拟" class="headerlink" title="3. 虚拟"></a>3. 虚拟</h4><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p><p>主要有两种虚拟技术：<strong>时（时间）分复用技术</strong>和<strong>空（空间）分复用技术</strong>。</p><p>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p><p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p><h4 id="4-异步"><a href="#4-异步" class="headerlink" title="4. 异步"></a>4. 异步</h4><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p><h3 id="二、基本功能"><a href="#二、基本功能" class="headerlink" title="二、基本功能"></a>二、基本功能</h3><h4 id="1-进程管理"><a href="#1-进程管理" class="headerlink" title="1. 进程管理"></a>1. 进程管理</h4><p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p><h4 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h4><p>内存分配、地址映射、内存保护与共享、虚拟内存等。</p><h4 id="3-文件管理"><a href="#3-文件管理" class="headerlink" title="3. 文件管理"></a>3. 文件管理</h4><p>文件存储空间的管理、目录管理、文件读写管理和保护等。</p><h4 id="4-设备管理"><a href="#4-设备管理" class="headerlink" title="4. 设备管理"></a>4. 设备管理</h4><p>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</p><p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p><h3 id="三、系统调用"><a href="#三、系统调用" class="headerlink" title="三、系统调用"></a>三、系统调用</h3><p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5tzwoa1bj30kx0cu0uv.jpg" alt="img"></p><p>Linux 的系统调用主要有以下这些：</p><table><thead><tr><th>Task</th><th>Commands</th></tr></thead><tbody><tr><td>进程控制</td><td>fork(); exit(); wait();</td></tr><tr><td>进程通信</td><td>pipe(); shmget(); mmap();</td></tr><tr><td>文件操作</td><td>open(); read(); write();</td></tr><tr><td>设备操作</td><td>ioctl(); read(); write();</td></tr><tr><td>信息维护</td><td>getpid(); alarm(); sleep();</td></tr><tr><td>安全</td><td>chmod(); umask(); chown();</td></tr></tbody></table><h3 id="四、大内核和微内核"><a href="#四、大内核和微内核" class="headerlink" title="四、大内核和微内核"></a>四、大内核和微内核</h3><h4 id="1-大内核"><a href="#1-大内核" class="headerlink" title="1. 大内核"></a>1. 大内核</h4><p>大内核是将操作系统功能作为一个紧密结合的整体放到内核。</p><p>由于各模块共享信息，因此有很高的性能。</p><h4 id="2-微内核"><a href="#2-微内核" class="headerlink" title="2. 微内核"></a>2. 微内核</h4><p>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。</p><p>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。</p><p>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5tzxjpyyj30gx0870v1.jpg" alt="img"></p><h3 id="五、中断分类"><a href="#五、中断分类" class="headerlink" title="五、中断分类"></a>五、中断分类</h3><h4 id="1-外中断"><a href="#1-外中断" class="headerlink" title="1. 外中断"></a>1. 外中断</h4><p>由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p><h4 id="2-异常"><a href="#2-异常" class="headerlink" title="2. 异常"></a>2. 异常</h4><p>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p><h4 id="3-陷入"><a href="#3-陷入" class="headerlink" title="3. 陷入"></a>3. 陷入</h4><p>在用户程序中使用系统调用。</p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="一、进程与线程"><a href="#一、进程与线程" class="headerlink" title="一、进程与线程"></a>一、进程与线程</h3><h4 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h4><p><strong>进程是资源分配的基本单位。</strong></p><p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p><p>下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5tzy18jvj30mb0840t3.jpg" alt="img"></p><h4 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h4><p><strong>线程是独立调度的基本单位。</strong></p><p>一个进程中可以有多个线程，它们共享进程资源。</p><p>QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5tzyx7vnj30a708g0sm.jpg" alt="img"></p><h4 id="3-进程与线程的区别"><a href="#3-进程与线程的区别" class="headerlink" title="3. 进程与线程的区别"></a>3. 进程与线程的区别</h4><p>线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。</p><ul><li><strong>根本区别：</strong>进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</li><li><strong>资源开销：</strong>每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</li><li><strong>包含关系：</strong>如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</li><li><strong>内存分配：</strong>同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的</li><li><strong>影响关系：</strong>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</li><li><strong>执行过程：</strong>每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</li></ul><h4 id="4-多进程和多线程的选择"><a href="#4-多进程和多线程的选择" class="headerlink" title="4. 多进程和多线程的选择"></a>4. 多进程和多线程的选择</h4><p><img src="C:/Users/Slimshady/AppData/Roaming/Typora/typora-user-images/image-20200420104050516.png" alt="image-20200420104050516"></p><ol><li><p>需要频繁创建销毁的优先用线程</p><p>原因请看上面的对比。</p><p>这种原则最常见的应用就是Web服务器了，来一个连接建立一个线程，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的</p></li><li><p>需要进行大量计算的优先使用线程</p><p>所谓大量计算，当然就是要耗费很多CPU，切换频繁了，这种情况下线程是最合适的。</p><p>这种原则最常见的是图像处理、算法处理。</p></li><li><p>强相关的处理用线程，弱相关的处理用进程</p><p>什么叫强相关、弱相关？理论上很难定义，给个简单的例子就明白了。</p><p>一般的Server需要完成如下任务：消息收发、消息处理。“消息收发”和“消息处理”就是弱相关的任务，而“消息处理”里面可能又分为“消息解码”、“业务处理”，这两个任务相对来说相关性就要强多了。因此“消息收发”和“消息处理”可以分进程设计，“消息解码”、“业务处理”可以分线程设计。</p><p>当然这种划分方式不是一成不变的，也可以根据实际情况进行调整。</p></li><li><p>可能要扩展到多机分布的用进程，多核分布的用线程</p><p>原因请看上面对比。</p></li><li><p>都满足需求的情况下，用你最熟悉、最拿手的方式</p><p>至于“数据共享、同步”、“编程、调试”、“可靠性”这几个维度的所谓的“复杂、简单”应该怎么取舍，我只能说：没有明确的选择方法。但我可以告诉你一个选择原则：如果多进程和多线程都能够满足要求，那么选择你最熟悉、最拿手的那个。</p></li></ol><h3 id="二、进程状态的切换"><a href="#二、进程状态的切换" class="headerlink" title="二、进程状态的切换"></a>二、进程状态的切换</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5tzztfmzj30iv0c60t1.jpg" alt="img"></p><ul><li>就绪状态（ready）：等待被调度</li><li>运行状态（running）</li><li>阻塞状态（waiting）：等待资源</li></ul><p>应该注意以下内容：</p><ul><li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li><li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li></ul><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p><h4 id="1-批处理系统"><a href="#1-批处理系统" class="headerlink" title="1. 批处理系统"></a>1. 批处理系统</h4><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p><p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong></p><p><strong>非抢占式</strong>的调度算法，按照请求的顺序进行调度。</p><p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p><p><strong>1.2 短作业优先 shortest job first（SJF）</strong></p><p><strong>非抢占式</strong>的调度算法，按估计运行时间最短的顺序进行调度。</p><p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p><p><strong>1.3 最短剩余时间优先 shortest remaining time next（SRTN）</strong></p><p>最短作业优先的<strong>抢占式</strong>版本，按剩余运行时间的顺序进行调度。</p><p>当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p><h4 id="2-交互式系统"><a href="#2-交互式系统" class="headerlink" title="2. 交互式系统"></a>2. 交互式系统</h4><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p><p><strong>2.1 时间片轮转</strong></p><p>将所有就绪进程按 <strong>FCFS</strong> 的原则排成一个<strong>队列</strong>，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p><p>时间片轮转算法的效率和时间片的大小有很大关系：</p><ul><li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li><li>而如果时间片过长，那么实时性就不能得到保证。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u008u0zj309x03f0sm.jpg" alt="img"></p><p><strong>2.2 优先级调度</strong></p><p>为每个进程分配一个<strong>优先级</strong>，按优先级进行调度。</p><p>为了防止低优先级的进程永远等不到调度，可以<strong>随着时间的推移增加等待进程的优先级</strong>。</p><p><strong>2.3 多级反馈队列</strong></p><p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p><p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u016h4tj30c60860t5.jpg" alt="img"></p><h4 id="3-实时系统"><a href="#3-实时系统" class="headerlink" title="3. 实时系统"></a>3. 实时系统</h4><p>实时系统要求一个请求在一个确定时间内得到响应。</p><p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p><h3 id="三、进程同步"><a href="#三、进程同步" class="headerlink" title="三、进程同步"></a>三、进程同步</h3><h4 id="1-临界区"><a href="#1-临界区" class="headerlink" title="1. 临界区"></a>1. 临界区</h4><p><strong>对临界资源进行访问</strong>的那段代码称为临界区。</p><p>为了互斥访问临界资源，<strong>每个进程在进入临界区之前，需要先进行检查</strong>。</p><h4 id="2-同步与互斥"><a href="#2-同步与互斥" class="headerlink" title="2. 同步与互斥"></a>2. 同步与互斥</h4><ul><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li></ul><h4 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h4><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p><ul><li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li><li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li></ul><p>down 和 up 操作需要被设计成<strong>原语</strong>，不可分割，通常的做法是在<strong>执行这些操作的时候屏蔽中断</strong>。</p><p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用信号量实现生产者-消费者问题</strong></p><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p><p>因为缓冲区属于临界资源，因此需要使用一个互斥量 <code>mutex</code> 来控制对缓冲区的互斥访问。</p><p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p><p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="keyword">int</span> item = produce_item();</span><br><span class="line">        down(&amp;empty);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;full);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        <span class="keyword">int</span> item = remove_item();</span><br><span class="line">        consume_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-管程"><a href="#4-管程" class="headerlink" title="4. 管程"></a>4. 管程</h4><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p><p>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    integer i;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">remove</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br></pre></td></tr></table></figure><p>管程有一个重要特性：<strong>在一个时刻只能有一个进程使用管程</strong>。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p><p>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p><p><strong>使用管程实现生产者-消费者问题</strong></p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管程</span></span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;</span><br><span class="line">    integer count := <span class="number">0</span>;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(item: integer)</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = N <span class="keyword">then</span> wait(full);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count := count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">1</span> <span class="keyword">then</span> signal(empty);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>:</span> integer;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">0</span> <span class="keyword">then</span> wait(empty);</span><br><span class="line">        remove = remove_item;</span><br><span class="line">        count := count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = N -<span class="number">1</span> <span class="keyword">then</span> signal(full);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">producer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">produce_item</span>;</span></span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">ProducerConsumer</span>.<span class="title">remove</span>;</span></span><br><span class="line">        consume_item(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h3 id="四、经典同步问题"><a href="#四、经典同步问题" class="headerlink" title="四、经典同步问题"></a>四、经典同步问题</h3><h4 id="1-生产者消费者问题"><a href="#1-生产者消费者问题" class="headerlink" title="1. 生产者消费者问题"></a>1. 生产者消费者问题</h4><p>生产者和消费者问题前面已经讨论过了。</p><h4 id="2-哲学家进餐问题"><a href="#2-哲学家进餐问题" class="headerlink" title="2. 哲学家进餐问题"></a>2. 哲学家进餐问题</h4><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a9077f06-7584-4f2b-8c20-3a8e46928820.jpg" alt="img" style="zoom:50%;" /><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p><p>下面是一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think();</span><br><span class="line">        take(i);       <span class="comment">// 拿起左边的筷子</span></span><br><span class="line">        take((i+<span class="number">1</span>)%N); <span class="comment">// 拿起右边的筷子</span></span><br><span class="line">        eat();</span><br><span class="line">        <span class="built_in">put</span>(i);</span><br><span class="line">        <span class="built_in">put</span>((i+<span class="number">1</span>)%N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止死锁的发生，可以设置两个条件：</p><ul><li>必须同时拿起左右两根筷子；</li><li>只有在两个邻居都没有进餐的情况下才允许进餐。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT (i + N - 1) % N <span class="comment">// 左邻居</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT (i + 1) % N    <span class="comment">// 右邻居</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUNGRY   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EATING   2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line"><span class="keyword">int</span> state[N];                <span class="comment">// 跟踪每个哲学家的状态</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;         <span class="comment">// 临界区的互斥，临界区是 state 数组，对其修改需要互斥</span></span><br><span class="line">semaphore s[N];              <span class="comment">// 每个哲学家一个信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think(i);</span><br><span class="line">        take_two(i);</span><br><span class="line">        eat(i);</span><br><span class="line">        put_two(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take_two</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = HUNGRY;</span><br><span class="line">    check(i);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">    down(&amp;s[i]); <span class="comment">// 只有收到通知之后才可以开始吃，否则会一直等下去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_two</span><span class="params">(i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = THINKING;</span><br><span class="line">    check(LEFT); <span class="comment">// 尝试通知左右邻居，自己吃完了，你们可以开始吃了</span></span><br><span class="line">    check(RIGHT);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = EATING;</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查两个邻居是否都没有用餐，如果是的话，就 up(&amp;s[i])，使得 down(&amp;s[i]) 能够得到通知并继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(i)</span> </span>&#123;         </span><br><span class="line">    <span class="keyword">if</span>(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123;</span><br><span class="line">        state[i] = EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-读者-写者问题"><a href="#3-读者-写者问题" class="headerlink" title="3. 读者-写者问题"></a>3. 读者-写者问题</h4><p>允许多个进程同时对数据进行读操作，但是不允许<strong>读和写</strong>以及<strong>写和写</strong>操作同时发生。</p><p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore count_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) down(&amp;data_mutex); <span class="comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span></span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">        <span class="built_in">read</span>();</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) up(&amp;data_mutex);</span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;data_mutex);</span><br><span class="line">        <span class="built_in">write</span>();</span><br><span class="line">        up(&amp;data_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、进程通信"><a href="#五、进程通信" class="headerlink" title="五、进程通信"></a>五、进程通信</h3><p>进程同步与进程通信很容易混淆，它们的区别在于：</p><ul><li>进程同步：控制多个进程按一定顺序执行；</li><li>进程通信：进程间传输信息。</li></ul><p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p><h4 id="1-管道"><a href="#1-管道" class="headerlink" title="1. 管道"></a>1. 管道</h4><p>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>它具有以下限制：</p><ul><li>只支持半双工通信（单向交替传输）；</li><li>只能在父子进程或者兄弟进程中使用。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u029s7pj30e907t0sr.jpg" alt="img"></p><h4 id="2-FIFO"><a href="#2-FIFO" class="headerlink" title="2. FIFO"></a>2. FIFO</h4><p>也称为命名管道，去除了管道只能在父子进程中使用的限制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifoat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u032b2mj30hr0cc0sz.jpg" alt="img"></p><h4 id="3-消息队列"><a href="#3-消息队列" class="headerlink" title="3. 消息队列"></a>3. 消息队列</h4><p>相比于 FIFO，消息队列具有以下优点：</p><ul><li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li><li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li><li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li></ul><h4 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4. 信号量"></a>4. 信号量</h4><p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p><h4 id="5-共享存储"><a href="#5-共享存储" class="headerlink" title="5. 共享存储"></a>5. 共享存储</h4><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p><p>需要使用信号量用来同步对共享存储的访问。</p><p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。</p><h4 id="6-套接字"><a href="#6-套接字" class="headerlink" title="6. 套接字"></a>6. 套接字</h4><p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="一、必要条件"><a href="#一、必要条件" class="headerlink" title="一、必要条件"></a>一、必要条件</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u03lmccj30fk0730t2.jpg" alt="img"></p><ul><li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li><li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li><li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li><li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li></ul><h3 id="二、处理方法"><a href="#二、处理方法" class="headerlink" title="二、处理方法"></a>二、处理方法</h3><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p><p><strong>破坏互斥条件</strong></p><p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p><p><strong>破坏请求与保持条件</strong></p><p>一次性申请所有的资源。</p><p><strong>破坏不剥夺条件</strong></p><p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p><strong>破坏循环等待条件</strong></p><p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p><p>主要有以下四种方法：</p><ul><li>鸵鸟策略</li><li>死锁检测与死锁恢复</li><li>死锁预防</li><li>死锁避免</li></ul><h3 id="三、鸵鸟策略"><a href="#三、鸵鸟策略" class="headerlink" title="三、鸵鸟策略"></a>三、鸵鸟策略</h3><p>把头埋在沙子里，假装根本没发生问题。</p><p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p><p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p><p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p><h3 id="四、死锁检测与死锁恢复"><a href="#四、死锁检测与死锁恢复" class="headerlink" title="四、死锁检测与死锁恢复"></a>四、死锁检测与死锁恢复</h3><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p><h4 id="1-每种类型一个资源的死锁检测"><a href="#1-每种类型一个资源的死锁检测" class="headerlink" title="1. 每种类型一个资源的死锁检测"></a>1. 每种类型一个资源的死锁检测</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u04g7o6j30gl08h0t5.jpg" alt="img"></p><p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p><p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p><p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p><h4 id="2-每种类型多个资源的死锁检测"><a href="#2-每种类型多个资源的死锁检测" class="headerlink" title="2. 每种类型多个资源的死锁检测"></a>2. 每种类型多个资源的死锁检测</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u05ff8aj30cg0640sy.jpg" alt="img"></p><p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p><ul><li>E 向量：资源总量</li><li>A 向量：资源剩余量</li><li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li><li>R 矩阵：每个进程请求的资源数量</li></ul><p>进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。</p><p>算法总结如下：</p><p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p><ol><li>寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。</li><li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li><li>如果没有这样一个进程，算法终止。</li></ol><h4 id="3-死锁恢复"><a href="#3-死锁恢复" class="headerlink" title="3. 死锁恢复"></a>3. 死锁恢复</h4><ul><li>利用抢占恢复</li><li>利用回滚恢复</li><li>通过杀死进程恢复</li></ul><h3 id="五、死锁预防"><a href="#五、死锁预防" class="headerlink" title="五、死锁预防"></a>五、死锁预防</h3><p>在程序运行之前预防发生死锁。</p><h4 id="1-破坏互斥条件"><a href="#1-破坏互斥条件" class="headerlink" title="1. 破坏互斥条件"></a>1. 破坏互斥条件</h4><p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p><h4 id="2-破坏占有和等待条件"><a href="#2-破坏占有和等待条件" class="headerlink" title="2. 破坏占有和等待条件"></a>2. 破坏占有和等待条件</h4><p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p><h4 id="3-破坏不可抢占条件"><a href="#3-破坏不可抢占条件" class="headerlink" title="3. 破坏不可抢占条件"></a>3. 破坏不可抢占条件</h4><h4 id="4-破坏环路等待"><a href="#4-破坏环路等待" class="headerlink" title="4. 破坏环路等待"></a>4. 破坏环路等待</h4><p>给资源统一编号，进程只能按编号顺序来请求资源。</p><h3 id="六、死锁避免"><a href="#六、死锁避免" class="headerlink" title="六、死锁避免"></a>六、死锁避免</h3><p>在程序运行时避免发生死锁。</p><h4 id="1-安全状态"><a href="#1-安全状态" class="headerlink" title="1. 安全状态"></a>1. 安全状态</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u06cwtmj30hz04y0t3.jpg" alt="img"></p><p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p><p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p><p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p><h4 id="2-单个资源的银行家算法"><a href="#2-单个资源的银行家算法" class="headerlink" title="2. 单个资源的银行家算法"></a>2. 单个资源的银行家算法</h4><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u06weo9j30fr06f0t3.jpg" alt="img"></p><p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p><h4 id="3-多个资源的银行家算法"><a href="#3-多个资源的银行家算法" class="headerlink" title="3. 多个资源的银行家算法"></a>3. 多个资源的银行家算法</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u07vflaj30e707m0tb.jpg" alt="img"></p><p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。</p><p>检查一个状态是否安全的算法如下：</p><ul><li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li><li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li><li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li></ul><p>如果一个状态不是安全的，需要拒绝进入这个状态。</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="一、虚拟内存"><a href="#一、虚拟内存" class="headerlink" title="一、虚拟内存"></a>一、虚拟内存</h3><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p><p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p><p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u08o06yj30dn0c90to.jpg" alt="img"></p><h3 id="二、分页系统地址映射"><a href="#二、分页系统地址映射" class="headerlink" title="二、分页系统地址映射"></a>二、分页系统地址映射</h3><p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p><p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p><p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u0952b7j30hv0jc0uh.jpg" alt="img"></p><h3 id="三、页面置换算法"><a href="#三、页面置换算法" class="headerlink" title="三、页面置换算法"></a>三、页面置换算法</h3><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p><p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p><p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p><h4 id="1-最佳OPT"><a href="#1-最佳OPT" class="headerlink" title="1. 最佳OPT"></a>1. 最佳OPT</h4><blockquote><p>  OPT, Optimal replacement algorithm</p></blockquote><p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p><p>是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p><p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1</span><br></pre></td></tr></table></figure><p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</p><h4 id="2-最近最久未使用LRU"><a href="#2-最近最久未使用LRU" class="headerlink" title="2. 最近最久未使用LRU"></a>2. 最近最久未使用LRU</h4><blockquote><p>  LRU, Least Recently Used</p></blockquote><p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p><p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p><p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4，7，0，7，1，0，1，2，1，2，6</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u0a3qujj30ex04m0su.jpg" alt="img"></p><h4 id="3-最近未使用NRU"><a href="#3-最近未使用NRU" class="headerlink" title="3. 最近未使用NRU"></a>3. 最近未使用NRU</h4><blockquote><p>  NRU, Not Recently Used</p></blockquote><p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：</p><ul><li>R=0，M=0</li><li>R=0，M=1</li><li>R=1，M=0</li><li>R=1，M=1</li></ul><p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p><p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p><h4 id="4-先进先出FIFO"><a href="#4-先进先出FIFO" class="headerlink" title="4. 先进先出FIFO"></a>4. 先进先出FIFO</h4><blockquote><p>  FIFO, First In First Out</p></blockquote><p>选择换出的页面是最先进入的页面。</p><p>该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。</p><h4 id="5-第二次机会算法"><a href="#5-第二次机会算法" class="headerlink" title="5. 第二次机会算法"></a>5. 第二次机会算法</h4><p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p><p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u0b2nzuj30k008o0t1.jpg" alt="img"></p><h4 id="6-时钟"><a href="#6-时钟" class="headerlink" title="6. 时钟"></a>6. 时钟</h4><blockquote><p>  Clock</p></blockquote><p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u0bzbdnj30fp08w0ta.jpg" alt="img"></p><h3 id="四、分段"><a href="#四、分段" class="headerlink" title="四、分段"></a>四、分段</h3><p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p><p>下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u0chstcj30ck09n0t8.jpg" alt="img"></p><p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u0cwm4rj30g507y0t0.jpg" alt="img"></p><h3 id="五、段页式"><a href="#五、段页式" class="headerlink" title="五、段页式"></a>五、段页式</h3><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p><h3 id="六、分页与分段的比较"><a href="#六、分页与分段的比较" class="headerlink" title="六、分页与分段的比较"></a>六、分页与分段的比较</h3><ul><li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</li><li>地址空间的维度：分页是一维地址空间，分段是二维的。</li><li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li><li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li></ul><h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h3 id="一、磁盘结构"><a href="#一、磁盘结构" class="headerlink" title="一、磁盘结构"></a>一、磁盘结构</h3><ul><li>盘面（Platter）：一个磁盘有多个盘面；</li><li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li><li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</li><li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li><li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li><li>主轴（Spindle）：使整个盘面转动。</li></ul><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/014fbc4d-d873-4a12-b160-867ddaed9807.jpg" alt="img" style="zoom:67%;" /><h3 id="二、磁盘调度算法"><a href="#二、磁盘调度算法" class="headerlink" title="二、磁盘调度算法"></a>二、磁盘调度算法</h3><p>读写一个磁盘块的时间的影响因素有：</p><ul><li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li><li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li><li>实际的数据传输时间</li></ul><p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p><h4 id="1-先来先服务FCFS"><a href="#1-先来先服务FCFS" class="headerlink" title="1. 先来先服务FCFS"></a>1. 先来先服务FCFS</h4><blockquote><p>  FCFS, First Come First Served</p></blockquote><p>按照磁盘<strong>请求的顺序</strong>进行调度。</p><p>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p><h4 id="2-最短寻道时间优先SSTF"><a href="#2-最短寻道时间优先SSTF" class="headerlink" title="2. 最短寻道时间优先SSTF"></a>2. 最短寻道时间优先SSTF</h4><blockquote><p>  SSTF, Shortest Seek Time First</p></blockquote><p>优先调度与当前磁头所在磁道距离最近的磁道。</p><p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，<strong>两端的磁道请求更容易出现饥饿现象</strong>。</p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4e2485e4-34bd-4967-9f02-0c093b797aaa.png" alt="img" style="zoom:67%;" /><h4 id="3-电梯算法SCAN"><a href="#3-电梯算法SCAN" class="headerlink" title="3. 电梯算法SCAN"></a>3. 电梯算法SCAN</h4><blockquote><p>  SCAN</p></blockquote><p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p><p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p><p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/271ce08f-c124-475f-b490-be44fedc6d2e.png" alt="img" style="zoom: 67%;" /><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="一、编译系统"><a href="#一、编译系统" class="headerlink" title="一、编译系统"></a>一、编译系统</h3><p>以下是一个 <code>hello.c</code> 程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Unix 系统上，由编译器把源文件转换为目标文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br></pre></td></tr></table></figure><p>这个过程大致如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u0duo29j30uk05o0tu.jpg" alt="img"></p><ul><li>预处理阶段：处理以 # 开头的预处理命令；</li><li>编译阶段：翻译成汇编文件；</li><li>汇编阶段：将汇编文件翻译成可重定位目标文件；</li><li>链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得 <a href="..\网络\Socket.md">Socket.md</a> 到最终的可执行目标文件。</li></ul><h3 id="二、静态链接"><a href="#二、静态链接" class="headerlink" title="二、静态链接"></a>二、静态链接</h3><p>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p><ul><li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li><li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u0fay7mj30cc09b0td.jpg" alt="img"></p><h3 id="三、目标文件"><a href="#三、目标文件" class="headerlink" title="三、目标文件"></a>三、目标文件</h3><ul><li>可执行目标文件：可以直接在内存中执行；</li><li>可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；</li><li>共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；</li></ul><h3 id="四、动态链接"><a href="#四、动态链接" class="headerlink" title="四、动态链接"></a>四、动态链接</h3><p>静态库有以下两个问题：</p><ul><li>当静态库更新时那么整个程序都要重新进行链接；</li><li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li></ul><p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p><ul><li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li><li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5u0gml0uj30cp0di0tl.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;h3 id=&quot;一、基本特征&quot;&gt;&lt;a href=&quot;#一、基本特征&quot; class=&quot;headerlink&quot; title=&quot;一、基本特征&quot;&gt;&lt;/a&gt;一、基本特征&lt;/h3&gt;&lt;h4 id=&quot;1-并发&quot;&gt;&lt;a href=&quot;#1-并发&quot; class=&quot;headerlink&quot; title=&quot;1. 并发&quot;&gt;&lt;/a&gt;1. 并发&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;并发&lt;/strong&gt;是指宏观上在一段时间内能同时运行多个程序，而&lt;strong&gt;并行&lt;/strong&gt;则指同一时刻能运行多个指令。&lt;/p&gt;
&lt;p&gt;并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。&lt;/p&gt;
&lt;p&gt;操作系统通过引入进程和线程，使得程序能够并发运行。&lt;/p&gt;
&lt;h4 id=&quot;2-共享&quot;&gt;&lt;a href=&quot;#2-共享&quot; class=&quot;headerlink&quot; title=&quot;2. 共享&quot;&gt;&lt;/a&gt;2. 共享&lt;/h4&gt;&lt;p&gt;共享是指系统中的资源可以被多个并发进程共同使用。&lt;/p&gt;
&lt;p&gt;有两种共享方式：&lt;strong&gt;互斥共享&lt;/strong&gt;和&lt;strong&gt;同时共享&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Mysql</title>
    <link href="http://yoursite.com/2020/05/30/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    <id>http://yoursite.com/2020/05/30/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2020-06-08T00:55:03.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h2><h3 id="数据库的优势"><a href="#数据库的优势" class="headerlink" title="数据库的优势"></a>数据库的优势</h3><p><strong>数据保存在内存：</strong></p><p>优点：存取速度快</p><p>缺点：数据不能永久保存</p><p><strong>数据保存在文件：</strong></p><p>优点：数据永久保存</p><p>缺点：1）速度比内存操作慢，频繁的IO操作。2）查询数据不方便</p><p><strong>数据保存在数据库：</strong></p><ol><li>数据永久保存</li><li>使用SQL语句，查询方便效率高。</li><li>管理数据方便</li></ol><a id="more"></a><h3 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h3><ul><li>第一范式：每个列都不可以再拆分。</li><li>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</li><li>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</li></ul><p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由，比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p><h3 id="MySQL的权限表"><a href="#MySQL的权限表" class="headerlink" title="MySQL的权限表"></a>MySQL的权限表</h3><p>MySQL服务器通过权限表来<strong>控制用户对数据库的访问</strong>，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。</p><ol><li><p>user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</p></li><li><p>db权限表：记录各个帐号在各个数据库上的操作权限。</p></li><li><p>table_priv权限表：记录数据表级的操作权限。</p></li><li><p>columns_priv权限表：记录数据列级的操作权限。</p></li><li><p>host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</p></li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>1、<strong>整数类型</strong>，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。</p><p>长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。</p><p>例子，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。</p><p>2、<strong>实数类型</strong>，包括FLOAT、DOUBLE、DECIMAL。</p><ul><li>DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。</li><li>而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。</li></ul><p>计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</p><p>3、<strong>字符串类型</strong>，包括VARCHAR、CHAR、TEXT、BLOB</p><ul><li>VARCHAR用于存储<strong>可变长字符串</strong>，它比定长类型更节省空间。</li><li>VARCHAR使<strong>用额外1或2个字节存储字符串长度</strong>。列长度小于255字节时，使用1字节表示，否则使用2字节表示。</li><li>VARCHAR存储的内容超出设置的长度时，<strong>内容会被截断</strong>。</li><li>CHAR是定长的，根据定义的字符串长度分配足够的空间。</li><li>CHAR会根据需要使用空格进行填充，方便比较。</li><li>CHAR适合存储很短的字符串，或者所有值都接近同一个长度。</li><li>CHAR存储的内容超出设置的长度时，内容同样会被截断。</li></ul><p>使用策略：</p><ul><li>对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。</li><li>对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。</li><li>使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。</li><li>尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。</li></ul><p>4、<strong>枚举类型</strong>（ENUM），把不重复的数据存储为一个预定义的集合。</p><ul><li>有时可以使用ENUM代替常用的字符串类型。</li><li>ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。</li><li>ENUM在内部存储时，其实存的是整数。</li><li>尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。</li><li>排序是按照内部存储的整数</li></ul><p>5、<strong>日期和时间类型</strong>，尽量使用timestamp，空间效率高于datetime，</p><ul><li>用整数保存时间戳通常不方便处理。</li><li>如果需要存储微秒，可以使用bigint存储。</li></ul><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。常用的存储引擎有以下：</p><h3 id="MyISAM与InnoDB"><a href="#MyISAM与InnoDB" class="headerlink" title="MyISAM与InnoDB"></a>MyISAM与InnoDB</h3><ul><li>Innodb引擎：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</li><li>MyIASM引擎(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。</li><li>MEMORY引擎：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol><li>InnoDB索引是<strong>聚簇索引</strong>，MyISAM索引是<strong>非聚簇索引</strong>。</li><li>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</li><li>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li><li>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</li></ol><h4 id="InnoDB引擎的4大特性"><a href="#InnoDB引擎的4大特性" class="headerlink" title="InnoDB引擎的4大特性"></a>InnoDB引擎的4大特性</h4><ol><li>插入缓冲（insert buffer)</li><li>二次写(double write)</li><li>自适应哈希索引(ahi)</li><li>预读(read ahead)</li></ol><h4 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h4><p>如果没有特别的需求，使用默认的Innodb即可。</p><ul><li>MyISAM：以<strong>读写插入为主</strong>的应用程序，比如博客系统、新闻门户网站。</li><li>Innodb：<strong>更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键</strong>。比如OA自动化办公系统。</li></ul><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。</p><p>视图具有如下好处：</p><ul><li>简化复杂的 SQL 操作，比如复杂的连接；</li><li>只使用实际表的一部分数据；</li><li>通过只给用户访问视图的权限，保证数据的安全性；</li><li>更改数据格式和表示。</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</p><p>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p><p>更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</p><p>索引的原理很简单，就是把无序的数据变成有序的查询</p><ol><li>把创建了索引的列的内容进行排序</li><li>对排序结果生成<strong>倒排表</strong></li><li>在倒排表内容上拼上数据地址链</li><li>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</li></ol><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>索引的优点：</strong></p><p>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p><p>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p><p><strong>索引的缺点：</strong></p><p>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</p><p>空间方面：索引需要占物理空间。</p><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。</p><p>因此我们需要<strong>尽可能的在select后只写必要的查询字段，以增加索引覆盖的几率</strong>。</p><blockquote><p>  这里值得注意的是不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。</p></blockquote><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><ul><li><p><strong>主键索引</strong>: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p></li><li><p><strong>唯一索引</strong>: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</p><blockquote><p>  可以通过 ALTER TABLE table_name ADD UNIQUE (column)；创建唯一索引</p><p>  可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2)；创建唯一组合索引</p></blockquote></li><li><p><strong>普通索引</strong>: 基本的索引类型，没有唯一性的限制，允许为NULL值。</p><blockquote><p>  可以通过ALTER TABLE table_name ADD INDEX index_name (column); 创建普通索引</p><p>  可以通过ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3)；创建组合索引</p></blockquote></li><li><p><strong>全文索引</strong>：是目前搜索引擎使用的一种关键技术。</p><blockquote><p>  可以通过ALTER TABLE table_name ADD FULLTEXT (column); 创建全文索引</p></blockquote></li></ul><h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><p>索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有Hash索引，B+树索引等，而我们经常使用的InnoDB存储引擎的默认索引实现为：<strong>B+树索引</strong>。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p><p>mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。</p><h4 id="B树索引"><a href="#B树索引" class="headerlink" title="B树索引"></a>B树索引</h4><p>B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）</p><p><strong>BTree算法</strong></p><p>BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量。</p><p><strong>查询方式：</strong></p><p>主键索引区：PI(关联保存的时数据的地址)按主键查询,</p><p>普通索引区：si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度最快</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6pgg6jb9j30ma0b9755.jpg" alt="B+树" style="zoom:67%;" /><p><strong>B+树性质：</strong></p><ul><li>n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</li><li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li><li>所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</li><li>B+ 树中，数据对象的插入和删除仅在叶节点上进行。</li><li>B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</li></ul><p><strong>B树和B+树的区别</strong></p><ol><li><p>在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</p></li><li><p>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。</p></li></ol><p><strong>使用B树的好处</strong></p><p>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在<strong>特定数据重复多次查询</strong>的场景中更加高效。</p><p><strong>使用B+树的好处</strong></p><p>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于<strong>更快地缩小查找范围</strong>。B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用<code>O(logN)</code>时间找到最小的一个节点，然后通过链进行<code>O(N)</code>的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间。</p><p><strong>数据库为什么使用B+树而不是B树</strong></p><ol><li>B树只适合随机检索，而B+树同时支持随机检索和顺序检索；</li><li>B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；</li><li>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</li><li>B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。</li><li>增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</li></ol><h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>哈希索引类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。</p><p><strong>Hash算法</strong></p><p>Hash Hash索引只能用于<strong>对等比较</strong>，例如=,&lt;=&gt;（相当于!=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以<strong>检索效率远高于BTree索引</strong>。</p><p><strong>Hash索引和B+树所有有什么区别或者说优劣呢?</strong></p><p>首先要知道Hash索引和B+树索引的底层实现原理：</p><p>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</p><p>那么可以看出他们有以下的不同：</p><p><strong>hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。</strong></p><p>因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</p><ol><li>hash索引不支持使用索引进行排序，原理同上。</li><li>hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。</li><li>hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。</li><li>hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</li></ol><p>因此，<strong>在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度，而不需要使用hash索引</strong>。</p><h3 id="索引设计的原则"><a href="#索引设计的原则" class="headerlink" title="索引设计的原则"></a>索引设计的原则</h3><ul><li>适合索引的列是出现在where子句中的列，或者连接子句中指定的列</li><li>基数较小的类，索引效果较差，没有必要在此列建立索引</li><li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</li><li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</li></ul><h3 id="创建索引的原则"><a href="#创建索引的原则" class="headerlink" title="创建索引的原则"></a>创建索引的原则</h3><p>索引虽好，但也不是无限制的使用，最好符合一下几个原则</p><ol><li><p>最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>， 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p></li><li><p>较频繁作为查询条件的字段才去创建索引</p></li><li><p>更新频繁字段不适合创建索引</p></li><li><p>若是不能有效区分数据的列不适合做索引列（如性别，男女未知，最多也就三种，区分度实在太低）</p></li><li><p>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a，b)的索引，那么只需要修改原来的索引即可。</p></li><li><p>定义有外键的数据列一定要建立索引。</p></li><li><p>对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</p></li><li><p>对于定义为text、image和bit的数据类型的列不要建立索引。</p></li></ol><h3 id="创建索引的三种方式"><a href="#创建索引的三种方式" class="headerlink" title="创建索引的三种方式"></a>创建索引的三种方式</h3><ol><li>第一种方式：在执行<code>CREATE TABLE</code>时创建索引</li><li>第二种方式：使用<code>ALTER TABLE</code>命令去增加索引</li><li>第三种方式：使用<code>CREATE INDEX</code>命令创建</li></ol><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>根据索引名删除普通索引、唯一索引、全文索引：<code>DROP INDEX 索引的名字 ON 索引的表</code></p><p>删除主键索引：<code>alter table 表名 drop primary key</code>（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）</p><h3 id="创建索引注意事项"><a href="#创建索引注意事项" class="headerlink" title="创建索引注意事项"></a>创建索引注意事项</h3><ul><li>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应该用0、一个特殊的值或者一个空串代替空值；</li><li>取值离散大的字段：变量各个取值之间的差异程度大的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</li><li>索引字段越小越好：数据库的数据存储以页为单位，一页存储的数据越多一次IO操作获取的数据越大，效率越高。</li></ul><h3 id="使用索引查询一定能提高查询的性能吗？"><a href="#使用索引查询一定能提高查询的性能吗？" class="headerlink" title="使用索引查询一定能提高查询的性能吗？"></a>使用索引查询一定能提高查询的性能吗？</h3><p>通常通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</p><p>索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况：</p><ol><li>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</li><li>基于非唯一性索引的检索</li></ol><h3 id="百万级别或以上的数据如何删除？"><a href="#百万级别或以上的数据如何删除？" class="headerlink" title="百万级别或以上的数据如何删除？"></a><strong>百万级别或以上的数据如何删除？</strong></h3><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知<strong>删除数据的速度和创建的索引数量是成正比的</strong>。</p><ol><li><p>所以我们想要删除百万数据的时候可以<strong>先删除索引</strong>（此时大概耗时三分多钟）</p></li><li><p>然后<strong>删除其中无用数据</strong>（此过程需要不到两分钟）</p></li><li><p>删除完成后<strong>重新创建索引</strong>(此时数据较少了)创建索引也非常快，约十分钟左右。</p></li></ol><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>语法：index(field(10))，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。</p><p>前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。</p><p>实操的难度：在于前缀截取的长度。</p><p>我们可以利用select count(*)/count(distinct left(password,prefixLen));，通过从调整prefixLen的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前prefixLen个字符几乎能确定唯一一条记录）</p><h4 id="最左前缀、最左匹配"><a href="#最左前缀、最左匹配" class="headerlink" title="最左前缀、最左匹配"></a>最左前缀、最左匹配</h4><p>最左前缀匹配原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配。</p><p>比如<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code> 如果建立(a,b,c,d)顺序的索引，d是用不到索引的(c已经是范围查询了，d肯定是排不了序了)，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p><p>=和in可以乱序，比如<code>a = 1 and b = 2 and c = 3</code> 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p><h3 id="聚簇索引、非聚簇索引"><a href="#聚簇索引、非聚簇索引" class="headerlink" title="聚簇索引、非聚簇索引"></a>聚簇索引、非聚簇索引</h3><ul><li><p>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</p></li><li><p>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行。MyISAM通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</p></li></ul><p>澄清一个概念：InnoDB中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值。</p><p><strong>非聚簇索引一定会回表查询吗？</strong></p><p>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</p><p>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行<code>select age from employee where age &lt; 20</code>的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p><p>具体原因为:</p><p>MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</p><p>当进行查询，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="什么是数据库事务？"><a href="#什么是数据库事务？" class="headerlink" title="什么是数据库事务？"></a>什么是数据库事务？</h3><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><p>事务最经典也经常被拿出来说例子就是转账了。</p><p>假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p><h3 id="事物的四大特性-ACID"><a href="#事物的四大特性-ACID" class="headerlink" title="事物的四大特性(ACID)"></a>事物的四大特性(ACID)</h3><p>关系性数据库需要遵循ACID规则，具体内容如下：</p><ul><li><p>原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p></li><li><p>一致性：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</p></li><li><p>隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</p></li><li><p>持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p></li></ul><h3 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h3><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p><h4 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h4><p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p><h4 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h4><p>T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><h4 id="幻影读"><a href="#幻影读" class="headerlink" title="幻影读"></a>幻影读</h4><p>T1 读取某个<strong>范围</strong>的数据，T2 在这个<strong>范围内</strong>插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><h4 id="未提交读"><a href="#未提交读" class="headerlink" title="未提交读"></a>未提交读</h4><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p><h4 id="提交读"><a href="#提交读" class="headerlink" title="提交读"></a>提交读</h4><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p><h4 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h4><p>保证在同一个事务中多次读取同一数据的结果是一样的。</p><h4 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h4><p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p><p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻影读</th></tr></thead><tbody><tr><td>未提交读</td><td>√</td><td>√</td><td>√</td></tr><tr><td>提交读</td><td>×</td><td>√</td><td>√</td></tr><tr><td>可重复读</td><td>×</td><td>×</td><td>√</td></tr><tr><td>可串行化</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容)，但是你要知道的是InnoDB 存储引擎默认使用REPEATABLE-READ（可重读），并不会有任何性能损失。</p><p>InnoDB 存储引擎在分布式事务的情况下一般会用到SERIALIZABLE(可串行化)隔离级别。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。</p><p>就像酒的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。</p><h3 id="MySQL都有哪些锁？"><a href="#MySQL都有哪些锁？" class="headerlink" title="MySQL都有哪些锁？"></a>MySQL都有哪些锁？</h3><p>从锁的类别上来讲，有共享锁和排他锁。</p><p>共享锁: 又叫做读锁。当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</p><p>排他锁: 又叫做写锁。当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</p><p>用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。</p><p>锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。</p><p>他们的加锁开销从大到小，并发能力也是从大到小。</p><h3 id="隔离级别与锁的关系"><a href="#隔离级别与锁的关系" class="headerlink" title="隔离级别与锁的关系"></a>隔离级别与锁的关系</h3><ul><li>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</li><li>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</li><li>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</li><li>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</li></ul><p><strong>按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法</strong></p><p>在关系型数据库中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p><p>MyISAM和InnoDB存储引擎使用的锁：</p><p>1、MyISAM采用表级锁(table-level locking)。</p><p>2、InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁</p><h3 id="行级锁、表级锁和页级锁"><a href="#行级锁、表级锁和页级锁" class="headerlink" title="行级锁、表级锁和页级锁"></a>行级锁、表级锁和页级锁</h3><p><strong>行级锁</strong> ：行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</p><p>特点：开销大，加锁慢；<strong>会出现死锁</strong>；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p><p><strong>表级锁</strong> ：表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p><p>特点：开销小，加锁快；<strong>不会出现死锁</strong>；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p><p><strong>页级锁</strong> ：页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</p><p>特点：开销和加锁时间界于表锁和行锁之间；<strong>会出现死锁</strong>；锁定粒度界于表锁和行锁之间，并发度一般。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p><p><strong>常见的解决死锁的方法</strong></p><ol><li>如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</li><li>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</li><li>对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</li><li>用分布式事务锁或者使用乐观锁</li></ol><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p><p><strong>悲观锁：</strong>假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。</p><p>实现方式：使用数据库中的锁机制</p><p><strong>乐观锁：</strong>假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。</p><p>实现方式：乐观锁一般会使用版本号机制或CAS算法实现。</p><p><strong>两种锁的使用场景</strong></p><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种.</p><ul><li>乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</li><li>如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</li></ul><h2 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h2><h3 id="为什么要优化"><a href="#为什么要优化" class="headerlink" title="为什么要优化"></a>为什么要优化</h3><ul><li>系统的吞吐量瓶颈往往出现在数据库的访问速度上</li><li>随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢</li><li>数据是存放在磁盘上的，读写速度无法和内存相比</li></ul><p>优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。</p><h3 id="优化SQL语句"><a href="#优化SQL语句" class="headerlink" title="优化SQL语句"></a>优化SQL语句</h3><p>1：对查询进行优化，应尽量避免全表扫描，首先应考虑在where及order by 涉及的列上创建索引。因为：索引对查询的速度有着至关重要的影响。</p><p>2：尽量避免在where字句中对字段进行<code>null</code>值的判断。否则将会导致引擎放弃使用索引而进行全表扫描。</p><p>3：应尽量避免在where子句中使用!=或者是&lt;&gt;操作符号。否则引擎将放弃使用索引，进而进行全表扫描。</p><p>4：应尽量避免在where子句中使用or来连接条件，否则导致放弃使用索引而进行全表扫描。可以使用 union 或者是 union all代替。</p><p>5：in 和 not in 也要慎用，否则将会导致全表扫描。in 对于连续的数组，可以使用between ..…and.来代替。</p><p>6：where子句参数使用时候需注意</p><p>如果在where子句中使用参数，也会导致全表扫描。因为sql只会在运行时才会解析局部变量。<strong>但优化程序不能将访问计划的选择推迟到运行时；必须在编译时候进行选择</strong>。然而，如果在编译时建立访问计划，变量的值还是未知大，因而无法作为索引选择输入项。</p><p>7：尽量避免在where子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。</p><p>8：尽量避免爱where子句中对字段进行函数操作，这将导致引擎放弃索引，而进行全表扫描。</p><p>9：很多时候用exists 代替 in是一个很好的选择。</p><p>10：并不是所有索引对查询都有效</p><p>sql是根据表中数据进行查询优化的，当索引(索引字段)有大量重复数据的时候，sql查询可能不会去利用索引。如字段 sex中male、female 几乎各一半。那么即使在sex上创建了索引对查询效率也起不了多大作用。</p><p>11：索引创建需注意</p><p>并非索引创建越多越好。索引固然可以提高相应的查询效率，但是同样会降低insert以及update的效率。因为在insert或是update的时候有可能会重建索引或是修改索引。所以索引怎样创建需要慎重考虑，视情况而定。一个表中索引数量最好不要超过6个。若太多，则需要考虑对一些不常用的列创建索引是否有必要。</p><h3 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h3><p>一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</p><p>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p><p><strong>将字段很多的表分解成多个表</strong></p><p>对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</p><p>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</p><p><strong>增加中间表</strong></p><p>对于需要经常联合查询的表，可以建立中间表以提高查询效率。</p><p>通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</p><p><strong>增加冗余字段</strong></p><p>设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。</p><p>表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</p><p><strong>注意</strong>：冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。</p><h3 id="数据库单表优化"><a href="#数据库单表优化" class="headerlink" title="数据库单表优化"></a>数据库单表优化</h3><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p><ul><li>限定数据的范围：务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</li><li>读/写分离：经典的数据库拆分方案，主库负责写，从库负责读；</li><li>缓存：使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；</li><li>通过分库分表的方式进行优化，主要有垂直分表和水平分表</li></ul><p><strong>垂直分区：</strong></p><p>根据数据库里面数据表的相关性进行拆分。例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p><p>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</p><p>垂直拆分的优点：可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</p><p>垂直拆分的缺点：主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</p><p><strong>水平分区：</strong></p><p>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。水平拆分可以支撑非常大的数据量。</p><p>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p><p>水平拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以<strong>水平拆分最好分库</strong> 。</p><p><strong>水平切分的缺点</strong></p><ol><li>给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作</li><li>在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数</li></ol><p>《Java工程师修炼之道》的作者推荐 <strong>尽量不要对数据进行分片</strong>，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</p><p><strong>数据库分片的两种常见方案：</strong></p><ul><li>客户端代理：分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。</li><li>中间件代理：在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。</li></ul><h3 id="分页查询的性能优化"><a href="#分页查询的性能优化" class="headerlink" title="分页查询的性能优化"></a>分页查询的性能优化</h3><p>Mysql的分页查询十分简单，但是当数据量大的时候一般的分页就吃不消了。</p><p>传统分页查询：<code>select * from table limit M,N</code></p><p>表示查询表M条数据开始（不包括第M条数据），然后一共查询N条</p><p>MySQL的limit工作原理就是先读取前面n条记录，然后抛弃前n条，读后面m条想要的，百千条数据的时候，这种查找的方法是全表扫描，找到页码，所以N越大，偏移量越大，性能就越差。</p><p>推荐分页查询方法：</p><ol><li><p><strong>使用 id 限定优化</strong></p><p>这种方式假设数据表的id是连续递增的，根据查询的页数和查询的记录数可以算出查询的id的范围</p><p><code>select * from student where id&gt;=8000000 ORDER BY id desc limit 0,20</code></p><p>适用于数据量多的情况(元组数上万)。最好ORDER BY后的列对象是主键或唯一索引，使得ORDER BY操作能利用索引被消除索引扫描，速度会很快。MySQL的排序操作，asc升序，desc降序。</p><p>这种查询方式能够极大地优化查询速度，基本能够在几十毫秒之内完成。限制是只能使用于明确知道id的情况，不过一般建立表的时候，都会添加基本的id字段，这为分页查询带来很多便利。</p></li><li><p><strong>利用子查询</strong></p><p>这种方式先定位偏移位置的 id，然后往后查询，这种方式适用于 id 递增的情况。</p><p><code>select id from student limit 800000, 20</code></p><p>id是主键且是唯一索引，这样只需要查找索引结构，查询速度会非常快，但是这样查询只有id信息，那么如果要得到全列信息，可以使用子查询或者join连接</p><p><code>select * from student where id&gt;=(select id from student limit 800000,1) limit 20</code></p><p><code>select * from student a join(select id from student limit 800000, 20) b ON a.id= b.id</code></p></li></ol><h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><blockquote><p>  参考文档：<a href="https://www.jianshu.com/p/735a3d4789fc" target="_blank" rel="noopener">一致性哈希问题</a></p></blockquote><p>在 Mysql数据库要存储的量达到一个很高的地步的时候，我们会对数据库进行分库分表操作。将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据不同。 这样做能够有效的缓解单机数据库的压力和系统的性能瓶颈。</p><p><strong>一致性哈希算法</strong></p><p>一致性哈希算法，其实就是解决了这里面的存取规则的问题，有了这个一致性哈希算法，我们能够准确的知道我们要取的数据落在哪个机器的哪个数据库中。</p><h2 id="MySQL的复制与分离"><a href="#MySQL的复制与分离" class="headerlink" title="MySQL的复制与分离"></a>MySQL的复制与分离</h2><p>主从复制：将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</p><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><ul><li>主数据库出现问题，可以切换到从数据库。</li><li>可以进行数据库层面的读写分离。</li><li>可以在从数据库上进行日常备份。</li></ul><p><strong>MySQL主从复制解决的问题</strong></p><ul><li>数据分布：随意开始或停止复制，并在不同地理位置分布数据备份</li><li>负载均衡：降低单个服务器的压力</li><li>高可用和故障切换：帮助应用程序避免单点失败</li><li>升级测试：可以用更高版本的MySQL作为从库</li></ul><h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。</p><p>读写分离就是只在mysql主服务器上写，只在mysql从服务器上读。基本原理是让主数据库处理事务性查询，而从数据库处理select查询。数据库复制被用来把事务性查询导致的变更同步到集群中的数据库。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据库基础&quot;&gt;&lt;a href=&quot;#数据库基础&quot; class=&quot;headerlink&quot; title=&quot;数据库基础&quot;&gt;&lt;/a&gt;数据库基础&lt;/h2&gt;&lt;h3 id=&quot;数据库的优势&quot;&gt;&lt;a href=&quot;#数据库的优势&quot; class=&quot;headerlink&quot; title=&quot;数据库的优势&quot;&gt;&lt;/a&gt;数据库的优势&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;数据保存在内存：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优点：存取速度快&lt;/p&gt;
&lt;p&gt;缺点：数据不能永久保存&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据保存在文件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优点：数据永久保存&lt;/p&gt;
&lt;p&gt;缺点：1）速度比内存操作慢，频繁的IO操作。2）查询数据不方便&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据保存在数据库：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据永久保存&lt;/li&gt;
&lt;li&gt;使用SQL语句，查询方便效率高。&lt;/li&gt;
&lt;li&gt;管理数据方便&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis与缓存</title>
    <link href="http://yoursite.com/2020/05/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E4%B8%8E%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2020/05/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E4%B8%8E%E7%BC%93%E5%AD%98/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2020-06-08T00:55:11.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><h3 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h3><p>Redis(Remote Dictionary Server) 是一个使用 C 语言编写的，开源的（BSD许可）高性能非关系型（NoSQL）的键值对数据库。</p><p>Redis 可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。</p><p>与传统数据库不同的是， Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p><a id="more"></a><h3 id="Redis的优缺点"><a href="#Redis的优缺点" class="headerlink" title="Redis的优缺点"></a>Redis的优缺点</h3><p><strong>优点</strong></p><ul><li>读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。</li><li>支持数据持久化，支持AOF和RDB两种持久化方式。</li><li>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</li><li>数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。</li><li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li></ul><p><strong>缺点</strong></p><ul><li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li><li>Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。</li><li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</li><li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li></ul><h3 id="为什么要用缓存"><a href="#为什么要用缓存" class="headerlink" title="为什么要用缓存"></a>为什么要用缓存</h3><p>主要从“高性能”和“高并发”这两点来看待这个问题。</p><p><strong>高性能：</strong></p><p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p><p><strong>高并发：</strong></p><p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p><h3 id="为什么不用-map做缓存"><a href="#为什么不用-map做缓存" class="headerlink" title="为什么不用 map做缓存"></a>为什么不用 map做缓存</h3><p>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p><p>使用 redis之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 服务的高可用，整个程序架构上较为复杂。</p><h3 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h3><ul><li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；</li><li>数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；</li><li>采用<strong>单线程</strong>，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，<strong>不存在加锁释放锁操作</strong>，没有因为可能出现死锁而导致的性能消耗；</li><li>使用多路 I/O 复用模型，非阻塞 IO；</li><li>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Redis相比其他缓存，有一个非常大的优势，就是支持多种数据类型。</p><p>Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，满足大部分的使用要求</p><ul><li><strong>string</strong>——适合最简单的k-v存储，类似于memcached的存储结构，短信验证码，配置信息等，就用这种类型来存储。</li><li><strong>hash</strong>——一般key为ID或者唯一标示，value对应的就是详情了。如商品详情，个人信息详情，新闻详情等。</li><li><strong>list</strong>——因为list是有序的，比较适合存储一些有序且数据相对固定的数据。如省市区表、字典表等。因为list是有序的，适合根据写入的时间来排序，如：最新的热点新闻，消息队列等。</li><li><strong>set</strong>——可以简单的理解为ID-List的模式，如微博中一个人有哪些好友，set最牛的地方在于，可以对两个set提供交集、并集、差集操作。例如：查找两个人共同的好友等。</li><li><strong>Sorted Set</strong>——是set的增强版本，增加了一个score参数，自动会根据score的值进行排序。比较适合类似于top 10等不根据插入的时间来排序的数据。</li></ul><table><thead><tr><th align="center"><strong>类型</strong></th><th align="center"><strong>存储值</strong></th><th align="center"><strong>操作</strong></th><th align="center"><strong>应用场景</strong></th></tr></thead><tbody><tr><td align="center">STRING</td><td align="center">字符串、整数或者浮点数</td><td align="center">对整个字符串或者字符串的其中一部分执行操作； 对整数和浮点数执行自增或者自减操作</td><td align="center">做简单的键值对缓存</td></tr><tr><td align="center">LIST</td><td align="center">列表</td><td align="center">从两端压入或者弹出元素； 对单个或者多个元素进行修剪，只保留一个范围内的元素</td><td align="center">存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的数据</td></tr><tr><td align="center">SET</td><td align="center">无序集合</td><td align="center">添加、获取、移除单个元素； 检查一个元素是否存在于集合中； 计算交集、并集、差集； 从集合里面随机获取元素</td><td align="center">交集、并集、差集的操作，比如交集，可以把两个人的粉丝列表整一个交集</td></tr><tr><td align="center">HASH</td><td align="center">哈希</td><td align="center">添加、获取、移除单个键值对； 获取所有键值对； 检查某个键是否存在</td><td align="center">结构化的数据，比如一个对象</td></tr><tr><td align="center">ZSET</td><td align="center">有序集合</td><td align="center">添加、获取、删除元素； 根据分值范围或者成员来获取元素； 计算一个键的排名</td><td align="center">去重但可以排序，如获取排名前几名的用户</td></tr></tbody></table><p>如上所述，虽然Redis不像关系数据库那么复杂的数据结构，但是，也能适合很多场景，比一般的缓存数据结构要多。了解每种数据结构适合的业务场景，不仅有利于提升开发效率，也能有效利用Redis的性能。</p><h2 id="Redis的应用场景"><a href="#Redis的应用场景" class="headerlink" title="Redis的应用场景"></a>Redis的应用场景</h2><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p><h3 id="会话缓存"><a href="#会话缓存" class="headerlink" title="会话缓存"></a>会话缓存</h3><p>可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p><h3 id="全页缓存（FPC）"><a href="#全页缓存（FPC）" class="headerlink" title="全页缓存（FPC）"></a>全页缓存（FPC）</h3><p>除基本的会话token之外，Redis还提供很简便的FPC平台。以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p><h3 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h3><p>例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p><h3 id="消息队列-发布-订阅功能"><a href="#消息队列-发布-订阅功能" class="headerlink" title="消息队列(发布/订阅功能)"></a>消息队列(发布/订阅功能)</h3><p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。</p><h3 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h3><p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。</p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p><h3 id="持久化机制和优缺点"><a href="#持久化机制和优缺点" class="headerlink" title="持久化机制和优缺点"></a>持久化机制和优缺点</h3><p>Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制；</p><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。</p><p><strong>优点：</strong></p><ol><li>只有一个文件 dump.rdb，方便持久化。</li><li>容灾性好，一个文件可以保存到安全的磁盘。</li><li>性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能。</li><li>相对于数据集大时，比 AOF 的启动效率更高。</li></ol><p><strong>缺点：</strong></p><p>数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)</p><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。</p><p>当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。</p><p><strong>优点：</strong></p><ol><li>数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。</li><li>通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li><li>AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）</li></ol><p><strong>缺点：</strong></p><ol><li>AOF 文件比 RDB 文件大，且恢复速度慢。</li><li>数据集大的时候，比 rdb 启动效率低。</li></ol><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul><li>AOF文件比RDB更新频率高，优先使用AOF还原数据</li><li>AOF比RDB更安全也更大</li><li>RDB性能比AOF好</li><li>如果两个都配了优先加载AOF</li></ul><h3 id="如何选择合适的持久化方式"><a href="#如何选择合适的持久化方式" class="headerlink" title="如何选择合适的持久化方式"></a>如何选择合适的持久化方式</h3><p>一般来说， 如果想达到足以媲美PostgreSQL的数据安全性，你应该同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</p><p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。</p><p>有很多用户都只使用AOF持久化，但并不推荐这种方式，因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免AOF程序的bug。</p><p>如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>如果Redis被当做缓存使用，使用<strong>一致性哈希</strong>实现动态扩容缩容。</p><p>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</p><h3 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h3><p>Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。</p><p>过期策略通常有以下三种：</p><ol><li><strong>定时过期</strong>：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</li><li><strong>惰性过期</strong>：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li><li><strong>定期过期</strong>：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</li></ol><p>(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)</p><p>Redis中同时使用了惰性过期和定期过期两种过期策略。</p><p><strong>Redis key的过期时间和永久有效分别怎么设置？</strong></p><p>EXPIRE和PERSIST命令。</p><p><strong>我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?</strong></p><p>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p><ol><li>定时去清理过期的缓存；</li><li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li></ol><p>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p><h2 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h2><p><strong>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？</strong></p><p>redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p><h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p><p>1、全局的键空间选择性移除</p><ul><li><strong>noeviction</strong>：当内存不足以容纳新写入数据时，新写入操作会报错。</li><li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的）</li><li><strong>allkeys-random</strong>：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li></ul><p>2、设置过期时间的键空间选择性移除</p><ul><li><strong>volatile-lru</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li><li><strong>volatile-random</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li><li><strong>volatile-ttl</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li></ul><p><strong>总结</strong></p><p>Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。</p><h3 id="内存用完了会发生什么"><a href="#内存用完了会发生什么" class="headerlink" title="内存用完了会发生什么"></a>内存用完了会发生什么</h3><p>如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）</p><p>或者可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</p><h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p>可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。</p><p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面。</p><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫<strong>单线程模型</strong>。</p><p>文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</p><p>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p><p>虽然文件事件处理器以单线程方式运行， 但通过使用 I/O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p><h3 id="Redis事务的概念"><a href="#Redis事务的概念" class="headerlink" title="Redis事务的概念"></a>Redis事务的概念</h3><p>Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p><p>总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p><h3 id="Redis事务的三个阶段"><a href="#Redis事务的三个阶段" class="headerlink" title="Redis事务的三个阶段"></a>Redis事务的三个阶段</h3><ul><li>事务开始 MULTI</li><li>命令入队</li><li>事务执行 EXEC</li></ul><p>事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队</p><h3 id="Redis事务相关命令"><a href="#Redis事务相关命令" class="headerlink" title="Redis事务相关命令"></a>Redis事务相关命令</h3><p>Redis会将一个事务中的所有命令序列化，然后按顺序执行。</p><ul><li><strong>redis 不支持回滚</strong>，“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。</li><li>如果在一个事务中的命令出现错误，那么所有的命令都不会执行；</li><li>如果在一个事务中出现运行错误，那么正确的命令会被执行。</li></ul><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的</p><ul><li><p>WATCH：WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</p></li><li><p>MULTI：MULTI命令用于开启一个事务，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</p></li><li><p>EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil 。</p></li><li><p>DISCARD：通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。</p></li><li><p>UNWATCH：UNWATCH命令可以取消watch对所有key的监控。</p></li></ul><h3 id="事务管理（ACID）概述"><a href="#事务管理（ACID）概述" class="headerlink" title="事务管理（ACID）概述"></a>事务管理（ACID）概述</h3><h4 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h4><p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p><h4 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h4><p>事务前后数据的完整性必须保持一致。</p><h4 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h4><p>多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</p><h4 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h4><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</p><p>Redis的事务总是具有ACID中的一致性和隔离性，其他特性是不支持的。当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。</p><h3 id="Redis事务支持隔离性吗"><a href="#Redis事务支持隔离性吗" class="headerlink" title="Redis事务支持隔离性吗"></a>Redis事务支持隔离性吗</h3><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<strong>Redis 的事务是总是带有隔离性的</strong>。</p><h3 id="Redis事务保证原子性吗，支持回滚吗"><a href="#Redis事务保证原子性吗，支持回滚吗" class="headerlink" title="Redis事务保证原子性吗，支持回滚吗"></a>Redis事务保证原子性吗，支持回滚吗</h3><p>Redis中，单条命令是原子性执行的，但<strong>事务不保证原子性，且没有回滚</strong>。事务中任意命令执行失败，其余的命令仍会被执行。</p><h3 id="Redis事务其他实现"><a href="#Redis事务其他实现" class="headerlink" title="Redis事务其他实现"></a>Redis事务其他实现</h3><ul><li>基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运。</li><li>基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐。</li></ul><h2 id="集群方案"><a href="#集群方案" class="headerlink" title="集群方案"></a>集群方案</h2><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><h4 id="哨兵的功能"><a href="#哨兵的功能" class="headerlink" title="哨兵的功能"></a>哨兵的功能</h4><p>sentinel，中文名是哨兵。哨兵是 redis 集群机构中非常重要的一个组件，主要有以下功能：</p><ul><li><strong>集群监控</strong>：负责监控 redis master 和 slave 进程是否正常工作。</li><li><strong>消息通知</strong>：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li><li><strong>故障转移</strong>：如果 master node 挂掉了，会自动转移到 slave node 上。</li><li><strong>配置中心</strong>：如果故障转移发生了，通知 client 客户端新的 master 地址。</li></ul><p><strong>哨兵用于实现 redis 集群的高可用</strong>，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p><ol><li>故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。</li><li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。</li></ol><h4 id="哨兵的核心知识"><a href="#哨兵的核心知识" class="headerlink" title="哨兵的核心知识"></a>哨兵的核心知识</h4><ol><li>哨兵至少需要 3 个实例，来保证自己的健壮性。</li><li>哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。</li><li>对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li></ol><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><h3 id="Redis是单线程的，如何提高多核CPU的利用率"><a href="#Redis是单线程的，如何提高多核CPU的利用率" class="headerlink" title="Redis是单线程的，如何提高多核CPU的利用率"></a>Redis是单线程的，如何提高多核CPU的利用率</h3><p>可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个CPU，你可以考虑一下分片（shard）。</p><h3 id="为什么要做Redis分区"><a href="#为什么要做Redis分区" class="headerlink" title="为什么要做Redis分区"></a>为什么要做Redis分区</h3><p>分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升，Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。</p><h3 id="Redis分区实现方案"><a href="#Redis分区实现方案" class="headerlink" title="Redis分区实现方案"></a>Redis分区实现方案</h3><ol><li><strong>客户端分区</strong>就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。大多数客户端已经实现了客户端分区。</li><li><strong>代理分区</strong>意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是Twemproxy。</li><li><strong>查询路由</strong>(Query routing) 的意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点。</li></ol><h3 id="Redis分区有什么缺点"><a href="#Redis分区有什么缺点" class="headerlink" title="Redis分区有什么缺点"></a>Redis分区有什么缺点</h3><ol><li>涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例（实际上这种情况也有办法，但是不能直接使用交集指令）。</li><li>同时操作多个key，则不能使用Redis事务。</li><li>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集</li><li>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB / AOF文件。</li><li>分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。</li></ol><h2 id="分布式问题"><a href="#分布式问题" class="headerlink" title="分布式问题"></a>分布式问题</h2><h3 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h3><p>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。</p><p>当且仅当 key 不存在，将 key 的值设为 value。若给定的 key 已经存在，则 SETNX 不做任何动作</p><p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p><p>返回值：设置成功，返回 1 。设置失败，返回 0 。</p><p>使用SETNX完成同步锁的流程及事项如下：</p><p>使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功</p><p>为了防止获取锁后E程序出现异常，导致其他线程/进程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个“合理”的过期时间</p><p>释放锁，使用DEL命令将锁数据删除</p><h3 id="如何解决-Redis-的并发竞争-Key-问题"><a href="#如何解决-Redis-的并发竞争-Key-问题" class="headerlink" title="如何解决 Redis 的并发竞争 Key 问题"></a>如何解决 Redis 的并发竞争 Key 问题</h3><p>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p><p>推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</p><p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p><p>在实践中，当然是从以可靠性为主。所以首推Zookeeper。</p><h3 id="分布式Redis是前期做还是后期规模上来了再做好？为什么？"><a href="#分布式Redis是前期做还是后期规模上来了再做好？为什么？" class="headerlink" title="分布式Redis是前期做还是后期规模上来了再做好？为什么？"></a>分布式Redis是前期做还是后期规模上来了再做好？为什么？</h3><p>既然Redis是如此的轻量（单实例只使用1M内存），为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。d</p><p>一开始就多设置几个Redis实例，例如32或者64个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</p><p>这样的话，当你的数据不断增长，需要更多的Redis服务器时，你需要做的就是仅仅将Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。</p><h3 id="什么是-RedLock"><a href="#什么是-RedLock" class="headerlink" title="什么是 RedLock"></a>什么是 RedLock</h3><p>Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫 Redlock，此种方式比原先的单节点的方法更安全。它可以保证以下特性：</p><ol><li>安全特性：互斥访问，即永远只有一个 client 能拿到锁</li><li>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区</li><li>容错性：只要大部分 Redis 节点存活就可以正常提供服务</li></ol><h2 id="缓存特征"><a href="#缓存特征" class="headerlink" title="缓存特征"></a>缓存特征</h2><h3 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h3><p>当某个请求能够通过访问缓存而得到响应时，称为缓存命中。</p><p>缓存命中率越高，缓存的利用率也就越高。</p><h3 id="最大空间"><a href="#最大空间" class="headerlink" title="最大空间"></a>最大空间</h3><p>缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。</p><p>当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。</p><h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><ul><li>FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。</li><li>LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。</li><li>LFU（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。</li></ul><h2 id="缓存使用举例"><a href="#缓存使用举例" class="headerlink" title="缓存使用举例"></a>缓存使用举例</h2><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。</p><h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><p>网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。</p><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><p>使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。</p><h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><p>使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。</p><p>相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。</p><h3 id="数据库缓存"><a href="#数据库缓存" class="headerlink" title="数据库缓存"></a>数据库缓存</h3><p>MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。</p><h3 id="Java-内部的缓存"><a href="#Java-内部的缓存" class="headerlink" title="Java 内部的缓存"></a>Java 内部的缓存</h3><p>Java 为了优化空间，提高字符串、基本数据类型包装类的创建效率，设计了字符串常量池及 Byte、Short、Character、Integer、Long、Boolean 这六种包装类缓冲池。</p><h3 id="CPU-多级缓存"><a href="#CPU-多级缓存" class="headerlink" title="CPU 多级缓存"></a>CPU 多级缓存</h3><p>CPU 为了解决运算速度与主存 IO 速度不匹配的问题，引入了多级缓存结构，同时使用 MESI 等缓存一致性协议来解决多核 CPU 缓存数据一致性的问题。</p><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>内容分发网络（Content distribution network，CDN）是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等静态资源分发给用户。</p><p>CDN 主要有以下优点：</p><ul><li>更快地将数据分发给用户；</li><li>通过部署多台服务器，从而提高系统整体的带宽性能；</li><li>多台服务器可以看成是一种冗余机制，从而具有高可用性。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6pgd7wvhj30k20960td.jpg" alt="img"></p><h2 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p><strong>解决方案</strong></p><p>1、缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</p><p>2、一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。</p><p>3、给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。</p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p><strong>解决方案</strong></p><p>1、接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</p><p>2、从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击；</p><p>3、采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。</p><p><strong>附加</strong></p><p>对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。</p><p><strong>Bitmap</strong>：典型的就是哈希表</p><p>缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。</p><p><strong>布隆过滤器（推荐）</strong></p><p>就是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。</p><p>它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><p>Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。</p><p>Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。</p><p>Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p><p><strong>解决方案</strong></p><p>1、设置热点数据永远不过期</p><p>2、加互斥锁，互斥锁</p><h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p><p><strong>解决方案</strong></p><p>1、直接写个缓存刷新页面，上线时手工操作一下；</p><p>2、数据量不大，可以在项目启动的时候自动进行加载；</p><p>3、定时刷新缓存；</p><h3 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h3><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p><p>缓存降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p><p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p><p>1、一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</p><p>2、警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</p><p>3、错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</p><p>4、严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p><p>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</p><h3 id="热点数据和冷数据"><a href="#热点数据和冷数据" class="headerlink" title="热点数据和冷数据"></a>热点数据和冷数据</h3><p>热点数据，缓存才有价值</p><p>对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存</p><p>对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。</p><p>数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。</p><p>那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。</p><p><strong>缓存热点key</strong></p><p>缓存中的一个Key(比如一个促销商品)，在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><p><strong>解决方案</strong></p><p>对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询</p><p><strong>如何保证缓存与数据库双写时的数据一致性？</strong></p><p>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p><p>一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况</p><p>串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p><p>还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是<strong>先更新数据库，然后再删除缓存</strong>。</p><h2 id="数据分布"><a href="#数据分布" class="headerlink" title="数据分布"></a>数据分布</h2><h3 id="顺序分布"><a href="#顺序分布" class="headerlink" title="顺序分布"></a>顺序分布</h3><p>将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如 User 表的 ID 范围为 1 ~ 7000，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，..…，6001 ~ 7000。</p><p>顺序分布相比于哈希分布的主要优点如下：</p><ul><li>能保持数据原有的顺序；</li><li>并且能够准确控制每台服务器存储的数据量，从而使得存储空间的利用率最大。</li></ul><h3 id="哈希分布"><a href="#哈希分布" class="headerlink" title="哈希分布"></a>哈希分布</h3><p>哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。</p><p>传统的哈希分布算法存在一个问题：<strong>当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。</strong></p><h3 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h3><p>Distributed Hash Table（DHT） 是一种哈希分布方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题。</p><p><strong>基本原理</strong></p><p>将哈希空间 [0, 2^n^-1] 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6pgeci4vj30fa0fd0te.jpg" alt="img"></p><p>一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点，例如下图中新增节点 X，只需要将它前一个节点 C 上的数据重新进行分布即可，对于节点 A、B、D 都没有影响。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6pgf7o3rj30f60fo0ti.jpg" alt="img"></p><h3 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h3><p>上面描述的一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同。</p><p>数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。</p><p>解决方式是通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Redis简介&quot;&gt;&lt;a href=&quot;#Redis简介&quot; class=&quot;headerlink&quot; title=&quot;Redis简介&quot;&gt;&lt;/a&gt;Redis简介&lt;/h2&gt;&lt;h3 id=&quot;什么是Redis&quot;&gt;&lt;a href=&quot;#什么是Redis&quot; class=&quot;headerlink&quot; title=&quot;什么是Redis&quot;&gt;&lt;/a&gt;什么是Redis&lt;/h3&gt;&lt;p&gt;Redis(Remote Dictionary Server) 是一个使用 C 语言编写的，开源的（BSD许可）高性能非关系型（NoSQL）的键值对数据库。&lt;/p&gt;
&lt;p&gt;Redis 可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。&lt;/p&gt;
&lt;p&gt;与传统数据库不同的是， Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>sql基础</title>
    <link href="http://yoursite.com/2020/05/30/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/05/30/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E5%9F%BA%E7%A1%80/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2020-06-08T00:55:31.895Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  参考文档: <a href="https://www.w3school.com.cn/sql/index.asp" target="_blank" rel="noopener">SQL 教程</a></p></blockquote><h2 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h2><p><strong>SQL 是用于访问和处理数据库的标准的计算机语言。</strong></p><h4 id="什么是-SQL"><a href="#什么是-SQL" class="headerlink" title="什么是 SQL"></a>什么是 SQL</h4><ul><li>SQL 指结构化查询语言</li><li>SQL 使我们有能力访问数据库</li><li>SQL 是一种 ANSI 的标准计算机语言</li></ul><p>注：ANSI，美国国家标准化组织</p><a id="more"></a><h4 id="DBMS-数据库管理系统（Database-Management-System）"><a href="#DBMS-数据库管理系统（Database-Management-System）" class="headerlink" title="DBMS - 数据库管理系统（Database Management System）"></a>DBMS - 数据库管理系统（Database Management System）</h4><p>数据库管理系统是一种可以访问数据库中数据的计算机程序。</p><p>DBMS 使我们有能力在数据库中提取、修改或者存贮信息。</p><p>不同的 DBMS 提供不同的函数供查询、提交以及修改数据。</p><h4 id="RDBMS-关系数据库管理系统（Relational-Database-Management-System）"><a href="#RDBMS-关系数据库管理系统（Relational-Database-Management-System）" class="headerlink" title="RDBMS- 关系数据库管理系统（Relational Database Management System）"></a>RDBMS- 关系数据库管理系统（Relational Database Management System）</h4><p>RDBMS 是 SQL 的基础，同样也是所有现代数据库系统的基础，比如 MS SQL Server, IBM DB2, Oracle, MySQL 以及 Microsoft Access。</p><p>RDBMS 中的数据存储在被称为表（tables）的数据库对象中。</p><p>表是相关的数据项的集合，它由列和行组成。</p><h4 id="DML-和-DDL"><a href="#DML-和-DDL" class="headerlink" title="DML 和 DDL"></a>DML 和 DDL</h4><p>可以把 SQL 分为两个部分：数据操作语言 (DML) 和 数据定义语言 (DDL)。</p><p>SQL (结构化查询语言)是用于执行查询的语法。但是 SQL 语言也包含用于更新、插入和删除记录的语法。</p><p>查询和更新指令构成了 SQL 的 DML 部分：</p><ul><li><em>SELECT</em> - 从数据库表中获取数据</li><li><em>UPDATE</em> - 更新数据库表中的数据</li><li><em>DELETE</em> - 从数据库表中删除数据</li><li><em>INSERT INTO</em> - 向数据库表中插入数据</li></ul><p>SQL 的数据定义语言 (DDL) 部分使我们有能力创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。</p><p>SQL 中最重要的 DDL 语句:</p><ul><li><em>CREATE DATABASE</em> - 创建新数据库</li><li><em>ALTER DATABASE</em> - 修改数据库</li><li><em>CREATE TABLE</em> - 创建新表</li><li><em>ALTER TABLE</em> - 变更（改变）数据库表</li><li><em>DROP TABLE</em> - 删除表</li><li><em>CREATE INDEX</em> - 创建索引（搜索键）</li><li><em>DROP INDEX</em> - 删除索引</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><h5 id="大小写问题"><a href="#大小写问题" class="headerlink" title="大小写问题"></a>大小写问题</h5><p>一定要记住，SQL 对大小写不敏感！</p><h5 id="SQL-语句后面的分号"><a href="#SQL-语句后面的分号" class="headerlink" title="SQL 语句后面的分号"></a>SQL 语句后面的分号</h5><p>某些数据库系统要求在每条 SQL 命令的末端使用分号。</p><p>分号是在数据库系统中分隔每条 SQL 语句的标准方法，这样就可以在对服务器的相同请求中执行一条以上的语句。如果使用的是 MS Access 和 SQL Server 2000，则不必在每条 SQL 语句之后使用分号，不过某些数据库软件要求必须使用分号。</p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h4><p>SELECT 语句用于从表中选取数据。</p><p>结果被存储在一个结果表中（称为结果集）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名称 <span class="keyword">FROM</span> 表名称</span><br></pre></td></tr></table></figure><p>以及：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表名称</span><br></pre></td></tr></table></figure><p><strong>注释：</strong>SQL 语句对大小写不敏感。SELECT 等效于 select。</p><h4 id="SELECT-DISTINCT"><a href="#SELECT-DISTINCT" class="headerlink" title="SELECT DISTINCT"></a>SELECT DISTINCT</h4><p>在表中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。</p><p>关键词 DISTINCT 用于返回唯一不同的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 列名称 <span class="keyword">FROM</span> 表名称</span><br></pre></td></tr></table></figure><h4 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h4><p>如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名称 <span class="keyword">FROM</span> 表名称 <span class="keyword">WHERE</span> 列 运算符 值</span><br></pre></td></tr></table></figure><p>下面的运算符可在 WHERE 子句中使用：</p><table><thead><tr><th align="left">操作符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">等于</td></tr><tr><td align="left">&lt;&gt;</td><td align="left">不等于</td></tr><tr><td align="left">&gt;</td><td align="left">大于</td></tr><tr><td align="left">&lt;</td><td align="left">小于</td></tr><tr><td align="left">&gt;=</td><td align="left">大于等于</td></tr><tr><td align="left">&lt;=</td><td align="left">小于等于</td></tr><tr><td align="left">BETWEEN</td><td align="left">在某个范围内</td></tr><tr><td align="left">LIKE</td><td align="left">搜索某种模式</td></tr></tbody></table><p><strong>注释：</strong>在某些版本的 SQL 中，操作符 &lt;&gt; 可以写为 !=。</p><p><strong>引号的使用</strong></p><p>SQL 使用单引号来环绕<em>文本值</em>（大部分数据库系统也接受双引号）。如果是<em>数值</em>，请不要使用引号。</p><p><strong>AND 和 OR 运算符</strong></p><p>AND 和 OR 运算符用于基于一个以上的条件对记录进行过滤。</p><p>AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。</p><p>如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。</p><p>如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。</p><h4 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h4><p>GROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name, aggregate_function(column_name)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">operator</span> <span class="keyword">value</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column_name</span><br></pre></td></tr></table></figure><p><strong>GROUP BY 一个以上的列:</strong></p><p>我们也可以对一个以上的列应用 GROUP BY 语句，就像这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customer,OrderDate,<span class="keyword">SUM</span>(OrderPrice) <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Customer,OrderDate</span><br></pre></td></tr></table></figure><h4 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h4><p>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name, aggregate_function(column_name)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">operator</span> <span class="keyword">value</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column_name</span><br><span class="line"><span class="keyword">HAVING</span> aggregate_function(column_name) <span class="keyword">operator</span> valu</span><br></pre></td></tr></table></figure><h4 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h4><p>ORDER BY 语句用于根据指定的列对结果集进行排序。</p><p>ORDER BY 语句默认按照升序对记录进行排序。</p><p>如果希望按照降序对记录进行排序，可以使用 DESC 关键字。</p><p><strong>注意：</strong>使用多列进行排序时，左边的列的排序优先级高于右侧，</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> exp1, exp2 <span class="keyword">FROM</span> table1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> exp1, exp2 <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><p>先对exp1进行升序排序，若exp1相同，则按照exp2进行降序排序；若exp1没有重复，则不会对exp2排序。</p><h4 id="INSERT-INTO"><a href="#INSERT-INTO" class="headerlink" title="INSERT INTO"></a>INSERT INTO</h4><p>INSERT INTO 语句用于向表格中插入新的行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名称 <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>,....)</span><br></pre></td></tr></table></figure><p>我们也可以指定所要插入数据的列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (列<span class="number">1</span>, 列<span class="number">2</span>,...) <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>,....)</span><br></pre></td></tr></table></figure><h4 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h4><p>Update 语句用于修改表中的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名称 <span class="keyword">SET</span> 列名称 = 新值 <span class="keyword">WHERE</span> 列名称 = 某值</span><br></pre></td></tr></table></figure><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><p>DELETE 语句用于删除表中的行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名称 <span class="keyword">WHERE</span> 列名称 = 值</span><br></pre></td></tr></table></figure><p><strong>删除所有行</strong></p><p>可以在不删除表的情况下删除所有的行。这意味着<strong>表的结构、属性和索引都是完整的</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> * <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure><h4 id="CREATE-DATABASE"><a href="#CREATE-DATABASE" class="headerlink" title="CREATE DATABASE"></a>CREATE DATABASE</h4><p>CREATE DATABASE 用于创建数据库。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> database_name</span><br></pre></td></tr></table></figure><h4 id="CREATE-TABLE"><a href="#CREATE-TABLE" class="headerlink" title="CREATE TABLE"></a>CREATE TABLE</h4><p>CREATE TABLE 语句用于创建数据库中的表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名称</span><br><span class="line">(</span><br><span class="line">列名称<span class="number">1</span> 数据类型,</span><br><span class="line">列名称<span class="number">2</span> 数据类型,</span><br><span class="line">列名称<span class="number">3</span> 数据类型,</span><br><span class="line">....</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>数据类型（data_type）规定了列可容纳何种数据类型。下面的表格包含了SQL中最常用的数据类型：</p><table><thead><tr><th align="left">数据类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">integer(size) <br/>int(size) <br/>smallint(size)<br/>tinyint(size)</td><td align="left">仅容纳整数。在括号内规定数字的最大位数。</td></tr><tr><td align="left">decimal(size,d)<br/>numeric(size,d)</td><td align="left">容纳带有小数的数字。”size” 规定数字的最大位数。”d” 规定小数点右侧的最大位数。</td></tr><tr><td align="left">char(size)</td><td align="left">容纳固定长度的字符串（可容纳字母、数字以及特殊字符）。在括号中规定字符串的长度。</td></tr><tr><td align="left">varchar(size)</td><td align="left">容纳可变长度的字符串（可容纳字母、数字以及特殊的字符）。在括号中规定字符串的最大长度。</td></tr><tr><td align="left">date(yyyymmdd)</td><td align="left">容纳日期。</td></tr></tbody></table><h4 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a>ALTER TABLE</h4><p>ALTER TABLE 语句用于在已有的表中添加、修改或删除列。</p><p>如需在表中添加列，请使用下列语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> column_name datatype</span><br></pre></td></tr></table></figure><p>要删除表中的列，请使用下列语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> column_name</span><br></pre></td></tr></table></figure><p><strong>注释：</strong>某些数据库系统不允许这种在数据库表中删除列的方式 (DROP COLUMN column_name)。</p><p>要改变表中列的数据类型，请使用下列语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> column_name datatype</span><br></pre></td></tr></table></figure><h4 id="CREATE-INDEX"><a href="#CREATE-INDEX" class="headerlink" title="CREATE INDEX"></a>CREATE INDEX</h4><p><strong>CREATE INDEX 语句用于在表中创建索引。</strong></p><p><strong>在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。</strong></p><p>您可以在表中创建索引，以便更加快速高效地查询数据。</p><p>用户无法看到索引，它们只能被用来加速搜索/查询。</p><p><strong>注释：</strong>更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。因此，理想的做法是<strong>仅仅在常常被搜索的列（以及表）上面创建索引</strong>。</p><p><strong>CREATE INDEX 语法:</strong></p><p>在表上创建一个简单的索引。允许使用重复的值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (column_name [<span class="keyword">DESC</span>])</span><br></pre></td></tr></table></figure><p><strong>注释：</strong>“column_name” 规定需要索引的列。</p><p><strong>SQL CREATE UNIQUE INDEX 语法:</strong></p><p>在表上创建一个唯一的索引。<strong>唯一的索引意味着两个行不能拥有相同的索引值</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (column_name)</span><br></pre></td></tr></table></figure><h4 id="CREATE-VIEW"><a href="#CREATE-VIEW" class="headerlink" title="CREATE VIEW"></a>CREATE VIEW</h4><p>什么是视图？</p><p>在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。</p><p>视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据，就像这些来自于某个单一的表。</p><p><strong>注释：</strong>数据库的设计和结构不会受到视图中的函数、where 或 join 语句的影响。</p><p>SQL CREATE VIEW 语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> condition</span><br></pre></td></tr></table></figure><p><strong>注释：</strong>视图总是显示最近的数据。每当用户查询视图时，数据库引擎通过使用 SQL 语句来重建数据。</p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h4 id="TOP-LIMIT"><a href="#TOP-LIMIT" class="headerlink" title="TOP (LIMIT)"></a>TOP (LIMIT)</h4><p>TOP 子句用于规定要返回的记录的数目。</p><p>对于拥有数千条记录的大型表来说，TOP 子句是非常有用的。</p><p><strong>注释：</strong>并非所有的数据库系统都支持 TOP 子句。</p><p>MySQL 语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="keyword">numbe</span></span><br></pre></td></tr></table></figure><h4 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h4><p>LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">LIKE</span> pattern</span><br></pre></td></tr></table></figure><p><strong>通配符:</strong></p><p>在搜索数据库中的数据时，SQL 通配符可以替代一个或多个字符。</p><p>SQL 通配符必须与 LIKE 运算符一起使用。</p><p>在 SQL 中，可使用以下通配符：</p><table><thead><tr><th align="left">通配符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">%</td><td align="left">替代一个或多个字符</td></tr><tr><td align="left">_</td><td align="left">仅替代一个字符</td></tr><tr><td align="left">[charlist]</td><td align="left">字符列中的任何单一字符</td></tr><tr><td align="left">[^charlist]或者[!charlist]</td><td align="left">不在字符列中的任何单一字符</td></tr></tbody></table><h4 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h4><p>IN 操作符允许我们在 WHERE 子句中规定多个值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">IN</span> (value1,value2,...)</span><br></pre></td></tr></table></figure><h4 id="BETWEEN"><a href="#BETWEEN" class="headerlink" title="BETWEEN"></a>BETWEEN</h4><p>操作符 BETWEEN … AND 会选取介于两个值之间的数据范围。这些值可以是数值、文本或者日期。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name</span><br><span class="line"><span class="keyword">BETWEEN</span> value1 <span class="keyword">AND</span> value2</span><br></pre></td></tr></table></figure><p><strong>重要事项：</strong>不同的数据库对 BETWEEN…AND 操作符的处理方式是有差异的。所以，请检查你的数据库是如何处理 BETWEEN….AND 操作符的！</p><h4 id="SQL-Alias"><a href="#SQL-Alias" class="headerlink" title="SQL Alias"></a>SQL Alias</h4><p><strong>通过使用 SQL，可以为列名称和表名称指定别名（Alias）。</strong></p><p>表的 SQL Alias 语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">AS</span> alias_name</span><br></pre></td></tr></table></figure><p>列的 SQL Alias 语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name </span><br><span class="line"><span class="keyword">AS</span> alias_name</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure><h4 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h4><p><strong>SQL join 用于根据两个或多个表中的列之间的关系，从这些表中查询数据。</strong></p><p><strong>Join 和 Key</strong></p><p>有时为了得到完整的结果，我们需要从两个或更多的表中获取结果。我们就需要执行 join。</p><p>数据库中的表可通过键将彼此联系起来。主键（Primary Key）是一个列，在这个列中的每一行的值都是唯一的。在表中，每个主键的值都是唯一的。这样做的目的是在不重复每个表中的所有数据的情况下，把表间的数据交叉捆绑在一起。</p><p>我们可以通过引用两个表的方式，从两个表中获取数据，我们也可以使用关键词 JOIN 来从两个表中获取数据。</p><p><strong>不同的 SQL JOIN</strong></p><ul><li>JOIN: 如果表中有至少一个匹配，则返回行</li><li>LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行</li><li>RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行</li><li>FULL JOIN: 只要其中一个表中存在匹配，就返回行</li></ul><h5 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h5><p>在表中存在至少一个匹配时，INNER JOIN 关键字返回行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> table_name2 </span><br><span class="line"><span class="keyword">ON</span> table_name1.column_name=table_name2.column_name</span><br></pre></td></tr></table></figure><p><strong>注释：</strong>INNER JOIN 与 JOIN 是相同的。</p><h5 id="LEFT-JOIN"><a href="#LEFT-JOIN" class="headerlink" title="LEFT JOIN"></a>LEFT JOIN</h5><p>LEFT JOIN 关键字会从左表 (table_name1) 那里返回所有的行，即使在右表 (table_name2) 中没有匹配的行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table_name2 </span><br><span class="line"><span class="keyword">ON</span> table_name1.column_name=table_name2.column_name</span><br></pre></td></tr></table></figure><p><strong>注释：</strong>在某些数据库中， LEFT JOIN 称为 LEFT OUTER JOIN。</p><h5 id="RIGHT-JOIN"><a href="#RIGHT-JOIN" class="headerlink" title="RIGHT JOIN"></a>RIGHT JOIN</h5><p>RIGHT JOIN 关键字会右表 (table_name2) 那里返回所有的行，即使在左表 (table_name1) 中没有匹配的行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name1</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> table_name2 </span><br><span class="line"><span class="keyword">ON</span> table_name1.column_name=table_name2.column_name</span><br></pre></td></tr></table></figure><p><strong>注释：</strong>在某些数据库中， RIGHT JOIN 称为 RIGHT OUTER JOIN。</p><h5 id="FULL-JOIN"><a href="#FULL-JOIN" class="headerlink" title="FULL JOIN"></a>FULL JOIN</h5><p>只要其中某个表存在匹配，FULL JOIN 关键字就会返回行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name1</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">JOIN</span> table_name2 </span><br><span class="line"><span class="keyword">ON</span> table_name1.column_name=table_name2.column_name</span><br></pre></td></tr></table></figure><p><strong>注释：</strong>在某些数据库中， FULL JOIN 称为 FULL OUTER JOIN。</p><h4 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h4><p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。</p><p>请注意，<strong>UNION 内部的 SELECT 语句必须拥有相同数量的列，也必须拥有相似的数据类型，同时每条 SELECT 语句中的列的顺序必须相同</strong>。</p><p>SQL UNION 语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name1</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name2</span><br></pre></td></tr></table></figure><p><strong>注释：</strong>默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。</p><p>SQL UNION ALL 语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name1</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name2</span><br></pre></td></tr></table></figure><p>另外，<strong>UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名</strong>。</p><h4 id="SELECT-INTO"><a href="#SELECT-INTO" class="headerlink" title="SELECT INTO"></a>SELECT INTO</h4><p>SELECT INTO 语句从一个表中选取数据，然后把数据插入另一个表中。</p><p>SELECT INTO 语句常用于创建表的备份复件或者用于对记录进行存档。</p><p>您可以把所有的列插入新表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">INTO</span> new_table_name [<span class="keyword">IN</span> externaldatabase] </span><br><span class="line"><span class="keyword">FROM</span> old_tablename</span><br></pre></td></tr></table></figure><p>或者只把希望的列插入新表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">INTO</span> new_table_name [<span class="keyword">IN</span> externaldatabase] </span><br><span class="line"><span class="keyword">FROM</span> old_tablename</span><br></pre></td></tr></table></figure><h4 id="SQL-DROP"><a href="#SQL-DROP" class="headerlink" title="SQL DROP"></a>SQL DROP</h4><p><strong>通过使用 DROP 语句，可以轻松地删除索引、表和数据库。</strong></p><p><strong>SQL DROP INDEX 语句:</strong></p><p>我们可以使用 DROP INDEX 命令删除表格中的索引。</p><p>用于 MySQL 的语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name</span><br></pre></td></tr></table></figure><p><strong>SQL DROP DATABASE 语句:</strong></p><p>DROP DATABASE 语句用于删除数据库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> 数据库名称</span><br></pre></td></tr></table></figure><h4 id="TRUNCATE"><a href="#TRUNCATE" class="headerlink" title="TRUNCATE"></a>TRUNCATE</h4><p>如果我们仅仅需要除去表内的数据，但并不删除表本身，那么我们该如何做呢？</p><p>请使用 TRUNCATE TABLE 命令（仅仅删除表格中的数据）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 表名称</span><br></pre></td></tr></table></figure><h4 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h4><p>如果表中的某个列是可选的，那么我们可以在不向该列添加值的情况下插入新记录或更新已有的记录。这意味着该字段将以 NULL 值保存。</p><p>NULL 值的处理方式与其他值不同。</p><p>NULL 用作未知的或不适用的值的占位符。</p><p><strong>注释：</strong>无法比较 NULL 和 0；<strong>它们是不等价的</strong>。</p><p>那么我们如何测试 NULL 值呢？</p><p>无法使用比较运算符来测试 NULL 值，比如 =, &lt;, 或者 &lt;&gt;。</p><p>我们必须使用 IS NULL 和 IS NOT NULL 操作符。</p><h2 id="约束-Constraints"><a href="#约束-Constraints" class="headerlink" title="约束 (Constraints)"></a>约束 (Constraints)</h2><h4 id="约束简介"><a href="#约束简介" class="headerlink" title="约束简介"></a>约束简介</h4><p>约束用于限制加入表的数据的类型。</p><p>可以在创建表时规定约束（通过 CREATE TABLE 语句），或者在表创建之后也可以（通过 ALTER TABLE 语句）。</p><h4 id="NOT-NULL"><a href="#NOT-NULL" class="headerlink" title="NOT NULL"></a>NOT NULL</h4><p>NOT NULL 约束强制列不接受 NULL 值。</p><p>NOT NULL 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。</p><h4 id="UNIQUE"><a href="#UNIQUE" class="headerlink" title="UNIQUE"></a>UNIQUE</h4><p>UNIQUE 约束唯一标识数据库表中的每条记录。</p><p>UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。</p><p>PRIMARY KEY 拥有自动定义的 UNIQUE 约束。</p><p>请注意，<strong>每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束</strong>。</p><h4 id="PRIMARY-KEY"><a href="#PRIMARY-KEY" class="headerlink" title="PRIMARY KEY"></a>PRIMARY KEY</h4><p>PRIMARY KEY 约束唯一标识数据库表中的每条记录。</p><p>主键必须包含唯一的值。</p><p>主键列不能包含 NULL 值。</p><p>每个表都应该有一个主键，并且每个表只能有一个主键。</p><h4 id="FOREIGN-KEY"><a href="#FOREIGN-KEY" class="headerlink" title="FOREIGN KEY"></a>FOREIGN KEY</h4><p>一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY。</p><p>FOREIGN KEY 约束用于预防破坏表之间连接的动作。</p><p>FOREIGN KEY 约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</p><h4 id="CHECK"><a href="#CHECK" class="headerlink" title="CHECK"></a>CHECK</h4><p>CHECK 约束用于限制列中的值的范围。</p><p>如果对单个列定义 CHECK 约束，那么该列只允许特定的值。</p><p>如果对一个表定义 CHECK 约束，那么此约束会在特定的列中对值进行限制。</p><h4 id="DEFAULT"><a href="#DEFAULT" class="headerlink" title="DEFAULT"></a>DEFAULT</h4><p>DEFAULT 约束用于向列中插入默认值。</p><p>如果没有规定其他的值，那么会将默认值添加到所有的新记录。</p><h4 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO INCREMENT"></a>AUTO INCREMENT</h4><p><strong>Auto-increment 会在新记录插入表中时生成一个唯一的数字。</strong></p><p>我们通常希望在每次插入新记录时，自动地创建主键字段的值。</p><p>我们可以在表中创建一个 auto-increment 字段。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h4 id="函数简介"><a href="#函数简介" class="headerlink" title="函数简介"></a>函数简介</h4><p>内建 SQL 函数的语法是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">function</span>(列) <span class="keyword">FROM</span> 表</span><br></pre></td></tr></table></figure><p>在 SQL 中，基本的函数类型和种类有若干种。函数的基本类型是：</p><ul><li><p>Aggregate 函数</p><p>Aggregate 函数的操作面向一系列的值，并返回一个单一的值。</p><p><strong>注释：</strong>如果在 SELECT 语句的项目列表中的众多其它表达式中使用 SELECT 语句，则这个 SELECT 必须使用 GROUP BY 语句</p></li><li><p>Scalar 函数</p><p>Scalar 函数的操作面向某个单一的值，并返回基于输入值的一个单一的值。</p></li></ul><h4 id="AVG"><a href="#AVG" class="headerlink" title="AVG"></a>AVG</h4><p>AVG 函数返回数值列的平均值。NULL 值不包括在计算中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(column_name) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure><h4 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT"></a>COUNT</h4><p><strong>SQL COUNT(column_name) 语法:</strong></p><p>COUNT(column_name) 函数返回指定列的值的数目（NULL 不计入）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(column_name) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure><p><strong>SQL COUNT(*) 语法:</strong></p><p>COUNT(*) 函数返回表中的记录数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure><p><strong>SQL COUNT(DISTINCT column_name) 语法:</strong></p><p>COUNT(DISTINCT column_name) 函数返回指定列的不同值的数目：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> column_name) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure><p><strong>注释：</strong>COUNT(DISTINCT) 适用于 ORACLE 和 Microsoft SQL Server，但是无法用于 Microsoft Access。</p><h4 id="FIRST"><a href="#FIRST" class="headerlink" title="FIRST"></a>FIRST</h4><p>FIRST() 函数返回指定的字段中第一个记录的值。</p><p><strong>提示：</strong>可使用 ORDER BY 语句对记录进行排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FIRST</span>(column_name) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure><h4 id="LAST"><a href="#LAST" class="headerlink" title="LAST"></a>LAST</h4><p>LAST() 函数返回指定的字段中最后一个记录的值。</p><p><strong>提示：</strong>可使用 ORDER BY 语句对记录进行排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LAST</span>(column_name) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure><h4 id="MAX"><a href="#MAX" class="headerlink" title="MAX"></a>MAX</h4><p>MAX 函数返回一列中的最大值。NULL 值不包括在计算中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(column_name) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure><p><strong>注释：</strong>MIN 和 MAX 也可用于文本列，以获得按字母顺序排列的最高或最低值。</p><h4 id="MIN"><a href="#MIN" class="headerlink" title="MIN"></a>MIN</h4><p>MIN 函数返回一列中的最小值。NULL 值不包括在计算中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(column_name) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure><p><strong>注释：</strong>MIN 和 MAX 也可用于文本列，以获得按字母顺序排列的最高或最低值。</p><h4 id="SUM"><a href="#SUM" class="headerlink" title="SUM"></a>SUM</h4><p>SUM 函数返回数值列的总数（总额）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(column_name) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure><p><strong>合计函数 (比如 SUM) 常常需要添加 GROUP BY 语句。</strong></p><h4 id="UCASE"><a href="#UCASE" class="headerlink" title="UCASE"></a>UCASE</h4><p>UCASE 函数把字段的值转换为大写。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">UCASE</span>(column_name) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure><h4 id="LCASE"><a href="#LCASE" class="headerlink" title="LCASE"></a>LCASE</h4><p>LCASE 函数把字段的值转换为小写。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LCASE</span>(column_name) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure><h4 id="MID"><a href="#MID" class="headerlink" title="MID"></a>MID</h4><p>MID 函数用于从文本字段中提取字符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MID</span>(column_name,<span class="keyword">start</span>[,<span class="keyword">length</span>]) <span class="keyword">FROM</span> table_names</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">column_name</td><td align="left">必需。要提取字符的字段。</td></tr><tr><td align="left">start</td><td align="left">必需。规定开始位置（起始值是 1）。</td></tr><tr><td align="left">length</td><td align="left">可选。要返回的字符数。如果省略，则 MID() 函数返回剩余文本。</td></tr></tbody></table><h4 id="LEN"><a href="#LEN" class="headerlink" title="LEN"></a>LEN</h4><p>LEN 函数返回文本字段中值的长度。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LEN</span>(column_name) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure><h4 id="ROUND"><a href="#ROUND" class="headerlink" title="ROUND"></a>ROUND</h4><p>ROUND 函数用于把数值字段舍入为指定的小数位数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ROUND</span>(column_name,decimals) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">column_name</td><td align="left">必需。要舍入的字段。</td></tr><tr><td align="left">decimals</td><td align="left">必需。规定要返回的小数位数。</td></tr></tbody></table><h4 id="NOW"><a href="#NOW" class="headerlink" title="NOW"></a>NOW</h4><p>NOW 函数返回当前的日期和时间。</p><p><strong>提示：</strong>如果您在使用 Sql Server 数据库，请使用 getdate() 函数来获得当前的日期时间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NOW</span>() <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure><h4 id="FORMAT"><a href="#FORMAT" class="headerlink" title="FORMAT"></a>FORMAT</h4><p>FORMAT 函数用于对字段的显示进行格式化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FORMAT</span>(column_name,<span class="keyword">format</span>) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">column_name</td><td align="left">必需。要格式化的字段。</td></tr><tr><td align="left">format</td><td align="left">必需。规定格式。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;  参考文档: &lt;a href=&quot;https://www.w3school.com.cn/sql/index.asp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SQL 教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;SQL简介&quot;&gt;&lt;a href=&quot;#SQL简介&quot; class=&quot;headerlink&quot; title=&quot;SQL简介&quot;&gt;&lt;/a&gt;SQL简介&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;SQL 是用于访问和处理数据库的标准的计算机语言。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;什么是-SQL&quot;&gt;&lt;a href=&quot;#什么是-SQL&quot; class=&quot;headerlink&quot; title=&quot;什么是 SQL&quot;&gt;&lt;/a&gt;什么是 SQL&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;SQL 指结构化查询语言&lt;/li&gt;
&lt;li&gt;SQL 使我们有能力访问数据库&lt;/li&gt;
&lt;li&gt;SQL 是一种 ANSI 的标准计算机语言&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：ANSI，美国国家标准化组织&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库系统原理</title>
    <link href="http://yoursite.com/2020/05/30/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/05/30/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2020-06-08T00:54:53.391Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  参考文档：<a href="https://cyc2018.github.io/CS-Notes/#/notes/数据库系统原理" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/notes/数据库系统原理</a></p></blockquote><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6pnlokjqj30us0jbq3x.jpg" alt="img" style="zoom:50%;" /><a id="more"></a><h3 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h3><h4 id="1-原子性（Atomicity）"><a href="#1-原子性（Atomicity）" class="headerlink" title="1. 原子性（Atomicity）"></a>1. 原子性（Atomicity）</h4><p>事务被视为<strong>不可分割的最小单元</strong>，事务的所有操作要么全部提交成功，要么全部失败回滚。</p><p>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p><h4 id="2-一致性（Consistency）"><a href="#2-一致性（Consistency）" class="headerlink" title="2. 一致性（Consistency）"></a>2. 一致性（Consistency）</h4><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</p><h4 id="3-隔离性（Isolation）"><a href="#3-隔离性（Isolation）" class="headerlink" title="3. 隔离性（Isolation）"></a>3. 隔离性（Isolation）</h4><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p><h4 id="4-持久性（Durability）"><a href="#4-持久性（Durability）" class="headerlink" title="4. 持久性（Durability）"></a>4. 持久性（Durability）</h4><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p><p>系统发生奔溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</p><hr><p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对系统崩溃的情况。</li></ul><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6pgh34gyj30uy0fndgv.jpg" alt="img" style="zoom:50%;" /><h3 id="AUTOCOMMIT"><a href="#AUTOCOMMIT" class="headerlink" title="AUTOCOMMIT"></a>AUTOCOMMIT</h3><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p><h2 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h2><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p><h3 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h3><p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6pgi2qgmj30tu0hiaaq.jpg" alt="img" style="zoom:50%;" /><h3 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h3><p>T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6pgii73mj30r10mygmh.jpg" alt="img" style="zoom:50%;" /><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6pgjghfkj30ra0l1mxw.jpg" alt="img" style="zoom:50%;" /><h3 id="幻影读"><a href="#幻影读" class="headerlink" title="幻影读"></a>幻影读</h3><p>T1 读取某个<strong>范围</strong>的数据，T2 在这个<strong>范围内</strong>插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6pgkbmzwj30sb0kwt9o.jpg" alt="img" style="zoom:50%;" /><hr><p>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p><h2 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h2><h3 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h3><p>MySQL 中提供了两种封锁粒度：<strong>行级锁</strong>以及<strong>表级锁</strong>。</p><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p><p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p><p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p><h3 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h3><h4 id="1-读写锁"><a href="#1-读写锁" class="headerlink" title="1. 读写锁"></a>1. 读写锁</h4><ul><li>互斥锁（Exclusive），简写为 X 锁，又称写锁。</li><li>共享锁（Shared），简写为 S 锁，又称读锁。</li></ul><p>有以下两个规定：</p><ul><li>一个事务对数据对象 A 加了 <strong>X 锁</strong>，就可以对 A 进行<strong>读取</strong>和<strong>更新</strong>。<strong>加锁期间其它事务不能对 A 加任何锁</strong>。</li><li>一个事务对数据对象 A 加了 <strong>S 锁</strong>，可以对 A 进行<strong>读取</strong>操作，但是不能进行更新操作。<strong>加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁</strong>。</li></ul><p>锁的兼容关系如下：</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6pgkr46bj30tw0d2mxl.jpg" alt="img" style="zoom:50%;" /><h4 id="2-意向锁"><a href="#2-意向锁" class="headerlink" title="2. 意向锁"></a>2. 意向锁</h4><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p><p>意向锁在原来的 X/S 锁之上引入了 IX/IS，<strong>IX/IS 都是表锁</strong>，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p><ul><li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li><li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li></ul><p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p><p>各种锁的兼容关系如下：</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6pglpg3tj30tz0g474z.jpg" alt="img" style="zoom:50%;" /><p>解释如下：</p><ul><li>任意 IS/IX 锁之间都是兼容的，因为它们<strong>只表示想要对表加锁，而不是真正加锁</strong>；</li><li>这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</li></ul><h3 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h3><h4 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h4><p><strong>一级封锁协议</strong></p><p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p><p>可以<strong>解决丢失修改问题</strong>，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6pgmltgij30vd0q0wfs.jpg" alt="img" style="zoom:50%;" /><p><strong>二级封锁协议</strong></p><p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p><p>可以<strong>解决读脏数据问题</strong>，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6pgnk9nqj30u70qiabe.jpg" alt="img" style="zoom:50%;" /><p><strong>三级封锁协议</strong></p><p>在二级的基础上，要求读取数据 A 时必须加 S 锁，<strong>直到事务结束</strong>了才能释放 S 锁。</p><p>可以<strong>解决不可重复读的问题</strong>，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6pgp1gpij30t50sawft.jpg" alt="img" style="zoom:50%;" /><h4 id="两段封锁协议"><a href="#两段封锁协议" class="headerlink" title="两段封锁协议"></a>两段封锁协议</h4><p>加锁和解锁分为两个阶段进行。</p><p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p><p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure><p>但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure><h3 id="MySQL-隐式与显示锁定"><a href="#MySQL-隐式与显示锁定" class="headerlink" title="MySQL 隐式与显示锁定"></a>MySQL 隐式与显示锁定</h3><p>MySQL 的 <strong>InnoDB 存储引擎采用两段锁协议</strong>，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p><p>InnoDB 也可以使用特定的语句进行显示锁定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">In</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="未提交读（READ-UNCOMMITTED）"><a href="#未提交读（READ-UNCOMMITTED）" class="headerlink" title="未提交读（READ UNCOMMITTED）"></a>未提交读（READ UNCOMMITTED）</h3><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p><h3 id="提交读（READ-COMMITTED）"><a href="#提交读（READ-COMMITTED）" class="headerlink" title="提交读（READ COMMITTED）"></a>提交读（READ COMMITTED）</h3><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p><h3 id="可重复读（REPEATABLE-READ）"><a href="#可重复读（REPEATABLE-READ）" class="headerlink" title="可重复读（REPEATABLE READ）"></a>可重复读（REPEATABLE READ）</h3><p>保证在同一个事务中多次读取同一数据的结果是一样的。</p><h3 id="可串行化（SERIALIZABLE）"><a href="#可串行化（SERIALIZABLE）" class="headerlink" title="可串行化（SERIALIZABLE）"></a>可串行化（SERIALIZABLE）</h3><p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p><p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p><hr><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6pgpwa4dj30v10gb0u1.jpg" alt="img" style="zoom:50%;" /><h2 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h2><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 <strong>InnoDB 存储引擎实现隔离级别的一种具体方式</strong>，<strong>用于实现提交读和可重复读这两种隔离级别</strong>。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>在封锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 <strong>MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系</strong>，这一点和 CopyOnWrite 类似。</p><p>在 MVCC 中事务的<strong>修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照</strong>。</p><p>脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，<strong>MVCC 规定只能读取已经提交的快照</strong>。当然一个事务可以读取自身未提交的快照，这不算是脏读。</p><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><ul><li>系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li><li>事务版本号 TRX_ID ：事务开始时的系统版本号。</li></ul><h3 id="Undo-日志"><a href="#Undo-日志" class="headerlink" title="Undo 日志"></a>Undo 日志</h3><p>MVCC 的多版本指的是多个版本的快照，<strong>快照存储在 Undo 日志中</strong>，该日志通过回滚指针 <code>ROLL_PTR</code> 把一个数据行的所有快照连接起来。</p><p>例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t(<span class="keyword">id</span>, x) <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> x=<span class="string">"b"</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> x=<span class="string">"c"</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>因为没有使用 <code>START TRANSACTION</code> 将上面的操作当成一个事务来执行，根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6pgqfcvhj30ty0aoq3m.jpg" alt="img" style="zoom:50%;" /><p>INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。</p><h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>MVCC 维护了一个 <code>ReadView</code> 结构，主要包含了当前系统未提交的事务列表 <code>TRX_IDs {TRX_ID_1, TRX_ID_2, ...}</code>，还有该列表的最小值 <code>TRX_ID_MIN</code> 和 <code>TRX_ID_MAX</code>。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6pgraso5j30tf0dhgm3.jpg" alt="img" style="zoom:50%;" /><p>在进行 SELECT 操作时，根据数据行快照的 <code>TRX_ID</code> 与 <code>TRX_ID_MIN</code> 和 <code>TRX_ID_MAX</code> 之间的关系，从而判断数据行快照是否可以使用：</p><ul><li><code>TRX_ID &lt; TRX_ID_MIN</code>，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。</li><li><code>TRX_ID &gt; TRX_ID_MAX</code>，表示该数据行快照是在事务启动之后被更改的，因此不可使用。</li><li><code>TRX_ID_MIN</code> &lt;= <code>TRX_ID</code> &lt;= <code>TRX_ID_MAX</code>，需要根据隔离级别再进行判断：<ul><li>提交读：如果 <code>TRX_ID</code> 在 <code>TRX_IDs</code> 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。</li><li>可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</li></ul></li></ul><p>在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。</p><h3 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h3><h4 id="1-快照读"><a href="#1-快照读" class="headerlink" title="1. 快照读"></a>1. 快照读</h4><p>MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> ...;</span><br></pre></td></tr></table></figure><h4 id="2-当前读"><a href="#2-当前读" class="headerlink" title="2. 当前读"></a>2. 当前读</h4><p>MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span>;</span><br><span class="line"><span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">DELETE</span>;</span><br></pre></td></tr></table></figure><p>在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><h2 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h2><p><strong>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现</strong>。</p><p>MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。<strong>在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</strong></p><h3 id="Record-Locks"><a href="#Record-Locks" class="headerlink" title="Record Locks"></a>Record Locks</h3><p><strong>锁定一个记录上的索引，而不是记录本身。</strong></p><p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p><h3 id="Gap-Locks"><a href="#Gap-Locks" class="headerlink" title="Gap Locks"></a>Gap Locks</h3><p><strong>锁定索引之间的间隙，但是不包含索引本身</strong>。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><h3 id="Next-Key-Locks-1"><a href="#Next-Key-Locks-1" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h3><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(-∞, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, +∞)</span><br></pre></td></tr></table></figure><h2 id="关系数据库设计理论"><a href="#关系数据库设计理论" class="headerlink" title="关系数据库设计理论"></a>关系数据库设计理论</h2><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p><p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p><p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p><p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p><table><thead><tr><th>Sno</th><th>Sname</th><th>Sdept</th><th>Mname</th><th>Cname</th><th>Grade</th></tr></thead><tbody><tr><td>1</td><td>学生-1</td><td>学院-1</td><td>院长-1</td><td>课程-1</td><td>90</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td><td>课程-2</td><td>80</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td><td>课程-1</td><td>100</td></tr><tr><td>3</td><td>学生-3</td><td>学院-2</td><td>院长-2</td><td>课程-2</td><td>95</td></tr></tbody></table><p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p><ul><li>冗余数据：例如 <code>学生-2</code> 出现了两次。</li><li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li><li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li><li>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li></ul><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>范式理论是为了解决以上提到四种异常。</p><p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p><h4 id="1-第一范式-1NF"><a href="#1-第一范式-1NF" class="headerlink" title="1. 第一范式 (1NF)"></a>1. 第一范式 (1NF)</h4><p>1NF的定义为：符合1NF的关系中的每个属性都不可再分。1NF是所有关系型数据库的最基本要求。</p><p>但是仅仅符合1NF的设计，仍然会存在数据冗余过大，插入异常，删除异常，修改异常的问题。</p><h4 id="2-第二范式-2NF"><a href="#2-第二范式-2NF" class="headerlink" title="2. 第二范式 (2NF)"></a>2. 第二范式 (2NF)</h4><p>2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。</p><p>每个非主属性完全函数依赖于键码，可以通过分解来满足。</p><p><strong>分解前</strong></p><table><thead><tr><th>Sno</th><th>Sname</th><th>Sdept</th><th>Mname</th><th>Cname</th><th>Grade</th></tr></thead><tbody><tr><td>1</td><td>学生-1</td><td>学院-1</td><td>院长-1</td><td>课程-1</td><td>90</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td><td>课程-2</td><td>80</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td><td>课程-1</td><td>100</td></tr><tr><td>3</td><td>学生-3</td><td>学院-2</td><td>院长-2</td><td>课程-2</td><td>95</td></tr></tbody></table><p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li><li>Sno, Cname-&gt; Grade</li></ul><p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p><p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p><p><strong>分解后</strong></p><p>关系-1</p><table><thead><tr><th>Sno</th><th>Sname</th><th>Sdept</th><th>Mname</th></tr></thead><tbody><tr><td>1</td><td>学生-1</td><td>学院-1</td><td>院长-1</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td></tr><tr><td>3</td><td>学生-3</td><td>学院-2</td><td>院长-2</td></tr></tbody></table><p>有以下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li></ul><p>关系-2</p><table><thead><tr><th>Sno</th><th>Cname</th><th>Grade</th></tr></thead><tbody><tr><td>1</td><td>课程-1</td><td>90</td></tr><tr><td>2</td><td>课程-2</td><td>80</td></tr><tr><td>2</td><td>课程-1</td><td>100</td></tr><tr><td>3</td><td>课程-2</td><td>95</td></tr></tbody></table><p>有以下函数依赖：</p><ul><li>Sno, Cname -&gt; Grade</li></ul><h4 id="3-第三范式-3NF"><a href="#3-第三范式-3NF" class="headerlink" title="3. 第三范式 (3NF)"></a>3. 第三范式 (3NF)</h4><p>非主属性不传递函数依赖于键码。</p><p>3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求。</p><p>符合3NF要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。当然，在实际中，往往为了性能上或者应对扩展的需要，经常 做到2NF或者1NF。</p><p>上面的 关系-1 中存在以下传递函数依赖：</p><ul><li>Sno -&gt; Sdept -&gt; Mname</li></ul><p>可以进行以下分解：</p><p>关系-11</p><table><thead><tr><th>Sno</th><th>Sname</th><th>Sdept</th></tr></thead><tbody><tr><td>1</td><td>学生-1</td><td>学院-1</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td></tr><tr><td>3</td><td>学生-3</td><td>学院-2</td></tr></tbody></table><p>关系-12</p><table><thead><tr><th>Sdept</th><th>Mname</th></tr></thead><tbody><tr><td>学院-1</td><td>院长-1</td></tr><tr><td>学院-2</td><td>院长-2</td></tr></tbody></table><h2 id="ER-图"><a href="#ER-图" class="headerlink" title="ER 图"></a>ER 图</h2><p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p><p>用来进行关系型数据库系统的概念设计。</p><h3 id="实体的三种联系"><a href="#实体的三种联系" class="headerlink" title="实体的三种联系"></a>实体的三种联系</h3><p>包含一对一，一对多，多对多三种。</p><ul><li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li><li>如果是一对一，画两个带箭头的线段；</li><li>如果是多对多，画两个不带箭头的线段。</li></ul><p>下图的 Course 和 Student 是一对多的关系。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6pgrwfhuj30f703y74a.jpg" alt="img" style="zoom:67%;" /><h3 id="表示出现多次的关系"><a href="#表示出现多次的关系" class="headerlink" title="表示出现多次的关系"></a>表示出现多次的关系</h3><p>一个实体在联系出现几次，就要用几条线连接。</p><p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6pgsso8aj309j079wel.jpg" alt="img" style="zoom:67%;" /><h3 id="联系的多向性"><a href="#联系的多向性" class="headerlink" title="联系的多向性"></a>联系的多向性</h3><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6pgt8i9mj30fd06omx9.jpg" alt="img" style="zoom:67%;" /><h3 id="表示子类"><a href="#表示子类" class="headerlink" title="表示子类"></a>表示子类</h3><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6pgu7d52j30l8090t92.jpg" alt="img" style="zoom:67%;" /><h2 id="三级模式与两级映射"><a href="#三级模式与两级映射" class="headerlink" title="三级模式与两级映射"></a>三级模式与两级映射</h2><h3 id="三级模式"><a href="#三级模式" class="headerlink" title="三级模式"></a>三级模式</h3><p>人们为数据库设计了一个严谨的体系结构，数据库领域公认的标准结构是三级模式结构，它包括外模式、概念模式、内模式，有效地组织、管理数据，提高了数据库的逻辑独立性和物理独立性。</p><h4 id="用户级–-gt-外模式-反映了数据库系统的用户观"><a href="#用户级–-gt-外模式-反映了数据库系统的用户观" class="headerlink" title="用户级–&gt; 外模式(反映了数据库系统的用户观)"></a>用户级–&gt; 外模式(反映了数据库系统的用户观)</h4><p>外模式又称子模式或用户模式，对应于用户级。<strong>它是某个或某几个用户所看到的数据库的数据视图，是与某一应用有关的数据的逻辑表示。</strong>外模式是从模式导出的一个子集，包含模式中允许特定用户使用的那部分数据。用户可以通过外模式描述语言来描述、定义对应于用户的数据记录(外模式)，也可以利用数据操纵语言(Data Manipulation Language，DML)对这些数据记录进行操作。</p><h4 id="概念级–-gt-概念模式（反映了数据库系统的整体观）"><a href="#概念级–-gt-概念模式（反映了数据库系统的整体观）" class="headerlink" title="概念级–&gt; 概念模式（反映了数据库系统的整体观）"></a>概念级–&gt; 概念模式（反映了数据库系统的整体观）</h4><p>概念模式又称模式或逻辑模式，对应于概念级。<strong>它是由数据库设计者综合所有用户的数据，按照统一的观点构造的全局逻辑结构，是对数据库中全部数据的逻辑结构和特征的总体描述，是所有用户的公共数据视图(全局视图)。</strong>它是由数据库管理系统提供的数据模式描述语言(Data Description Language，DDL)来描述、定义的。</p><h4 id="物理级-–-gt-内模式（反映了数据库系统的存储观）"><a href="#物理级-–-gt-内模式（反映了数据库系统的存储观）" class="headerlink" title="物理级 –&gt; 内模式（反映了数据库系统的存储观）"></a>物理级 –&gt; 内模式（反映了数据库系统的存储观）</h4><p>内模式又称存储模式，对应于物理级。<strong>它是数据库中全体数据的内部表示或底层描述，是数据库最低一级的逻辑描述，它描述了数据在存储介质上的存储方式和物理结构，对应着实际存储在外存储介质上的数据库。</strong>内模式由内模式描述语言来描述、定义的。</p><h3 id="两级映射"><a href="#两级映射" class="headerlink" title="两级映射"></a>两级映射</h3><p>数据库系统在三级模式之间提供了两级映像：模式/内模式的映像、外模式/模式的映像。</p><ul><li>模式/内模式的映像：实现概念模式到内模式之间的相互转换。</li><li>外模式/模式的映像：实现外模式到概念模式之间的相互转换。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;  参考文档：&lt;a href=&quot;https://cyc2018.github.io/CS-Notes/#/notes/数据库系统原理&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cyc2018.github.io/CS-Notes/#/notes/数据库系统原理&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6pnlokjqj30us0jbq3x.jpg&quot; alt=&quot;img&quot; style=&quot;zoom:50%;&quot; /&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://yoursite.com/2020/05/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/05/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2020-06-08T00:57:51.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><p><strong>二叉树（Binary Tree）</strong></p><p>二叉树（Binary Tree）是有限个节点的集合，这个集合可以是空集，也可以是一个根节点和两颗不相交的子二叉树组成的集合，其中一颗树叫根的左子树，另一颗树叫右子树。所以二叉树是一个递归地概念。</p><a id="more"></a><p><strong>满二叉树（Full Binary Tree）</strong><br>一棵满二叉树就是高度为k，且拥有<code>(2^k)-1</code>个节点的二叉树，一棵满二叉树每个节点，要么都有两棵子树，要么都没有子树；而且每一层所有的节点之间必须要么都有两棵子树，要么都没子树。</p><p><strong>完全二叉树（Complete Binary Tree）</strong><br>完全二叉树是一颗特殊的二叉树，假设完全二叉树高度为k，则完全二叉树需要符合以下两点：</p><ol><li>所有叶子节点都出现在k层或k-1层，并且从1~k-1层必须达到最大节点数</li><li>第k层可以是不满的，但是第k层的所有节点必须集中在最左边</li></ol><h2 id="二叉树的实现"><a href="#二叉树的实现" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h2><p>二叉树的左右链表表示法：</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4f6hekj3j30m80bvab1.jpg" alt="二叉树的左右链表表示法" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNode</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;  <span class="comment">//数据</span></span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode leftChild ;  <span class="comment">//左孩子</span></span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode rightChild ; <span class="comment">//右孩子</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getLeftChild</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> leftChild ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftChild</span> <span class="params">(BinaryTreeNode leftChild )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.leftChild  = leftChild ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getRightChild</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rightChild ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightChild</span> <span class="params">(BinaryTreeNode rightChild )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rightChild  = rightChild ;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的操作"><a href="#二叉树的操作" class="headerlink" title="二叉树的操作"></a>二叉树的操作</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="先根遍历-Pre-Order"><a href="#先根遍历-Pre-Order" class="headerlink" title="先根遍历(Pre Order)"></a>先根遍历(Pre Order)</h4><p>若二叉树为空，则退出，否则进行下面操作：</p><ul><li>访问根节点</li><li>先根遍历左子树</li><li>先根遍历右子树</li><li>退出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(node.getData()); <span class="comment">//先访问根节点</span></span><br><span class="line">        PreOrder(node.getLeftChild ());  <span class="comment">//先根遍历左子树</span></span><br><span class="line">        PreOrder(node.getRightChild ());  <span class="comment">//先根遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中根遍历-In-Order"><a href="#中根遍历-In-Order" class="headerlink" title="中根遍历(In Order)"></a>中根遍历(In Order)</h4><p>若二叉树为空，则退出，否则进行下面操作</p><ul><li>中根遍历左子树</li><li>访问根节点</li><li>中根遍历右子树</li><li>退出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        InOrder(node.getLeftChild());  <span class="comment">//中根遍历左子树</span></span><br><span class="line">        System.out.println(node.getData());    <span class="comment">//访问根节点</span></span><br><span class="line">        InOrder(node.getRightChild());  <span class="comment">//中根遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后根遍历-Post-Order"><a href="#后根遍历-Post-Order" class="headerlink" title="后根遍历(Post Order)"></a>后根遍历(Post Order)</h4><p>若二叉树为空，则退出，否则进行下面操作</p><ul><li>后根遍历左子树</li><li>后根遍历右子树</li><li>访问根节点</li><li>退出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        PostOrder(node.getLeftChild());  <span class="comment">//后根遍历左子树</span></span><br><span class="line">        PostOrder(node.getRightChild());  <span class="comment">//后根遍历右子树</span></span><br><span class="line">        System.out.println(node.getData());   <span class="comment">//访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层次遍历-Level-Traverse"><a href="#层次遍历-Level-Traverse" class="headerlink" title="层次遍历(Level Traverse)"></a>层次遍历(Level Traverse)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelTraverse</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    LinkedList&lt;BinaryTreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();  </span><br><span class="line">    queue.offer(root);  </span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;  </span><br><span class="line">        BinaryTreeNode node = queue.poll();  </span><br><span class="line">        System.out.print(node.getData()+<span class="string">"  "</span>);  </span><br><span class="line">        <span class="keyword">if</span> (node.getLeftChild() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            queue.offer(node.getLeftChild());  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (node.getRightChild() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            queue.offer(node.getRightChild());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>创建二叉树，一般有两种情况：初始化一个根节点或者初始化一棵空二叉树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode root;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getRoot</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h4><p>对于二叉树的清空，首先提供一个清空某个节点为根节点的子树的方法，即递归的删除每个节点；接着提供删除一个删除树的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清除某个子树的所有节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        clear(node.getLeftChild());</span><br><span class="line">        clear(node.getRightChild());</span><br><span class="line">        node = <span class="keyword">null</span>; <span class="comment">//删除节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空整个树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    clear(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断是否为空"><a href="#判断是否为空" class="headerlink" title="判断是否为空"></a>判断是否为空</h4><p>只需判断根节点是否存在即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断二叉树是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求最大深度-高度"><a href="#求最大深度-高度" class="headerlink" title="求最大深度(高度)"></a>求最大深度(高度)</h4><p>首先需要一种获取以某个节点为子树的高度方法，使用递归实现。如果一个节点为空，那么这个节点肯定是一颗空树，高度为0；如果不为空，则遍历地比较它的左右子树高度，高的一个为这颗子树的最大高度，然后加上自身的高度即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取二叉树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxDepth</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getMaxDepth(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取以某节点为子树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxDepth</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//递归结束，空子树高度为0</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//递归获取左子树高度</span></span><br><span class="line">        <span class="keyword">int</span> l = getMaxDepth(node.getLeftChild());</span><br><span class="line">        <span class="comment">//递归获取右子树高度</span></span><br><span class="line">        <span class="keyword">int</span> r = getMaxDepth(node.getRightChild());</span><br><span class="line">        <span class="comment">//高度应该算更高的一边，（+1是因为要算上自身这一层）</span></span><br><span class="line">        <span class="keyword">return</span> l &gt; r ? (l+<span class="number">1</span>) : (r+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求最小深度"><a href="#求最小深度" class="headerlink" title="求最小深度"></a>求最小深度</h4><p>根节点到最近叶子结点的距离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinDepth</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getMinDepth (root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinDepth</span><span class="params">(BinaryTreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> == node) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> == node.getLeftChild()) &#123;</span><br><span class="line">        <span class="keyword">return</span> getMinDepth(node.getRightChild()) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> == root.getRightChild()) &#123;</span><br><span class="line">        <span class="keyword">return</span> getMinDepth(node.getLeftChild()) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//递归获取左子树高度</span></span><br><span class="line">    <span class="keyword">int</span> l = getMaxDepth(node.getLeftChild());</span><br><span class="line">    <span class="comment">//递归获取右子树高度</span></span><br><span class="line">    <span class="keyword">int</span> r = getMaxDepth(node.getRightChild());</span><br><span class="line">    <span class="comment">//高度应该算更低的一边，（+1是因为要算上自身这一层）</span></span><br><span class="line">    <span class="keyword">return</span> l &lt; r ? (l+<span class="number">1</span>) : (r+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求所有节点数"><a href="#求所有节点数" class="headerlink" title="求所有节点数"></a>求所有节点数</h4><p>获取二叉树节点数，需要获取以某个节点为根的子树的节点数实现。如果节点为空，则个数肯定为0；如果不为空，则算上这个节点之后，继续递归计算所有子树的节点数，全部相加即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//如果节点为空，则返回节点数为0</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//计算本节点 所以要+1</span></span><br><span class="line">        <span class="comment">//递归获取左子树节点数和右子树节点数，最终相加</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + size(node.getLeftChild ()) + size(node.getRightChild ());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求叶子节点个数"><a href="#求叶子节点个数" class="headerlink" title="求叶子节点个数"></a>求叶子节点个数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNumOfChildNode</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> == root) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> == root.getLeftChild() &amp;&amp; <span class="keyword">null</span> == root.RightChild()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getNumOfChildNode(root.getLeftChild())+getNumOfChildNode(root.getLeftChild());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求第k层节点数"><a href="#求第k层节点数" class="headerlink" title="求第k层节点数"></a>求第k层节点数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNumOfLevelNode</span><span class="params">(BinaryTreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> == root || k &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> == k) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> numleft = getNumOfLevelNode(root.getLeftChild(), k - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> numright = getNumOfLevelNode(root.RightChild,k - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> numleft + numright;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回某节点的父亲节点"><a href="#返回某节点的父亲节点" class="headerlink" title="返回某节点的父亲节点"></a>返回某节点的父亲节点</h4><p>首先，同样需要通过一种方法来获取某个节点在某个子树中的父节点，这里使用递归实现，接着通过这种方法获取这个节点在二叉树中的父节点。</p><p>事实上，以现有的这种二叉树的形式，我们并没有办法直接获取一个节点的父节点， 这里只能通过从根节点遍历来比较获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node节点在subTree子树中的父节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getParent</span><span class="params">(BinaryTreeNode subTree, BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果是空子树，则没有父节点</span></span><br><span class="line">    <span class="keyword">if</span>(subTree == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果子树的根节点的左右孩子之一是待查节点，则返回子树的根节点</span></span><br><span class="line">    <span class="keyword">if</span>(subTree.getLeftChild () == node || subTree.getRightChild () == node)&#123;</span><br><span class="line">        <span class="keyword">return</span> subTree;   </span><br><span class="line">    &#125;</span><br><span class="line">    BinaryTreeNode parent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//递归左右子树</span></span><br><span class="line">    <span class="keyword">if</span>(getParent(subTree.getLeftChild (), node) != <span class="keyword">null</span>)&#123;</span><br><span class="line">        parent = getParent(subTree.getLeftChild (), node);</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getParent(subTree.getRightChild (), node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找node节点在二叉树中的父节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getParent</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (root == <span class="keyword">null</span> || root == node) ? <span class="keyword">null</span> : getParent(root, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">findNode</span><span class="params">(BinaryTreeNode root, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(root.getData() == x)&#123;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//递归搜索左子树</span></span><br><span class="line">BinaryTreeNode leftNode = findNode(root.getLeftChild(), x);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> != leftNode)</span><br><span class="line"><span class="keyword">return</span> leftNode;</span><br><span class="line">    <span class="comment">//递归搜索右子树</span></span><br><span class="line">BinaryTreeNode rightNode = findNode(root.getRightChild(), x);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> != rightNode)</span><br><span class="line"><span class="keyword">return</span> rightNode;</span><br><span class="line">    <span class="comment">//没找到，返回null</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断两棵二叉树是否相等"><a href="#判断两棵二叉树是否相等" class="headerlink" title="判断两棵二叉树是否相等"></a>判断两棵二叉树是否相等</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEquals</span><span class="params">(BinaryTreeNode root1, BinaryTreeNode root2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//当前节点均为空或者相等，返回true</span></span><br><span class="line">    <span class="keyword">if</span>((root1 == <span class="keyword">null</span> &amp;&amp; root2 == <span class="keyword">null</span>) ||root1.getData() == root2.getData())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//递归判断所有左右子树，均相等返回true</span></span><br><span class="line">    <span class="keyword">if</span>(isEquals(root1.getLeftChild(), root2.getLeftChild()) </span><br><span class="line">       &amp;&amp; isEquals(root1.getRightChild(), root2.getRightChild()))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//否则返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断两棵二叉树是否镜像"><a href="#判断两棵二叉树是否镜像" class="headerlink" title="判断两棵二叉树是否镜像"></a>判断两棵二叉树是否镜像</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isMirrorBTree</span><span class="params">(BinaryTreeNode root1, BinaryTreeNode root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> == root1 &amp;&amp; <span class="keyword">null</span> == root2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">null</span> == root1 || <span class="keyword">null</span> == root2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root1.getData() != root2.getData()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此处注意相反比较</span></span><br><span class="line">    <span class="keyword">return</span> isMirrorBTree(root1.getLeftChild(),root2.getRightChild())</span><br><span class="line">        &amp;&amp; isMirrorBTree(root1.getRightChild(),root2.getLeftChild());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断是否为完全二叉树"><a href="#判断是否为完全二叉树" class="headerlink" title="判断是否为完全二叉树"></a>判断是否为完全二叉树</h4><p>我们可以根据题意做题即可，我们可以采用分层遍历的方式，在判断一个具体的节点的时候，我们可以有如下的判断依据:</p><ol><li>如果这个节点的左子树为null，右子树不为null，则一定不是完全二叉树</li><li>如果这个节点的左右子树均为null，或者这个节点的左子树不为null但是右子树为null，则当前层或者下一层不能再出现含有左右子树的节点</li><li>如果当前节点的左右子树均不为null，则观察下一个节点</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCompleteBTree</span><span class="params">(BinaryTreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> hasLeaf = <span class="keyword">false</span>;</span><br><span class="line">    List&lt;BinaryTreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        BinaryTreeNode tmp = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (tmp.getLeftChild() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp.getRightChild() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//情况1，左子树为null，右子树不为null，则一定不是完全二叉树</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tmp.getRightChild() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//情况2，左右子树均为null</span></span><br><span class="line">                <span class="comment">//则当前层或者下一层不能再出现含有左右子树的节点</span></span><br><span class="line">                hasLeaf = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasLeaf) &#123;</span><br><span class="line">                <span class="comment">//出现了含有左子树的节点，直接返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tmp.getRightChild() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//情况2，左子树不为null，右子树为null</span></span><br><span class="line">                <span class="comment">//则当前层或者下一层不能再出现含有左右子树的节点</span></span><br><span class="line">                hasLeaf = <span class="keyword">true</span>;</span><br><span class="line">                queue.add(tmp.getLeftChild());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tmp.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//情况3，左右子树均不为null，则观察下一个节点</span></span><br><span class="line">                queue.add(tmp.getLeftChild());</span><br><span class="line">                queue.add(tmp.getRightChild());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="翻转二叉树-镜像二叉树"><a href="#翻转二叉树-镜像二叉树" class="headerlink" title="翻转二叉树(镜像二叉树)"></a>翻转二叉树(镜像二叉树)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">invertTree</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归反转左右子树</span></span><br><span class="line">    BinaryTreeNode temp = root.getLeftChild();</span><br><span class="line">    root.getLeftChild() = invertTree(root.getRightChild());</span><br><span class="line">    root.getRightChild() = invertTree(temp);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断是否是二叉查找树"><a href="#判断是否是二叉查找树" class="headerlink" title="判断是否是二叉查找树"></a>判断是否是二叉查找树</h4><p>一棵BST定义为：</p><ul><li>节点的左子树中的值要严格小于该节点的值</li><li>节点的右子树中的值要严格大于该节点的值</li><li>左右子树也必须是二叉查找树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根节点的值data必然在(minVal,maxVal)这个范围内</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(BinaryTreeNode root, <span class="keyword">long</span> minVal, <span class="keyword">long</span> maxVal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.getData() &gt;= maxVal || root.getData() &lt;= minVal) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.getLeftChild(), minVal, root.data)</span><br><span class="line">        &amp;&amp; isValidBST(root.getRightChild(), root.data, maxVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断是否是平衡二叉树"><a href="#判断是否是平衡二叉树" class="headerlink" title="判断是否是平衡二叉树"></a>判断是否是平衡二叉树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalancedTree</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左右子树高度绝对值大于1，返回false</span></span><br><span class="line">    <span class="keyword">if</span>(Math.abs(getMaxDepth(root.getLeftChild())-getMaxDepth(root.getRightChild()))&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//递归检查左右子树</span></span><br><span class="line">        <span class="keyword">return</span> IsBalancedTree(root.getLeftChild()) </span><br><span class="line">            &amp;&amp; IsBalancedTree(root.getRightChild());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求高度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxDepth</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = getMaxDepth(root.getLeftChild());</span><br><span class="line">    <span class="keyword">int</span> right = getMaxDepth(root.getRightChild());</span><br><span class="line">    <span class="keyword">return</span> left &gt; right ? left + <span class="number">1</span> : right + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二叉树的定义&quot;&gt;&lt;a href=&quot;#二叉树的定义&quot; class=&quot;headerlink&quot; title=&quot;二叉树的定义&quot;&gt;&lt;/a&gt;二叉树的定义&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;二叉树（Binary Tree）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;二叉树（Binary Tree）是有限个节点的集合，这个集合可以是空集，也可以是一个根节点和两颗不相交的子二叉树组成的集合，其中一颗树叫根的左子树，另一颗树叫右子树。所以二叉树是一个递归地概念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>图算法</title>
    <link href="http://yoursite.com/2020/05/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/"/>
    <id>http://yoursite.com/2020/05/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2020-06-08T00:57:51.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的定义和常用术语"><a href="#图的定义和常用术语" class="headerlink" title="图的定义和常用术语"></a>图的定义和常用术语</h2><p>图是一系列顶点（结点）和描述顶点之间的关系边（弧）组成。图是数据元素的集合，这些数据元素相互连接形成网络。其形式化定义为：G=（V，E）。其中，G表示图，V是顶点的集合，E是边或弧的集合。并且E可以表示为：E=（Vi，Vj），表示顶点Vi和Vj之间有边或弧相连。</p><a id="more"></a><ul><li><p>顶点集：图中具有相同特性的数据元素的集合；</p></li><li><p>边（弧）：边是一对顶点间的路径，通常带箭头的边称为弧；</p></li><li><p>度：在无向图中顶点的度是指连接那个顶点的边的数目。在有向图中，每个顶点有两种类型的度（入度、出度）；</p></li><li><p>入度：指向那个顶点的边的数目；</p></li><li><p>出度：由那个顶点出发的边的数目；</p></li><li><p>权：有些图的边或弧附带有一些数据信息，这些数据信息称为边或弧的权。在实际问题中，权可以表示某种含义，比如在一个地方的交通图上，边上的权值表示该条线路的长度。</p></li><li><p>有向图：在一个图中，如果任意两顶点构成的偶对（如果存在）是有序的，那么称该图为有向图；</p></li><li><p>无向图：在一个图中，如果任意两顶点构成的偶对（如果存在）是无序的，那么称该图为无向图；</p></li><li><p>有向完全图：在一个有向图中，如果任意两个顶点之间都是有弧相连，则称该图是完全有向图；</p></li><li><p>有向完全图：在一个无向图中，如果任意两个顶点之间都是有边相连，则称该图是完全无向图；</p></li><li><p>稀疏图：有很少条边或弧的图；</p></li><li><p>稠密图：有很多条边或弧的图。</p></li></ul><h2 id="图的实现"><a href="#图的实现" class="headerlink" title="图的实现"></a>图的实现</h2><p>一个图的信息主要包括两部分：图中顶点的信息以及描述顶点之间的关系——边或弧的信息。</p><p>邻接矩阵和邻接表是图的两种最通用的存储结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGraph</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">getNumOfVertex</span><span class="params">()</span></span>;<span class="comment">//获取顶点的个数</span></span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">insertVex</span><span class="params">(E v)</span></span>;<span class="comment">//插入顶点</span></span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">deleteVex</span><span class="params">(E v)</span></span>;<span class="comment">//删除顶点</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">indexOfVex</span><span class="params">(E v)</span></span>;<span class="comment">//定位顶点的位置</span></span><br><span class="line"> <span class="function">E <span class="title">valueOfVex</span><span class="params">(<span class="keyword">int</span> v)</span></span>;<span class="comment">// 定位指定位置的顶点</span></span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2,<span class="keyword">int</span> weight)</span></span>;<span class="comment">//插入边</span></span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">deleteEdge</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>;<span class="comment">//删除边</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">getEdge</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>;<span class="comment">//查找边</span></span><br><span class="line"> <span class="function">String <span class="title">depthFirstSearch</span><span class="params">(<span class="keyword">int</span> v )</span></span>;<span class="comment">//深度优先搜索遍历</span></span><br><span class="line"> <span class="function">String <span class="title">breadFirstSearch</span><span class="params">(<span class="keyword">int</span> v )</span></span>;<span class="comment">//广度优先搜索遍历</span></span><br><span class="line"> <span class="keyword">int</span>[] dijkstra(<span class="keyword">int</span> v);<span class="comment">//最短路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>邻接矩阵是用两个数组来表示图：</p><ul><li>一个数组是一维数组，存储图中的顶点信息；</li><li>一个数组是二维数组，即矩阵，存储顶点之间相邻的信息，也就是边或弧的信息。</li></ul><p>如果图中有n个顶点，就需要n×n的二维数组来表示图。</p><p>关于权值的说明：</p><ul><li>如果图的边没有权值，用0表示顶点之间无边，用1表示顶点之间有边。</li><li>如果图的弧有权值，用无穷大表示顶点之间无边，用权值表示顶点之间有边，同一点之间的权值为0。</li></ul><blockquote><p>  注意：如果图为稀疏图的话，在用邻接矩阵表示图的时候，由于在表示边的时候会导致变成一个系数矩阵，导致很多的浪费。所以，<strong>应在图为稠密图的时候使用邻接矩阵实现图</strong>。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf003skpvlj30d005ejse.jpg" alt="邻接矩阵"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphAdjMatrix</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">IGraph</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> E[] vexs;<span class="comment">// 存储图的顶点的一维数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] edges;<span class="comment">// 存储图的边的二维数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> numOfVexs;<span class="comment">// 顶点的实际数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxNumOfVexs;<span class="comment">// 顶点的最大数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] visited;<span class="comment">// 判断顶点是否被访问过</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GraphAdjMatrix</span><span class="params">(<span class="keyword">int</span> maxNumOfVexs, Class&lt;E&gt; type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.maxNumOfVexs = maxNumOfVexs;</span><br><span class="line">edges = <span class="keyword">new</span> <span class="keyword">int</span>[maxNumOfVexs][maxNumOfVexs];</span><br><span class="line">vexs = (E[]) Array.newInstance(type, maxNumOfVexs);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 得到顶点的数目</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfVertex</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> numOfVexs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入顶点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insertVex</span><span class="params">(E v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (numOfVexs &gt;= maxNumOfVexs)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">vexs[numOfVexs++] = v;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除顶点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteVex</span><span class="params">(E v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numOfVexs; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (vexs[i].equals(v)) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; numOfVexs - <span class="number">1</span>; j++) &#123;</span><br><span class="line">vexs[j] = vexs[j + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">vexs[numOfVexs - <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = i; col &lt; numOfVexs - <span class="number">1</span>; col++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; numOfVexs; row++) &#123;</span><br><span class="line">edges[col][row] = edges[col + <span class="number">1</span>][row];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = i; row &lt; numOfVexs - <span class="number">1</span>; row++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; numOfVexs; col++) &#123;</span><br><span class="line">edges[col][row] = edges[col][row + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">numOfVexs--;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定位顶点的位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOfVex</span><span class="params">(E v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numOfVexs; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (vexs[i].equals(v)) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定位指定位置的顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">valueOfVex</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span> ||v &gt;= numOfVexs )</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> vexs[v];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 插入边</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (v1 &lt; <span class="number">0</span> || v2 &lt; <span class="number">0</span> || v1 &gt;= numOfVexs || v2 &gt;= numOfVexs)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">edges[v1][v2] = weight;</span><br><span class="line">edges[v2][v1] = weight;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除边</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteEdge</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (v1 &lt; <span class="number">0</span> || v2 &lt; <span class="number">0</span> || v1 &gt;= numOfVexs || v2 &gt;= numOfVexs)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">edges[v1][v2] = <span class="number">0</span>;</span><br><span class="line">edges[v2][v1] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找边</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEdge</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (v1 &lt; <span class="number">0</span> || v2 &lt; <span class="number">0</span> || v1 &gt;= numOfVexs || v2 &gt;= numOfVexs)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line"><span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 深度优先搜索遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">depthFirstSearch</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 广度优先搜索遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">breadFirstSearch</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 实现Dijkstra算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dijkstra(<span class="keyword">int</span> v) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>前面的邻接矩阵方法实际上是图的一种静态存储方法。建立这种存储结构时需要预先知道图中顶点的个数。如果图结构本身需要在解决问题的过程中动态地产生，则每增加或者删除一个顶点都需要改变邻接矩阵的大小，显然这样做的效率很低。除此之外，邻接矩阵所占用的存储单元数目至于图中的顶点的个数有关，而与边或弧的数目无关，若图是一个稀疏图的话，必然造成存储空间的浪费。邻接表很好地解决了这些问题。</p><p>邻接表的存储方式是一种顺序存储与链式存储相结合的存储方式，</p><ul><li>顺序存储部分用来保存图中的顶点信息，</li><li>链式存储部分用来保存图中边或弧的信息。</li></ul><p>具体的做法是，使用一个一维数组保存图中顶点的信息，数组中每个数组元素包含两个域。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf003syyfsj30cy04lwfn.jpg" alt="邻接表"></p><p>邻接表是一个数组，数组的每个元素包含顶点信息和单链表的头指针两部分。而单链表的结构分成与顶点相邻的元素信息、边的信息和下一个与顶点相邻的元素指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphAdjList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">IGraph</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 链表中的节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ENode</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> adjvex; <span class="comment">// 邻接顶点序号</span></span><br><span class="line"><span class="keyword">int</span> weight;<span class="comment">// 存储边或弧相关的信息，如权值</span></span><br><span class="line">ENode nextadj; <span class="comment">// 下一个邻接表结点</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ENode</span><span class="params">(<span class="keyword">int</span> adjvex, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.adjvex = adjvex;</span><br><span class="line"><span class="keyword">this</span>.weight = weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数组中的节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VNode</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">E data; <span class="comment">// 顶点信息</span></span><br><span class="line">ENode firstadj; <span class="comment">// //邻接表的第1个结点</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> VNode&lt;E&gt;[] vexs; <span class="comment">// 顶点数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> numOfVexs;<span class="comment">// 顶点的实际数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxNumOfVexs;<span class="comment">// 顶点的最大数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] visited;<span class="comment">// 判断顶点是否被访问过</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GraphAdjList</span><span class="params">(<span class="keyword">int</span> maxNumOfVexs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.maxNumOfVexs = maxNumOfVexs;</span><br><span class="line">vexs = (VNode&lt;E&gt;[]) Array.newInstance(VNode<span class="class">.<span class="keyword">class</span>, <span class="title">maxNumOfVexs</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 得到顶点的数目</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfVertex</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> numOfVexs;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 插入顶点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insertVex</span><span class="params">(E v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (numOfVexs &gt;= maxNumOfVexs)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">VNode&lt;E&gt; vex = <span class="keyword">new</span> VNode&lt;E&gt;();</span><br><span class="line">vex.data = v;</span><br><span class="line">vexs[numOfVexs++] = vex;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 删除顶点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteVex</span><span class="params">(E v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numOfVexs; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (vexs[i].data.equals(v)) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; numOfVexs - <span class="number">1</span>; j++) &#123;</span><br><span class="line">vexs[j] = vexs[j + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">vexs[numOfVexs - <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">numOfVexs--;</span><br><span class="line">ENode current;</span><br><span class="line">ENode previous;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numOfVexs; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (vexs[j].firstadj == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (vexs[j].firstadj.adjvex == i) &#123;</span><br><span class="line">vexs[j].firstadj = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">current = vexs[j].firstadj;</span><br><span class="line"><span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">previous = current;</span><br><span class="line">current = current.nextadj;</span><br><span class="line"><span class="keyword">if</span> (current != <span class="keyword">null</span> &amp;&amp; current.adjvex == i) &#123;</span><br><span class="line">previous.nextadj = current.nextadj;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numOfVexs; j++) &#123;</span><br><span class="line">current = vexs[j].firstadj;</span><br><span class="line"><span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (current.adjvex &gt; i)</span><br><span class="line">current.adjvex--;</span><br><span class="line">current = current.nextadj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 定位顶点的位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOfVex</span><span class="params">(E v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numOfVexs; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (vexs[i].data.equals(v)) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 定位指定位置的顶点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">valueOfVex</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= numOfVexs)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span> vexs[v].data;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 插入边</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (v1 &lt; <span class="number">0</span> || v2 &lt; <span class="number">0</span> || v1 &gt;= numOfVexs || v2 &gt;= numOfVexs)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">ENode vex1 = <span class="keyword">new</span> ENode(v2, weight);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 索引为index1的顶点没有邻接顶点</span></span><br><span class="line"><span class="keyword">if</span> (vexs[v1].firstadj == <span class="keyword">null</span>) &#123;</span><br><span class="line">vexs[v1].firstadj = vex1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 索引为index1的顶点有邻接顶点</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">vex1.nextadj = vexs[v1].firstadj;</span><br><span class="line">vexs[v1].firstadj = vex1;</span><br><span class="line">&#125;</span><br><span class="line">ENode vex2 = <span class="keyword">new</span> ENode(v1, weight);</span><br><span class="line"><span class="comment">// 索引为index2的顶点没有邻接顶点</span></span><br><span class="line"><span class="keyword">if</span> (vexs[v2].firstadj == <span class="keyword">null</span>) &#123;</span><br><span class="line">vexs[v2].firstadj = vex2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 索引为index1的顶点有邻接顶点</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">vex2.nextadj = vexs[v2].firstadj;</span><br><span class="line">vexs[v2].firstadj = vex2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 删除边</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteEdge</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (v1 &lt; <span class="number">0</span> || v2 &lt; <span class="number">0</span> || v1 &gt;= numOfVexs || v2 &gt;= numOfVexs)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line"><span class="comment">// 删除索引为index1的顶点与索引为index2的顶点之间的边</span></span><br><span class="line">ENode current = vexs[v1].firstadj;</span><br><span class="line">ENode previous = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (current != <span class="keyword">null</span> &amp;&amp; current.adjvex != v2) &#123;</span><br><span class="line">previous = current;</span><br><span class="line">current = current.nextadj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (current != <span class="keyword">null</span>)</span><br><span class="line">previous.nextadj = current.nextadj;</span><br><span class="line"><span class="comment">// 删除索引为index2的顶点与索引为index1的顶点之间的边</span></span><br><span class="line">current = vexs[v2].firstadj;</span><br><span class="line"><span class="keyword">while</span> (current != <span class="keyword">null</span> &amp;&amp; current.adjvex != v1) &#123;</span><br><span class="line">previous = current;</span><br><span class="line">current = current.nextadj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (current != <span class="keyword">null</span>)</span><br><span class="line">previous.nextadj = current.nextadj;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 查找边</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEdge</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (v1 &lt; <span class="number">0</span> || v2 &lt; <span class="number">0</span> || v1 &gt;= numOfVexs || v2 &gt;= numOfVexs)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">ENode current = vexs[v1].firstadj;</span><br><span class="line"><span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (current.adjvex == v2) &#123;</span><br><span class="line"><span class="keyword">return</span> current.weight;</span><br><span class="line">&#125;</span><br><span class="line">current = current.nextadj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 深度优先搜索遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">depthFirstSearch</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 广度优先搜索遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">breadFirstSearch</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 实现Dijkstra算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dijkstra(<span class="keyword">int</span> v) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>图的遍历是指从图中的任一顶点出发，对图中的所有顶点访问一次并且只访问一次。图的遍历是图的一种基本操作，图中的许多其他操作也都是建立在遍历的基础之上。在图中，没有特殊的顶点被指定为起始顶点，图的遍历可以从任何顶点开始。</p><h3 id="深度优先搜索算法"><a href="#深度优先搜索算法" class="headerlink" title="深度优先搜索算法"></a>深度优先搜索算法</h3><p><strong>算法的思想</strong></p><p>从图中的某一个顶点x出发，访问x，然后遍历任何一个与x相邻的未被访问的顶点y，再遍历任何一个与y相邻的未被访问的顶点z……依次类推，直到到达一个所有邻接点都被访问的顶点为止；然后，依次回退到尚有邻接点未被访问过的顶点，重复上述过程，直到图中的全部顶点都被访问过为止。</p><p><strong>算法实现的思想</strong></p><p>深度优先遍历背后基于堆栈，有两种方式：</p><ul><li>第一种是在程序中<strong>显示构造堆栈</strong>，利用压栈出栈操作实现；</li><li>第二种是利用<strong>递归函数调用</strong>，基于递归程序栈实现。</li></ul><p>本文介绍第一种方式：</p><ol><li>访问起始顶点，并将其压入栈中；</li><li>从栈中弹出最上面的顶点，将与其相邻的未被访问的顶点压入栈中；</li><li>重复第二步，直至栈为空栈。</li></ol><p>未被访问的顶点怎么识别呢？利用visited数组来进行标记。</p><p><strong>算法的实现</strong></p><p>基于邻接矩阵的算法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">depthFirstSearch</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= numOfVexs)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[numOfVexs];</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    stack.push(v);</span><br><span class="line">    visited[v] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        v = stack.pop();</span><br><span class="line">        sb.append(vexs[v] + <span class="string">","</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = numOfVexs - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v][i] != <span class="number">0</span> &amp;&amp; edges[v][i] != Integer.MAX_VALUE &amp;&amp; !visited[i]) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">                visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.length() &gt; <span class="number">0</span> ? sb.substring(<span class="number">0</span>, sb.length() - <span class="number">1</span>) : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于邻接表的算法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">depthFirstSearch</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= numOfVexs)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[numOfVexs];</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    stack.push(v);</span><br><span class="line">    visited[v] = <span class="keyword">true</span>;</span><br><span class="line">    ENode current;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        v = stack.pop();</span><br><span class="line">        sb.append(vexs[v].data + <span class="string">","</span>);</span><br><span class="line">        current = vexs[v].firstadj;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[current.adjvex]) &#123;</span><br><span class="line">                stack.push(current.adjvex);</span><br><span class="line">                visited[current.adjvex] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.nextadj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.length() &gt; <span class="number">0</span> ? sb.substring(<span class="number">0</span>, sb.length() - <span class="number">1</span>) : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="广度优先搜索算法"><a href="#广度优先搜索算法" class="headerlink" title="广度优先搜索算法"></a>广度优先搜索算法</h3><p><strong>算法的思想</strong></p><p>从图中的某一个顶点x出发，访问x，然后访问与x所相邻的所有未被访问的顶点x1、x2……xn，接着再依次访问与x1、x2……xn相邻的未被访问的所有顶点。依次类推，直至图中的每个顶点都被访问。</p><p><strong>算法实现的思想</strong></p><p>广度优先遍历背后基于<strong>队列</strong>，下面介绍一下具体实现的方法：</p><ol><li>访问起始顶点，并将插入队列；</li><li>从队列中删除队头顶点，将与其相邻的未被访问的顶点插入队列中；</li><li>重复第二步，直至队列为空。</li></ol><p>未被访问的顶点怎么识别呢？利用visited数组来进行标记。</p><p><strong>算法的实现</strong></p><p>基于邻接矩阵的算法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">breadFirstSearch</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= numOfVexs)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[numOfVexs];</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    queue.offer(v);</span><br><span class="line">    visited[v] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        v = queue.poll();</span><br><span class="line">        sb.append(vexs[v] + <span class="string">","</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numOfVexs; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v][i] != <span class="number">0</span> &amp;&amp; edges[v][i] != Integer.MAX_VALUE &amp;&amp; !visited[i]) &#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">                visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.length() &gt; <span class="number">0</span> ? sb.substring(<span class="number">0</span>, sb.length() - <span class="number">1</span>) : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于邻接表的算法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">breadFirstSearch</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= numOfVexs)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[numOfVexs];</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    queue.offer(v);</span><br><span class="line">    visited[v] = <span class="keyword">true</span>;</span><br><span class="line">    ENode current;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        v = queue.poll();</span><br><span class="line">        sb.append(vexs[v].data + <span class="string">","</span>);</span><br><span class="line">        current = vexs[v].firstadj;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[current.adjvex]) &#123;</span><br><span class="line">                queue.offer(current.adjvex);</span><br><span class="line">                visited[current.adjvex] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.nextadj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.length() &gt; <span class="number">0</span> ? sb.substring(<span class="number">0</span>, sb.length() - <span class="number">1</span>) : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>最短路径的问题是比较典型的应用问题。在图中，确定了起始点和终点之后，一般情况下都可以有很多条路径来连接两者。而边或弧的权值最小的那一条路径就称为两点之间的最短路径，路径上的第一个顶点为源点，最后一个顶点为终点。</p><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p><strong>算法特点</strong></p><p>Dijkstra算法使用了<strong>广度优先搜索</strong>解决赋权<strong>有向图</strong>或者<strong>无向图</strong>的<strong>单源最短路径</strong>问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。</p><p>该算法的时间复杂度是n^2^，可以使用堆优化。</p><p>但是要注意一点，Dijkstra算法只能适用于权值为正的情况下；如果权值存在负数，则不能使用。</p><p><strong>算法思想</strong></p><ol><li>设置两个顶点集S和T，集合S中存放已经找到最短路径的顶点，集合T中存放着当前还未找到最短路径的顶点；</li><li>初始状态下，集合S中只包含源点V1，T中为除了源点之外的其余顶点，此时源点到各顶点的最短路径为两个顶点所连的边上的权值，如果源点V1到该顶点没有边，则最小路径为无穷大；</li><li>从集合T中选取到源点V1的路径长度最短的顶点Vi加入到集合S中；</li><li>修改源点V1到集合T中剩余顶点Vj的最短路径长度。新的最短路径长度值为Vj原来的最短路径长度值与顶点Vi的最短路径长度加上Vi到Vj的路径长度值中的较小者；</li><li>不断重复步骤3、4，直至集合T的顶点全部加入到集合S中。</li></ol><p>由此分析下来，我们可以得到以下几点：</p><ul><li><p>需要设立两个数组：</p><p>一个数组为diatance，用于存放个顶点距离源点的距离；</p><p>另一个数组为st，用于判断顶点是在哪一个集合内（true为在S集合，false为在T集合内）。</p></li><li><p>Dijkstra算法的精髓：</p><p>每次循环都将T集合内距离源点最近的那个点加入到S集合中，且加入的那个点距离源点的距离由“最短距离估计值”转变成“最短距离准确值”；</p><p>每次循环添加一个点到S集合中后，会导致与加入的那个点相邻的顶点可能会发生距离的更新，也就是“最短距离估计值”的更新。更新方法是取原本的“最短距离估计值”与新加入的那个点的“最短距离确定值”+新加入的那个点与其邻点的距离的较小者。</p><p>“最短距离估计值”的真正内涵：其实可以把S集合看成一个黑箱子，“最短距离估计值”就是该顶点经过黑箱子里的各个点到源点的最短距离，但不能保证该顶点是否可以通过黑箱子外（T集合）的顶点绕路达到更短。只有每次循环中“最短距离估计值”中的最小值，才能确定为“最短距离确定值”加入到集合S。</p></li></ul><p><strong>算法实现</strong></p><p>基于邻接矩阵的代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dijkstra(<span class="keyword">int</span> v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= numOfVexs)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">    <span class="keyword">boolean</span>[] st = <span class="keyword">new</span> <span class="keyword">boolean</span>[numOfVexs];<span class="comment">// 默认初始为false</span></span><br><span class="line">    <span class="keyword">int</span>[] distance = <span class="keyword">new</span> <span class="keyword">int</span>[numOfVexs];<span class="comment">// 存放源点到其他点的矩离</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numOfVexs; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; numOfVexs; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                edges[i][j] = Integer.MAX_VALUE;</span><br><span class="line">                edges[j][i] = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numOfVexs; i++) &#123;</span><br><span class="line">        distance[i] = edges[v][i];</span><br><span class="line">    &#125;</span><br><span class="line">    st[v] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 处理从源点到其余顶点的最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numOfVexs; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 比较从源点到其余顶点的路径长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numOfVexs; ++j) &#123;</span><br><span class="line">            <span class="comment">// 从源点到j顶点的最短路径还没有找到</span></span><br><span class="line">            <span class="keyword">if</span> (st[j]==<span class="keyword">false</span>) &#123;</span><br><span class="line">                <span class="comment">// 从源点到j顶点的路径长度最小</span></span><br><span class="line">                <span class="keyword">if</span> (distance[j] &lt; min) &#123;</span><br><span class="line">                    index = j;</span><br><span class="line">                    min = distance[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到源点到索引为index顶点的最短路径长度</span></span><br><span class="line">        <span class="keyword">if</span>(index != -<span class="number">1</span>)&#123;</span><br><span class="line">            st[index] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新当前最短路径及距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; numOfVexs; w++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (st[w] == <span class="keyword">false</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (edges[index][w] != Integer.MAX_VALUE</span><br><span class="line">                    &amp;&amp; (min + edges[index][w] &lt; distance[w]))</span><br><span class="line">                    distance[w] = min + edges[index][w];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于邻接表的代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dijkstra(<span class="keyword">int</span> v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= numOfVexs)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">    <span class="keyword">boolean</span>[] st = <span class="keyword">new</span> <span class="keyword">boolean</span>[numOfVexs];<span class="comment">// 默认初始为false</span></span><br><span class="line">    <span class="keyword">int</span>[] distance = <span class="keyword">new</span> <span class="keyword">int</span>[numOfVexs];<span class="comment">// 存放源点到其他点的距离</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numOfVexs; i++) &#123;</span><br><span class="line">        distance[i] = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    ENode current;</span><br><span class="line">    current = vexs[v].firstadj;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">        distance[current.adjvex] = current.weight;</span><br><span class="line">        current = current.nextadj;</span><br><span class="line">    &#125;</span><br><span class="line">    distance[v] = <span class="number">0</span>;</span><br><span class="line">    st[v] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 处理从源点到其余顶点的最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numOfVexs; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 比较从源点到其余顶点的路径长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numOfVexs; j++) &#123;</span><br><span class="line">            <span class="comment">// 从源点到j顶点的最短路径还没有找到</span></span><br><span class="line">            <span class="keyword">if</span> (st[j] == <span class="keyword">false</span>) &#123;</span><br><span class="line">                <span class="comment">// 从源点到j顶点的路径长度最小</span></span><br><span class="line">                <span class="keyword">if</span> (distance[j] &lt; min) &#123;</span><br><span class="line">                    index = j;</span><br><span class="line">                    min = distance[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到源点到索引为index顶点的最短路径长度</span></span><br><span class="line">        <span class="keyword">if</span> (index != -<span class="number">1</span>)&#123;</span><br><span class="line">            st[index] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新当前最短路径及距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; numOfVexs; w++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (st[w] == <span class="keyword">false</span>) &#123;</span><br><span class="line">                current = vexs[w].firstadj;</span><br><span class="line">                <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current.adjvex == w)&#123;</span><br><span class="line">                        <span class="keyword">if</span> (min + current.weight &lt; distance[w]) &#123;</span><br><span class="line">                            distance[w] = min + current.weight;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;  </span><br><span class="line">                    current = current.nextadj;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;图的定义和常用术语&quot;&gt;&lt;a href=&quot;#图的定义和常用术语&quot; class=&quot;headerlink&quot; title=&quot;图的定义和常用术语&quot;&gt;&lt;/a&gt;图的定义和常用术语&lt;/h2&gt;&lt;p&gt;图是一系列顶点（结点）和描述顶点之间的关系边（弧）组成。图是数据元素的集合，这些数据元素相互连接形成网络。其形式化定义为：G=（V，E）。其中，G表示图，V是顶点的集合，E是边或弧的集合。并且E可以表示为：E=（Vi，Vj），表示顶点Vi和Vj之间有边或弧相连。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>基本数据结构</title>
    <link href="http://yoursite.com/2020/05/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/05/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2020-06-08T00:57:51.991Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  常用的数据结构可根据数据访问的特点分为<strong>线性结构</strong>和<strong>非线性结构</strong>。</p><p>  线性结构包括常见的链表、栈、队列等，非线性结构包括树、图等。</p></blockquote><a id="more"></a><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组可以说是最基本最常见的数据结构。数组一般用来存储相同类型的数据，可通过数组名和下标进行数据的访问和更新。数组中元素的存储是按照先后顺序进行的，同时在内存中也是按照这个顺序进行连续存放。<strong>数组相邻元素之间的内存地址的间隔一般就是数组数据类型的大小</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5mn06k3sj30lt0h5gm7.jpg" alt="img"></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表相较于数组，除了数据域，还增加了指针域用于构建链式的存储数据。链表中每一个节点都包含此节点的数据和指向下一节点地址的指针。</p><p>由于是通过指针进行下一个数据元素的查找和访问，使得链表的自由度更高。这表现在对节点进行增加和删除时，只需要对上一节点的指针地址进行修改，而无需变动其它的节点。不过事物皆有两极，指针带来高自由度的同时，自然会牺牲数据查找的效率和多余空间的使用。</p><p>一般常见的是有头有尾的单链表，对指针域进行反向链接，还可以形成双向链表或者循环链表。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5mnu0dqgj30qx0e274u.jpg" alt="img"></p><p><strong>链表和数组对比</strong></p><p>链表和数组在实际的使用过程中需要根据自身的优劣势进行选择。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5mp6ri26j30fa09n3yg.jpg" alt="img"></p><h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>链表虽然通过增加指针域提升了自由度，但是却导致数据的查询效率恶化。特别是当链表长度很长的时候，对数据的查询还得从头依次查询，这样的效率会更低。跳表的产生就是为了解决链表过长的问题，<strong>通过增加链表的多级索引来加快原始链表的查询效率</strong>。这样的方式可以让查询的时间复杂度从O(n)提升至O(logn)。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5mqrxeagj30u00ceq3l.jpg" alt="img"></p><p>从上图可以看出，索引级的指针域除了指向下一个索引位置的指针，还有一个down指针指向低一级的链表位置，这样才能实现跳跃查询的目的。</p><blockquote><p>  跳表通过增加的多级索引能够实现高效的动态插入和删除，其效率和红黑树和平衡二叉树不相上下。目前redis和levelDB都有用到跳表。</p></blockquote><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种比较简单的数据结构，常用一句话描述其特性，<strong>后进先出</strong>。栈本身是一个线性表，但是在这个表中只有一个口允许数据的进出。</p><p>栈的常用操作包括入栈push和出栈pop，对应于数据的压入和压出。还有访问栈顶数据、判断栈是否为空和判断栈的大小等。由于栈后进先出的特性，常可以作为数据操作的临时容器，对数据的顺序进行调控，与其它数据结构相结合可获得许多灵活的处理。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5mtrk906g30hr0a20vb.gif" alt="img"></p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是栈的兄弟结构，与栈的后进先出相对应，队列是一种先进先出的数据结构。顾名思义，队列的数据存储是如同排队一般，先存入的数据先被压出。常与栈一同配合，可发挥最大的实力。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5munytxdg30hr0a2gpt.gif" alt="img"></p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树作为一种树状的数据结构，其数据节点之间的关系也如大树一样，将有限个节点根据不同层次关系进行排列，从而形成数据与数据之间的父子关系。常见的数的表示形式更接近“倒挂的树”，因为它将根朝上，叶朝下。</p><p>树的数据存储在结点中，每个结点有零个或者多个子结点。没有父结点的结点在最顶端，成为根节点；没有非根结点有且只有一个父节点；每个非根节点又可以分为多个不相交的子树。</p><p>这意味着树是具备层次关系的，父子关系清晰，家庭血缘关系明朗；这也是树与图之间最主要的区别。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5myyuj3rj30u00eidgm.jpg" alt="img"></p><p>别看树好像很高级，其实可看作是链表的高配版。树的实现就是对链表的指针域进行了扩充，增加了多个地址指向子结点。同时将“链表”竖起来，从而凸显了结点之间的层次关系，更便于分析和理解。</p><p>树可以衍生出许多的结构，若将指针域设置为双指针，那么即可形成最常见的二叉树，即每个结点最多有两个子树的树结构。二叉树根据结点的排列和数量还可进一度划分为完全二叉树、满二叉树、平衡二叉树、红黑树等。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5myyf1olj30u00bb74t.jpg" alt="img"></p><blockquote><p>  <strong>完全二叉树</strong>：除了最后一层结点，其它层的结点数都达到了最大值；同时最后一层的结点都是按照从左到右依次排布。</p></blockquote><blockquote><p>  <strong>满二叉树</strong>：除了最后一层，其它层的结点都有两个子结点。</p></blockquote><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>平衡二叉树又被称为AVL树，它是一棵二叉排序树，且具有以下性质：<strong>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</strong></p><blockquote><p>  <strong>二叉排序树</strong>：是一棵空树，或者：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉排序树。</p></blockquote><blockquote><p>  <strong>树的高度</strong>：结点层次的最大值</p></blockquote><blockquote><p>  <strong>平衡因子</strong>：左子树高度 - 右子树高度</p></blockquote><p>二叉排序树意味着二叉树中的数据是排好序的，顺序为左结点&lt;根节点&lt;右结点，这表明二叉排序树的中序遍历结果是有序的。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n06ws0jj30u00dwjrn.jpg" alt="img"></p><p>平衡二叉树的产生是为了解决二叉排序树在插入时发生线性排列的现象。由于二叉排序树本身为有序，当插入一个有序程度十分高的序列时，生成的二叉排序树会持续在某个方向的字数上插入数据，导致最终的二叉排序树会退化为链表，从而使得二叉树的查询和插入效率恶化。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n0a0wj0j30u00eswf3.jpg" alt="img"></p><p>平衡二叉树的出现能够解决上述问题，但是在构造平衡二叉树时，却需要采用不同的调整方式，使得二叉树在插入数据后保持平衡。主要的四种调整方式有LL（左旋）、RR（右旋）、LR（先左旋再右旋）、RL（先右旋再左旋）。这里先给大家介绍下简单的单旋转操作，左旋和右旋。LR和RL本质上只是LL和RR的组合。</p><blockquote><p>  在插入一个结点后应该沿搜索路径将路径上的结点平衡因子进行修改，当平衡因子大于1时，就需要进行平衡化处理。从发生不平衡的结点起，沿刚才回溯的路径取直接下两层的结点，如果这三个结点在一条直线上，则采用<strong>单旋转</strong>进行平衡化，如果这三个结点位于一条折线上，则采用<strong>双旋转</strong>进行平衡化。</p></blockquote><p>左旋：S为当前需要左旋的结点，E为当前结点的父节点。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n09ipk8j30u00c3q3d.jpg" alt="img"></p><p>左旋的操作可以用一句话简单表示：将当前结点S的左孩子旋转为当前结点父结点E的右孩子，同时将父结点E旋转为当前结点S的左孩子。可用动画表示：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n089doxg309506pjxv.gif" alt="img"></p><p>右旋：S为当前需要左旋的结点，E为当前结点的父节点。右单旋是左单旋的镜像旋转。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n0ai309j30u00bmaah.jpg" alt="img"></p><p>左旋的操作同样可以用一句话简单表示：将当前结点S的左孩子E的右孩子旋转为当前结点S的左孩子，同时将当前结点S旋转为左孩子E的右孩子。可用动画表示：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n098i9eg308d076te7.gif" alt="img"></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆通常是一个可以被看做一棵树的数组对象。堆的具体实现一般不通过指针域，而是通过构建一个一维数组与二叉树的父子结点进行对应，因此<strong>堆总是一颗完全二叉树</strong>。</p><p>对于任意一个父节点的序号n来说（这里n从0算），它的子节点的序号一定是2n+1，2n+2，因此<strong>可以直接用数组来表示一个堆</strong>。</p><p>不仅如此，堆还有一个性质：堆中某个节点的值总是不大于或不小于其父节点的值。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n53cwyuj30u00gwgmz.jpg" alt="img"></p><p><strong>堆常用来实现优先队列</strong>，在面试中经常考的问题都是与排序有关，比如堆排序、topK问题等。由于堆的根节点是序列中最大或者最小值，因而可以在建堆以及重建堆的过程中，筛选出数据序列中的极值，从而达到排序或者挑选topK值的目的。</p><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>散列表也叫哈希表，是一种通过键值对直接访问数据的机构。在初中，我们就学过一种能够将一个x值通过一个函数获得对应的一个y值的操作，叫做映射。散列表的实现原理正是映射的原理，<strong>通过设定的一个关键字和一个映射函数，就可以直接获得访问数据的地址，实现O(1)的数据访问效率</strong>。在映射的过程中，事先设定的函数就是一个映射表，也可以称作散列函数或者哈希函数。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n6hytm0j30u00aw0ta.jpg" alt="img"></p><p>散列表的实现最关键的就是散列函数的定义和选择。一般常用的有以下几种散列函数：</p><blockquote><p>  <strong>直接寻址法</strong>：取关键字或关键字的某个线性函数值为散列地址。</p><p>  <strong>数字分析法</strong>：通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。</p><p>  <strong>平方取中**</strong>法**：当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。</p><p>  <strong>取随机数法</strong>：使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。</p><p>  <strong>除留取余法</strong>：取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址。这种方式也可以在用过其他方法后再使用。该函数对 m 的选择很重要，一般取素数或者直接用 n。</p></blockquote><p>确定好散列函数之后，通过某个<code>key</code>值的确会得到一个唯一的<code>value</code>地址。但是却会出现一些特殊情况。即通过不同的<code>key</code>值可能会访问到同一个地址，这个现象称之为<strong>冲突</strong>。</p><p>冲突在发生之后，当在对不同的<code>key</code>值进行操作时会使得造成相同地址的数据发生覆盖或者丢失，是非常危险的。所以在设计散列表往往还需要采用冲突解决的办法。</p><p>常用的冲突处理方式有很多，常用的包括以下几种：</p><blockquote><p>  <strong>开放地址法</strong>（也叫开放寻址法）：实际上就是当需要存储值时，对Key哈希之后，发现这个地址已经有值了，这时该怎么办？不能放在这个地址，不然之前的映射会被覆盖。这时对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的增列序量。</p><p>  <strong>再哈希法</strong>：在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。这种方式的缺点是时间增加了。</p><p>  <strong>链地址法</strong>：链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。其实在很多高级语言的实现当中，也是使用这种方式处理冲突的。</p><p>  <strong>公共溢出区</strong>：这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。</p></blockquote><p>目前比较常用的冲突解决方法是链地址法，一般可以通过数组和链表的结合达到冲突数据缓存的目的。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n6irtgfj30u00fn0ts.jpg" alt="img"></p><p>左侧数组的每个成员包括一个指针，指向一个链表的头。每发生一个冲突的数据，就将该数据作为链表的节点链接到链表尾部。这样一来，就可以保证冲突的数据能够区分并顺利访问。</p><p>考虑到链表过长造成的问题，还可以使用红黑树替换链表进行冲突数据的处理操作，来提高散列表的查询稳定性。</p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图结构一般包括顶点和边，顶点通常用圆圈来表示，边就是这些圆圈之间的连线。边还可以根据顶点之间的关系设置不同的权重，默认权重相同皆为1。此外根据边的方向性，还可将图分为有向图和无向图。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n8bscfej30u00c80t7.jpg" alt="img"></p><p>图结构用抽象的图线来表示十分简单，顶点和边之间的关系非常清晰明了。但是在具体的代码实现中，为了将各个顶点和边的关系存储下来，却不是一件易事。</p><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>目前常用的图存储方式为邻接矩阵，通过所有顶点的二维矩阵来存储两个顶点之间是否相连，或者存储两顶点间的边权重。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n8b3xjvj30u00draan.jpg" alt="img"></p><p><strong>无向图的邻接矩阵是一个对称矩阵</strong>，是因为边不具有方向性，若能从此顶点能够到达彼顶点，那么彼顶点自然也能够达到此顶点。此外，由于顶点本身与本身相连没有意义，所以在邻接矩阵中对角线上皆为0。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n8cafa9j30u00dp0tc.jpg" alt="img"></p><p>有向图由于边具有方向性，因此彼此顶点之间并不能相互达到，所以其邻接矩阵的对称性不再。</p><p>用邻接矩阵可以直接从二维关系中获得任意两个顶点的关系，可直接判断是否相连。但是在对矩阵进行存储时，却需要完整的一个二维数组。若图中顶点数过多，会导致二维数组的大小剧增，从而占用大量的内存空间。</p><p>而根据实际情况可以分析得，图中的顶点并不是任意两个顶点间都会相连，不是都需要对其边上权重进行存储。那么存储的邻接矩阵实际上会存在大量的0。虽然可以通过稀疏表示等方式对稀疏性高的矩阵进行关键信息的存储，但是却增加了图存储的复杂性。</p><p>因此，为了解决上述问题，一种可以只存储相连顶点关系的邻接表应运而生。</p><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>在邻接表中，图的每一个顶点都是一个链表的头节点，其后连接着该顶点能够直接达到的相邻顶点。相较于无向图，有向图的情况更为复杂，因此这里采用有向图进行实例分析。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n8dbwg2j30u00e1wf3.jpg" alt="img">在邻接表中，每一个顶点都对应着一条链表，链表中存储的是顶点能够达到的相邻顶点。存储的顺序可以按照顶点的编号顺序进行。比如上图中对于顶点B来说，其通过有向边可以到达顶点A和顶点E，那么其对应的邻接表中的顺序即B-&gt;A-&gt;E，其它顶点亦如此。</p><p>通过邻接表可以获得从某个顶点出发能够到达的顶点，从而省去了对不相连顶点的存储空间。然而，这还不够。对于有向图而言，图中有效信息除了从顶点“指出去”的信息，还包括从别的顶点“指进来”的信息。这里的“指出去”和“指进来”可以用出度和入度来表示。</p><blockquote><p>  入度：有向图的某个顶点作为终点的次数和。</p><p>  出度：有向图的某个顶点作为起点的次数和。</p></blockquote><p>由此看出，<strong>在对有向图进行表示时，邻接表只能求出图的出度，而无法求出入度</strong>。这个问题很好解决，那就是增加一个表用来存储能够到达某个顶点的相邻顶点。这个表称作逆邻接表。</p><h4 id="逆邻接表"><a href="#逆邻接表" class="headerlink" title="逆邻接表"></a>逆邻接表</h4><p>逆邻接表与邻接表结构类似，只不过图的顶点链接着能够到达该顶点的相邻顶点。也就是说，邻接表时顺着图中的箭头寻找相邻顶点，而逆邻接表时逆着图中的箭头寻找相邻顶点。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n8duj3aj30u00ecmxs.jpg" alt="img"></p><p><strong>邻接表和逆邻接表的共同使用下，就能够把一个完整的有向图结构进行表示</strong>。可以发现，邻接表和逆邻接表实际上有一部分数据时重合的，因此可以将两个表合二为一，从而得到了所谓的十字链表。</p><h4 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h4><p>十字链表似乎很简单，只需要通过相同的顶点分别链向以该顶点为终点和起点的相邻顶点即可。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n8cu3gpj30u00drdgw.jpg" alt="img"></p><p>但这并不是最优的表示方式。虽然这样的方式共用了中间的顶点存储空间，但是邻接表和逆邻接表的链表节点中重复出现的顶点并没有得到重复利用，反而是进行了再次存储。因此，上图的表示方式还可以进行进一步优化。</p><p>十字链表优化后，可通过扩展的顶点结构和边结构来进行正逆邻接表的存储：（下面的弧头可看作是边的箭头那端，弧尾可看作是边的圆点那端）</p><blockquote><p>  <strong>data</strong>：用于存储该顶点中的数据；</p><p>  <strong>firstin指针</strong>：用于连接以当前顶点为弧头的其他顶点构成的链表，即从别的顶点指进来的顶点；</p><p>  <strong>firstout指针</strong>：用于连接以当前顶点为弧尾的其他顶点构成的链表，即从该顶点指出去的顶点；</p></blockquote><p>边结构通过存储两个顶点来确定一条边，同时通过分别代表这两个顶点的指针来与相邻顶点进行链接：</p><blockquote><p>  <strong>tailvex</strong>：用于存储作为弧尾的顶点的编号；</p><p>  <strong>headvex</strong>：用于存储作为弧头的顶点的编号；</p><p>  <strong>headlink</strong> <strong>指针</strong>：用于链接下一个存储作为弧头的顶点的节点；</p><p>  <strong>taillink</strong> <strong>指针</strong>：用于链接下一个存储作为弧尾的顶点的节点；</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n8bf0flj30u00ek0u2.jpg" alt="img"></p><p>以上图为例子，对于顶点A而言，其作为起点能够到达顶点E。因此在邻接表中顶点A要通过边<code>AE</code>（即边04）指向顶点E，顶点A的<code>firstout</code>指针需要指向边04的<code>tailvex</code>。同时，从B出发能够到达A，所以在逆邻接表中顶点A要通过边<code>AB</code>（即边10）指向B，顶点A的<code>firstin</code>指针需要指向边10的弧头，即<code>headlink</code>指针。依次类推。</p><p>十字链表采用了一种看起来比较繁乱的方式对边的方向性进行了表示，能够在尽可能降低存储空间的情况下增加指针保留顶点之间的方向性。具体的操作可能一时间不好弄懂，建议多看多练，弄清指针指向的意义，明白正向和逆向邻接表的表示。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;  常用的数据结构可根据数据访问的特点分为&lt;strong&gt;线性结构&lt;/strong&gt;和&lt;strong&gt;非线性结构&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;  线性结构包括常见的链表、栈、队列等，非线性结构包括树、图等。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>字符串算法</title>
    <link href="http://yoursite.com/2020/05/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/05/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2020-06-08T00:57:47.786Z</updated>
    
    <content type="html"><![CDATA[<h4 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h4><h5 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h5><p>谈到字符串问题，不得不提的就是 KMP 算法，它是用来解决<strong>字符串查找</strong>的问题，可以在一个字符串（S）中查找一个子串（W）出现的位置。KMP 算法把字符匹配的时间复杂度缩小到 O(m+n) ,而空间复杂度也只有O(m)。因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而KMP算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。</p><a id="more"></a><h4 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h4><blockquote><p>  剑指offer：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p></blockquote><p>这里我提供了两种方法：①常规方法；②利用 API 解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 第一种方法：常规方法。利用String.charAt(i)以及String.valueOf(char).equals(" "</span></span><br><span class="line"><span class="comment">    * )遍历字符串并判断元素是否为空格。是则替换为"%20",否则不替换</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = str.length();</span><br><span class="line">        <span class="comment">// System.out.println("length=" + length);</span></span><br><span class="line">        StringBuffer result = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> b = str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (String.valueOf(b).equals(<span class="string">" "</span>)) &#123;</span><br><span class="line">                result.append(<span class="string">"%20"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.append(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 第二种方法：利用API替换掉所用空格，一行代码解决问题</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceSpace2</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str.toString().replaceAll(<span class="string">"\\s"</span>, <span class="string">"%20"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h4><blockquote><p>  Leetcode: 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，则返回空字符串。</p></blockquote><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure><p>思路很简单！先利用Arrays.sort(strs)为数组排序，再将数组第一个元素和最后一个元素的字符从前往后对比即可！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceSpace</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果检查值不合法及就返回空串</span></span><br><span class="line">        <span class="keyword">if</span> (!checkStrs(strs)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组长度</span></span><br><span class="line">        <span class="keyword">int</span> len = strs.length;</span><br><span class="line">        <span class="comment">// 用于保存结果</span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 给字符串数组的元素按照升序排序(包含数字的话，数字会排在前面)</span></span><br><span class="line">        Arrays.sort(strs);</span><br><span class="line">        <span class="keyword">int</span> m = strs[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">int</span> n = strs[len - <span class="number">1</span>].length();</span><br><span class="line">        <span class="keyword">int</span> num = Math.min(m, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[<span class="number">0</span>].charAt(i) == strs[len - <span class="number">1</span>].charAt(i)) &#123;</span><br><span class="line">                res.append(strs[<span class="number">0</span>].charAt(i));</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">chechStrs</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (strs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历strs检查元素值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (strs[i] != <span class="keyword">null</span> &amp;&amp; strs[i].length() != <span class="number">0</span>) &#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] strs = &#123; <span class="string">"customer"</span>, <span class="string">"car"</span>, <span class="string">"cat"</span> &#125;;</span><br><span class="line">        <span class="comment">// String[] strs = &#123; "customer", "car", null &#125;;//空串</span></span><br><span class="line">        <span class="comment">// String[] strs = &#123;&#125;;//空串</span></span><br><span class="line">        <span class="comment">// String[] strs = null;//空串</span></span><br><span class="line">        System.out.println(Main.replaceSpace(strs));<span class="comment">// c</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回文串"><a href="#回文串" class="headerlink" title="回文串"></a>回文串</h4><h5 id="最长回文串"><a href="#最长回文串" class="headerlink" title="最长回文串"></a>最长回文串</h5><blockquote><p>  LeetCode: 给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。在构造过程中，请注意区分大小写。比如<code>&quot;Aa&quot;</code>不能当做一个回文字符串。注 意:假设字符串的长度不会超过 1010。</p></blockquote><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line">输出:</span><br><span class="line">7</span><br><span class="line">解释:我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</span><br></pre></td></tr></table></figure><p>我们上面已经知道了什么是回文串？现在我们考虑一下可以构成回文串的两种情况：</p><ul><li>字符出现次数为双数的组合</li><li><strong>字符出现次数为偶数的组合+单个字符中出现次数最多且为奇数次的字符</strong> </li></ul><p>统计字符出现的次数即可，双数才能构成回文。因为允许中间一个数单独出现，比如“abcba”，所以如果最后有字母落单，总长度可以加 1。首先将字符串转变为字符数组。然后遍历该数组，判断对应字符是否在HashSet中，如果不在就加进去，如果在就让count++，然后移除该字符！这样就能找到出现次数为双数的字符个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 用于存放字符</span></span><br><span class="line">        HashSet&lt;Character&gt; hashset = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hashset.contains(chars[i])) &#123;<span class="comment">// 如果hashset没有该字符就保存进去</span></span><br><span class="line">                hashset.add(chars[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果有,就让count++（说明找到了一个成对的字符），然后把该字符移除</span></span><br><span class="line">                hashset.remove(chars[i]);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hashset.isEmpty() ? count * <span class="number">2</span> : count * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a>验证回文串</h5><blockquote><p>  LeetCode: 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。</p></blockquote><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">// 从头和尾开始向中间遍历</span></span><br><span class="line">            <span class="keyword">if</span> (!Character.isLetterOrDigit(s.charAt(l))) &#123;</span><br><span class="line">                <span class="comment">// 字符不是字母和数字的情况</span></span><br><span class="line">                l++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!Character.isLetterOrDigit(s.charAt(r))) &#123;</span><br><span class="line">                <span class="comment">// 字符不是字母和数字的情况</span></span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 判断二者是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (Character.toLowerCase(s.charAt(l)) </span><br><span class="line">                    != Character.toLowerCase(s.charAt(r)))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h5><blockquote><p>  LeetCode: 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p></blockquote><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot;也是一个有效答案。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><p>以某个元素为中心，分别计算偶数长度的回文最大长度和奇数长度的回文最大长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index, maxLen;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//奇数情况</span></span><br><span class="line">            PalindromeHelper(s, i, i);</span><br><span class="line">            <span class="comment">//偶数情况</span></span><br><span class="line">            PalindromeHelper(s, i, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(index, index + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PalindromeHelper</span><span class="params">(String s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//若相等则向两边不断进行比较</span></span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">            l--;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保存最大长度和开始下标</span></span><br><span class="line">        <span class="keyword">if</span> (maxLen &lt; r - l - <span class="number">1</span>) &#123;</span><br><span class="line">            index = l + <span class="number">1</span>;</span><br><span class="line">            maxLen = r - l - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.equals(<span class="string">""</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//字符串s[i⋯j]是否为回文子串，如果是，dp[i][j]=true，如果不是，dp[i][j]=false</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录最长回文字串的左右下标</span></span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化，单个字符都是回文子串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//开始遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; s.length(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    <span class="comment">//考虑“cbba”这种情况</span></span><br><span class="line">                    <span class="keyword">if</span>(j - i == <span class="number">1</span>)&#123;</span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//只要dp[i+1][j-1]是回文子串，那么dp[i][j]也就是回文子串</span></span><br><span class="line">                        dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>]; </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j])&#123;</span><br><span class="line">                    <span class="comment">//找到更长字串，则更新</span></span><br><span class="line">                    <span class="keyword">if</span>(max - min &lt;= j - i)&#123;</span><br><span class="line">                        min = i;</span><br><span class="line">                        max = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(min, max + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h5><blockquote><p>  LeetCode: 给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。 <strong>最长回文子序列和上一题最长回文子串的区别是，子串是字符串中连续的一个序列，而子序列是字符串中保持相对位置的字符序列，例如，”bbbb”可以是字符串”bbbab”的子序列但不是子串。</strong></p></blockquote><p>给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;bbbab&quot;</span><br><span class="line">输出:</span><br><span class="line">4</span><br><span class="line">解释: 一个可能的最长回文子序列为 &quot;bbbb&quot;。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;cbbd&quot;</span><br><span class="line">输出:</span><br><span class="line">2</span><br><span class="line">解释: 一个可能的最长回文子序列为 &quot;bb&quot;。</span><br></pre></td></tr></table></figure><p><strong>动态规划：</strong></p><p><code>dp[i][j]</code>表示从i到j的子序列的回文串的数量(i&lt;j)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if s.charAt(i) &#x3D;&#x3D; s.charAt(j) </span><br><span class="line">dp[i][j] &#x3D; dp[i+1][j-1] + 2 </span><br><span class="line">else</span><br><span class="line">dp[i][j] &#x3D; Math.max(dp[i+1][j], dp[i][j-1])</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i+<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="括号匹配深度"><a href="#括号匹配深度" class="headerlink" title="括号匹配深度"></a>括号匹配深度</h4><blockquote><p>  “”,”()”,”()()”,”((()))”都是合法的括号序列 对于一个合法的括号序列我们又有以下定义它的深度:</p><ol><li>空串””的深度是0</li><li>如果字符串”X”的深度是x,字符串”Y”的深度是y,那么字符串”XY”的深度为max(x,y)</li><li>如果”X”的深度是x,那么字符串”(X)”的深度是x+1</li></ol></blockquote><blockquote><p>  例如: “()()()”的深度是1,”((()))”的深度是3。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入描述:</span><br><span class="line">输入包括一个合法的括号序列s,s长度length(2 ≤ length ≤ 50),序列中只包含&#39;(&#39;和&#39;)&#39;。</span><br><span class="line">输出描述:</span><br><span class="line">输出一个正整数,即这个序列的深度。</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">(())</span><br><span class="line">输出:</span><br><span class="line">2</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String s = sc.nextLine();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>)</span><br><span class="line">                cnt++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cnt--;</span><br><span class="line">            max = Math.max(max, cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h4><blockquote><p>  剑指offer: 将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="comment">// 判断是否存在符号位</span></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (chars[<span class="number">0</span>] == <span class="string">'+'</span>)&#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (chars[<span class="number">0</span>] == <span class="string">'-'</span>)&#123;</span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> start = flag &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 保存结果</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(chars[i])) &#123;</span><br><span class="line">                <span class="comment">// 调用Character.isDigit(char)方法判断是否是数字，是返回True，否则False</span></span><br><span class="line">                <span class="keyword">int</span> temp = chars[i] - <span class="string">'0'</span>;</span><br><span class="line">                res = res * <span class="number">10</span> + temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag == <span class="number">2</span> ? -res : res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"-12312312"</span>;</span><br><span class="line">        System.out.println(<span class="string">"使用库函数转换："</span> + Integer.valueOf(s));</span><br><span class="line">        <span class="keyword">int</span> res = Main.StrToInt(s);</span><br><span class="line">        System.out.println(<span class="string">"使用自己写的方法转换："</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;字符串查找&quot;&gt;&lt;a href=&quot;#字符串查找&quot; class=&quot;headerlink&quot; title=&quot;字符串查找&quot;&gt;&lt;/a&gt;字符串查找&lt;/h4&gt;&lt;h5 id=&quot;KMP-算法&quot;&gt;&lt;a href=&quot;#KMP-算法&quot; class=&quot;headerlink&quot; title=&quot;KMP 算法&quot;&gt;&lt;/a&gt;KMP 算法&lt;/h5&gt;&lt;p&gt;谈到字符串问题，不得不提的就是 KMP 算法，它是用来解决&lt;strong&gt;字符串查找&lt;/strong&gt;的问题，可以在一个字符串（S）中查找一个子串（W）出现的位置。KMP 算法把字符匹配的时间复杂度缩小到 O(m+n) ,而空间复杂度也只有O(m)。因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而KMP算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构图解</title>
    <link href="http://yoursite.com/2020/05/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BE%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/05/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BE%E8%A7%A3/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2020-06-08T00:57:51.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="数组、链表的优缺点"><a href="#数组、链表的优缺点" class="headerlink" title="数组、链表的优缺点"></a>数组、链表的优缺点</h3><h4 id="数组的优缺点"><a href="#数组的优缺点" class="headerlink" title="数组的优缺点"></a>数组的优缺点</h4><p>数组的优点在于：</p><ul><li>构建非常简单</li><li>能在 O(1) 的时间里根据数组的下标（index）查询某个元素</li></ul><p>而数组的缺点在于：</p><ul><li>构建时必须分配一段连续的空间</li><li>查询某个元素是否存在时需要遍历整个数组，耗费 O(n) 的时间（其中，n 是元素的个数）</li><li>删除和添加某个元素时，同样需要耗费 O(n) 的时间</li></ul><a id="more"></a><h4 id="链表的优缺点"><a href="#链表的优缺点" class="headerlink" title="链表的优缺点"></a>链表的优缺点</h4><p>链表的优点如下：</p><ul><li>链表能灵活地分配内存空间；</li><li>能在 O(1) 时间内删除或者添加元素，前提是该元素的前一个元素已知，当然也取决于是单链表还是双链表，在双链表中，如果已知该元素的后一个元素，同样可以在 O(1) 时间内删除或者添加该元素。</li></ul><p>链表的缺点是：</p><ul><li>不像数组能通过下标迅速读取元素，每次都要从链表头开始一个一个读取；</li><li>查询第 k 个元素需要 O(k) 时间。</li></ul><p><strong>应用场景</strong>：如果要解决的问题里面需要很多快速查询，链表可能并不适合；如果遇到的问题中，数据的元素个数不确定，而且需要经常进行数据的添加和删除，那么链表会比较合适。而如果数据元素大小确定，删除插入的操作并不多，那么数组可能更适合。</p><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p><strong>特点：</strong>栈的最大特点就是<strong>后进先出（LIFO）</strong>。对于栈中的数据来说，所有操作都是在栈的顶部完成的，只可以查看栈顶部的元素，只能够向栈的顶部压⼊数据，也只能从栈的顶部弹出数据。</p><p><strong>实现：</strong>利用一个<strong>单链表</strong>来实现栈的数据结构。而且，因为我们都只针对栈顶元素进行操作，所以借用单链表的头就能让所有栈的操作在 O(1) 的时间内完成。</p><p><strong>应用场景：</strong>在解决某个问题的时候，只要求关心最近一次的操作，并且在操作完成了之后，需要向前查找到更前一次的操作。如果打算用一个数组外加一个指针来实现相似的效果，那么，一旦数组的长度发生了改变，哪怕只是在最后添加一个新的元素，时间复杂度都不再是 O(1)，而且，空间复杂度也得不到优化。</p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p><strong>特点：</strong>和栈不同，队列的最大特点是<strong>先进先出（FIFO）</strong>，就好像按顺序排队一样。对于队列的数据来说，我们只允许在队尾查看和添加数据，在队头查看和删除数据。</p><p><strong>实现：</strong>可以借助<strong>双链表</strong>来实现队列。双链表的头指针允许<strong>在队头查看和删除数据</strong>，而双链表的尾指针允许我们<strong>在队尾查看和添加数据</strong>。</p><p><strong>应用场景：</strong>直观来看，当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题。在算法面试题当中，广度优先搜索（Breadth-First Search）是运用队列最多的地方。</p><h5 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h5><p><strong>特点：</strong>双端队列和普通队列最大的不同在于，它允许我们在队列的头尾两端都能在 O(1) 的时间内进行数据的查看、添加和删除。</p><p><strong>实现：</strong>与队列相似，我们可以利用一个<strong>双链表</strong>实现双端队列。</p><p><strong>应用场景：</strong>双端队列最常用的地方就是实现一个<strong>长度动态变化的窗口或者连续区间</strong>，而动态窗口这种数据结构在很多题目里都有运用。</p><h5 id="优先队列（-Priority-Queue）"><a href="#优先队列（-Priority-Queue）" class="headerlink" title="优先队列（ Priority Queue）"></a>优先队列（ Priority Queue）</h5><p><strong>特点：</strong>能保证每次取出的元素都是队列中优先级别最高的。优先级别可以是<strong>自定义</strong>的，例如，数据的数值越大，优先级越高；或者数据的数值越小，优先级越高。优先级别甚至可以通过各种复杂的计算得到。</p><p><strong>应用场景：</strong>从一堆杂乱无章的数据当中按照定的顺序（或者优先级）逐步地筛选出部分乃至全部的数据。</p><p><strong>实现：</strong>优先队列的本质是一个二叉堆结构。堆在英文里叫 Binary Heap，它是利用一个数组结构来实现的<strong>完全二叉树</strong>。换句话说，优先队列的本质是一个数组，数组里的每个元素既有可能是其他元素的父节点，也有可能是其他元素的子节点，而且，每个父节点只能有两个子节点，很像一棵二叉树的结构。</p><blockquote><p>  牢记三个重要的性质：</p><ol><li>数组里的第一个元素 arrays[0]拥有最高的优先级别</li><li>给定一个下标i，那么对于元素array[i]而言:<ul><li>它的父节点所对应的元素下标是(i-1)/2</li><li>它的左孩子所对应的元素下标是2*i+1</li><li>它的右孩子所对应的元素下标是2*i+2</li></ul></li><li>数组里每个元素的优先级别都要高于它两个孩子的优先级别</li></ol></blockquote><p>优先队列最基本的操作有两个</p><p><strong>向上筛选</strong></p><ol><li>当有新的数据加入到优先队列中，新的数据首先被放置在二叉堆的底部。</li><li>不断进行向上筛选的操作，即如果发现该数据的优先级别比父节点的优先级别还要高，那么就和父节点的元素相互交换，再接着往上进行比较，直到无法再继续交换为止。</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pji7rupg31400m8e82.gif" alt=""></p><p><strong>时间复杂度：</strong>由于二叉堆是一棵完全二叉树，并假设堆的大小为k，因此整个过程其实就是沿着树的高度往上爬，所以只需要O(log k)的时间。</p><p><strong>向下筛选</strong></p><ol><li>当堆顶的元素被取出时，要更新堆顶的元素来作为下一次按照优先级顺序被取出的对象，需要将堆底部的元素放置到堆顶，然后不断地对它执行向下筛选的操作。</li><li>将该元素和它的两个孩子节点对比优先级，如果优先级最高的是其中一个孩子，就将该元素和那个孩子进行交换，然后反复进行下去，直到无法继续交换为止。</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pjjm5lsg31400m8x6p.gif" alt="img"></p><p><strong>时间复杂度：</strong>整个过程就是沿着树的高度往下爬，所以时间复杂度也是O(log k）</p><p>因此，无论是添加新的数据还是取出堆顶的元素，都需要O(log k)的时间。</p><p><strong>初始化</strong></p><p>优先队列的初始化是一个<strong>最重要</strong>的时间复杂度，是分析运用优先队列性能时必不可少的，也是经常容易弄错的地方。</p><p><strong>误区：</strong>每当把—个数据加入到堆里，都要对其执行向上筛选的操作，这样一来就是O(n log n)。</p><p><strong>解法：</strong>在创建这个堆的过程中，二叉树的大小是从1逐渐增长到n的，所以整个算法的复杂度经过推导，最终的结果是O(n)。</p><p>注意：算法面试中是不要求推导的，你只需要记住，初始化大小为n的堆，所需要的时间是O（n）即可。</p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树的结构十分直观，而树的很多概念定义都有一个相同的特点：递归，也就是说，一棵树要满足某种性质，往往要求每个节点都必须满足。例如，在定义一棵二叉搜索树时，每个节点也都必须是一棵二叉搜索树。</p><p>正因为树有这样的性质，大部分关于树的面试题都与递归有关，换句话说，面试官希望通过一道关于树的问题来考察对于递归算法掌握的熟练程度。</p><h4 id="树的形状"><a href="#树的形状" class="headerlink" title="树的形状"></a>树的形状</h4><p>在面试中常考的树的形状有：普通二叉树、平衡二叉树、完全二叉树、二叉搜索树、四叉树（Quadtree）、多叉树（N-ary Tree）。</p><p>对于一些特殊的树，例如红黑树（Red-Black Tree）、自平衡二叉搜索树（AVL Tree），一般在面试中不会被问到，除非你所涉及的研究领域跟它们相关或者你十分感兴趣，否则不需要特别着重准备。</p><p>关于树的考题，无非就是要考查<strong>树的遍历</strong>以及<strong>序列化（serialization)</strong>。</p><h4 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h4><h5 id="前序遍历（Preorder-Traversal）"><a href="#前序遍历（Preorder-Traversal）" class="headerlink" title="前序遍历（Preorder Traversal）"></a>前序遍历（Preorder Traversal）</h5><p><strong>方法：</strong>先访问根节点，然后访问左子树，最后访问右子树。在访问左、右子树的时候，同样，先访问子树的根节点，再访问子树根节点的左子树和右子树，这是一个不断递归的过程。</p><p> <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pjmttggg31hc0p0hdz.gif" alt="img"></p><p>​    </p><p><strong>应用场景：</strong>运用最多的场合包括在树里进行<strong>搜索</strong>以及<strong>创建一棵新的树</strong>。</p><h5 id="中序遍历（Inorder-Traversal）"><a href="#中序遍历（Inorder-Traversal）" class="headerlink" title="中序遍历（Inorder Traversal）"></a>中序遍历（Inorder Traversal）</h5><p><strong>方法：</strong>先访问左子树，然后访问根节点，最后访问右子树，在访问左、右子树的时候，同样，先访问子树的左边，再访问子树的根节点，最后再访问子树的右边。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pjqntv9g31hc0p04qz.gif" alt="img">      </p><p><strong>应用场景：</strong>最常见的是<strong>二叉搜素树</strong>，由于二叉搜索树的性质就是左孩子小于根节点，根节点小于右孩子，对二叉搜索树进行中序遍历的时候，被访问到的节点大小是按顺序进行的。</p><h5 id="后序遍历（Postorder-Traversal）"><a href="#后序遍历（Postorder-Traversal）" class="headerlink" title="后序遍历（Postorder Traversal）"></a>后序遍历（Postorder Traversal）</h5><p><strong>方法：</strong>先访问左子树，然后访问右子树，最后访问根节点。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pjv2qjkg31hc0p0u17.gif" alt="img">       </p><p><strong>应用场景：</strong>在对某个节点进行分析的时候，需要来自左子树和右子树的信息。收集信息的操作是从树的底部不断地往上进行，好比你在修剪一棵树的叶子，修剪的方法是从外面不断地往根部将叶子一片片地修剪掉。</p><p><strong>注意：</strong></p><p>掌握好这三种遍历的<strong>递归写法</strong>和<strong>非递归写法</strong>是非常重要的，懂得分析各种写法的<strong>时间复杂度</strong>和<strong>空间复杂度</strong>同样重要。</p><p>无论是前端工程师，还是后端工程师，在准备面试的时候，树这个数据结构都是最应该花时间学习的，既能证明你对递归有很好的认识，又能帮助你学习图论。树的许多性质都是面试的热门考点，尤其是<strong>二叉搜索树（BST）</strong><code>（二叉搜索树的性质：对于每个节点来说，该节点的值比左孩子大，比右孩子小，而且一般来说，二叉搜索树里不出现重复的值）</code>。</p><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h4 id="基本知识点"><a href="#基本知识点" class="headerlink" title="基本知识点"></a><strong>基本知识点</strong></h4><p>图可以说是所有数据结构里面知识点最丰富的一个，最基本的知识点如下：</p><ul><li><p>阶、出度、入度</p></li><li><p>树、森林、环</p></li><li><p>有向图、无向图、完全有向图、完全无向图</p></li><li><p>连通图、连通分量</p></li><li><p>存储和表达方式：邻接矩阵、邻接链表</p></li></ul><p>根据长期的经验总结，以下的知识点是必须充分掌握并反复练习:</p><h4 id="基本存储方式"><a href="#基本存储方式" class="headerlink" title="基本存储方式"></a>基本存储方式</h4><h5 id="邻接链表（Adjacency-List）"><a href="#邻接链表（Adjacency-List）" class="headerlink" title="邻接链表（Adjacency List）"></a>邻接链表（Adjacency List）</h5><p><strong>无向图 graph 表示</strong></p><p><strong>有向图 digraph 表示</strong></p><h5 id="邻接矩阵（-Adjacency-Matrix）"><a href="#邻接矩阵（-Adjacency-Matrix）" class="headerlink" title="邻接矩阵（ Adjacency Matrix）"></a>邻接矩阵（ Adjacency Matrix）</h5><p><strong>无向图 graph 表示</strong></p><p><strong>有向图 digraph 表示</strong></p><blockquote><p>  若采用邻接矩阵表示，则需要申请空间大小为 <img src="https://math.jianshu.com/math?formula=%7CV%7C%5E2" alt="|V|^2"> 的二维数组，在二位数组中保存每两个顶点之间的连通关系，则无论有向图或无向图，邻接矩阵方式的存储<strong>空间复杂度皆为</strong> <img src="https://math.jianshu.com/math?formula=O(%7CV%7C%5E2)" alt="O(|V|^2)">。若只记录图中顶点是否连通，不记录权值大小，则可以使用一个二进制位来表示二维数组的每个元素，并且根据无向图的特点可知，<strong>无向图的邻接矩阵沿对角线对称，所以可以选择记录一半邻接矩阵的形式来节省空间开销</strong>。</p></blockquote><p><strong>两种存储结构对比</strong></p><p>根据邻接表和邻接矩阵的结构特性可知，当图为稀疏图、顶点较多，即图结构比较大时，更适宜选择邻接表作为存储结构。当图为稠密图、顶点较少时，或者不需要记录图中边的权值时，使用邻接矩阵作为存储结构较为合适。</p><h4 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h4><h5 id="深度优先搜索（Depth-First-Search-DFS）"><a href="#深度优先搜索（Depth-First-Search-DFS）" class="headerlink" title="深度优先搜索（Depth-First Search / DFS）"></a>深度优先搜索（Depth-First Search / DFS）</h5><p>深度优先搜索，从起点出发，从规定的方向中选择其中一个不断地向前走，直到无法继续为止，然后尝试另外一种方向，直到最后走到终点。就像走迷宫一样，尽量往深处走。</p><p><strong>DFS 解决的是连通性的问题，即给定两个点，一个是起始点，一个是终点，判断是不是有一条路径能从起点连接到终点</strong>。起点和终点，也可以指的是某种起始状态和最终的状态。<strong>问题的要求并不在乎路径是长还是短，只在乎有还是没有</strong>。有时候题目也会要求把找到的路径完整的打印出来。</p><p><strong>DFS 遍历</strong></p><p>对这个图进行深度优先的遍历：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pkikpvtj30lo07agm5.jpg" alt="img"></p><p><strong>解题思路</strong></p><p>必须依赖<strong>栈（Stack）</strong>，特点是<strong>后进先出（LIFO）</strong>。</p><p>第一步，选择一个起始顶点，例如从顶点 A 开始。把 A 压入栈，标记它为访问过（用红色标记），并输出到结果中。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pkjlqq5g31hc0p0npd.gif" alt="img"></p><p>第二步，寻找<strong>与 A 相连</strong>并且还<strong>没有被访问过</strong>的顶点，顶点 A 与 B、D、G 相连，而且它们都还没有被访问过，我们按照<strong>字母顺序</strong>处理，所以将 B 压入栈，标记它为访问过，并输出到结果中。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pkm7y06g31hc0p0qv6.gif" alt="img">   </p><p>第三步，现在我们在顶点 B 上，重复上面的操作，由于 B 与 A、E、F 相连，如果按照字母顺序处理的话，A 应该是要被访问的，但是 <strong>A 已经被访问</strong>了，所以我们访问顶点 E，将 E 压入栈，标记它为访问过，并输出到结果中。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pkpueksg31hc0p01ky.gif" alt="img">   </p><p>第四步，从 E 开始，E 与 B、G 相连，但是B刚刚被访问过了，所以下一个被访问的将是G，把G压入栈，标记它为访问过，并输出到结果中。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pkr4of1g31hc0p0b2a.gif" alt="img">   </p><p>第五步，现在我们在顶点 G 的位置，由于<strong>与 G 相连的顶点都被访问过</strong>了，类似于我们走到了一个死胡同，必须尝试其他的路口了。所以我们这里要做的就是简单地<strong>将 G 从栈里弹出</strong>，表示我们从 G 这里已经无法继续走下去了，看看能不能从前一个路口找到出路。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pksjmsug31hc0p07u8.gif" alt="img">   </p><blockquote><p>  可以看到，每次我们在考虑下一个要被访问的点是什么的时候，如果发现周围的顶点都被访问了，就把当前的顶点弹出。</p></blockquote><p>第六步，现在栈的顶部记录的是顶点 E，我们来看看与 E 相连的顶点中有没有还没被访问到的，发现它们都被访问了，所以把 E 也弹出去。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pktes4kg31hc0p01kx.gif" alt="img">   </p><p>第七步，当前栈的顶点是 B，看看它周围有没有还没被访问的顶点，有，是顶点 F，于是<strong>把 F 压入栈</strong>，标记它为访问过，并输出到结果中。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pkvfz1hg31hc0p0b2c.gif" alt="img">   </p><p>第八步，当前顶点是 F，与 F 相连并且还未被访问到的点是 C 和 D，按照字母顺序来，下一个被访问的点是 C，将 C 压入栈，标记为访问过，输出到结果中。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pkybm5pg31hc0p0u0z.gif" alt="img">   </p><p>第九步，当前顶点为 C，与 C 相连并尚未被访问到的顶点是 H，将 H 压入栈，标记为访问过，输出到结果中。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pl03gzfg31hc0p0e84.gif" alt="img">   </p><p>第十步，当前顶点是 H，由于和它相连的点都被访问过了，将它弹出栈。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pl2k7m0g31hc0p0x6q.gif" alt="img">   </p><p>第十一步，当前顶点是 C，与 C 相连的点都被访问过了，将 C 弹出栈。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pl4blmyg31hc0p0npe.gif" alt="img">   </p><p>第十二步，当前顶点是 F，与 F 相连的并且尚未访问的点是 D，将 D 压入栈，输出到结果中，并标记为访问过。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pl5o2dkg31hc0p0kjm.gif" alt="img">   </p><p>第十三步，当前顶点是 D，与它相连的点都被访问过了，将它弹出栈。以此类推，顶点 F，B，A 的邻居都被访问过了，将它们<strong>依次弹出栈</strong>就好了。最后，<strong>当栈里已经没有顶点需要处理了，我们的整个遍历结束</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pl7b5bwg31hc0p0npf.gif" alt="img">   </p><p><strong>算法分析</strong> </p><p>DFS 是图论里的算法，分析利用 DFS 解题的复杂度时，应当借用图论的思想。图有两种表示方式：邻接表、邻接矩阵。假设图里有 V 个顶点，E 条边。</p><p><strong>时间复杂度：</strong></p><ul><li><p>邻接表</p><p>访问所有顶点的时间为 O(V)，而查找所有顶点的邻居一共需要 O(E) 的时间，所以总的时间复杂度是 <strong>O(V + E)</strong>。</p></li><li><p>邻接矩阵</p><p>查找每个顶点的邻居需要 O(V) 的时间，所以查找整个矩阵的时候需要 <strong>O(V²)</strong> 的时间。</p></li></ul><p><strong>空间复杂度：</strong></p><p>DFS 需要<strong>堆栈</strong>来辅助，在最坏情况下，得把所有顶点都压入堆栈里，所以它的空间复杂度是 <strong>O(V)</strong>。</p><h5 id="广度优先搜索（Breadth-First-Search-BFS）"><a href="#广度优先搜索（Breadth-First-Search-BFS）" class="headerlink" title="广度优先搜索（Breadth-First Search / BFS）"></a>广度优先搜索（Breadth-First Search / BFS）</h5><p>广度优先搜索，一般用来解决<strong>最短路径</strong>的问题。和深度优先搜索不同，广度优先的搜索是从起始点出发，一层一层地进行，每层当中的点距离起始点的步数都是相同的，当找到了目的地之后就可以立即结束。</p><p>广度优先的搜索可以同时从起始点和终点开始进行，称之为<strong>双端 BFS</strong>。这种算法往往可以大大地提高搜索的效率。</p><p><strong>BFS 遍历</strong></p><p>对这个图进行广度优先的遍历：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pl8dhgrj30lo07amxp.jpg" alt="img"></p><p><strong>解题思路</strong></p><p>依赖<strong>队列（Queue）</strong>，<strong>先进先出（FIFO）</strong>。一层一层地把与某个点相连的点放入队列中，处理节点的时候正好按照它们进入队列的顺序进行。</p><p>第一步，选择一个起始顶点，让我们从顶点 A 开始。把 A 压入队列，标记它为访问过（用红色标记）。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pl9uwyag31hc0p04qq.gif" alt="img">   </p><p>第二步，从队列的头取出顶点 A，打印输出到结果中，同时将<strong>与它相连</strong>的<strong>尚未被访问过</strong>的点按照<strong>字母大小顺序</strong>压入队列，同时把它们都标记为访问过，防止它们被重复地添加到队列中。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4plcbbsfg31hc0p0b2c.gif" alt="img">   </p><p>第三步，从<strong>队列的头</strong>取出顶点 B，打印输出它，同时将与它相连的尚未被访问过的点（也就是 E 和 F）压入队列，同时把它们都标记为访问过。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pletvd7g31hc0p07wn.gif" alt="img">   </p><p>第四步，继续从队列的头取出顶点 D，打印输出它，此时我们发现，与 D 相连的顶点 A 和 F 都被标记访问过了，所以就不要把它们压入队列里。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4plgfn9qg31hc0p0x6q.gif" alt="img">   </p><p>第五步，接下来，队列的头是顶点 G，打印输出它，同样的，G 周围的点都被标记访问过了。我们不做任何处理。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pliczz6g31hc0p0hdv.gif" alt="img">   </p><p>第六步，队列的头是 E，打印输出它，它周围的点也都被标记为访问过了，我们不做任何处理。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pljpkvng31hc0p0e81.gif" alt="img">   </p><p>第七步，接下来轮到顶点 F，打印输出它，将 C 压入队列，并标记 C 为访问过。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4plm8b90g31hc0p0npe.gif" alt="img">   </p><p>第八步，将 C 从队列中移出，打印输出它，与它相连的 H 还没被访问到，将 H 压入队列，将它标记为访问过。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4plnm5iog31hc0p07wi.gif" alt="img">   </p><p> 第九步，队列里只剩下 H 了，将它移出，打印输出它，发现它的邻居都被访问过了，不做任何事情。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4plotsqwg31hc0p0u0x.gif" alt="img">   </p><p>第十步，<strong>队列为空，表示所有的点都被处理完毕了</strong>，程序结束。</p><p><strong>算法分析</strong></p><p>同样借助图论的分析方法，假设有 V 个顶点，E 条边。</p><p><strong>时间复杂度：</strong></p><ul><li><p>邻接表</p><p>每个顶点都需要被访问一次，时间复杂度是 O(V)；相连的顶点（也就是每条边）也都要被访问一次，加起来就是 O(E)。因此整体时间复杂度就是 <strong>O(V+E)</strong>。</p></li><li><p>邻接矩阵</p><p>V 个顶点，每次都要检查每个顶点与其他顶点是否有联系，因此时间复杂度是 <strong>O(V²)</strong>。</p></li></ul><p><strong>空间复杂度：</strong></p><p>需要借助一个队列，所有顶点都要进入队列一次，从队列弹出一次。在最坏的情况下，空间复杂度是 <strong>O(V)</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h2&gt;&lt;h3 id=&quot;数组、链表的优缺点&quot;&gt;&lt;a href=&quot;#数组、链表的优缺点&quot; class=&quot;headerlink&quot; title=&quot;数组、链表的优缺点&quot;&gt;&lt;/a&gt;数组、链表的优缺点&lt;/h3&gt;&lt;h4 id=&quot;数组的优缺点&quot;&gt;&lt;a href=&quot;#数组的优缺点&quot; class=&quot;headerlink&quot; title=&quot;数组的优缺点&quot;&gt;&lt;/a&gt;数组的优缺点&lt;/h4&gt;&lt;p&gt;数组的优点在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建非常简单&lt;/li&gt;
&lt;li&gt;能在 O(1) 的时间里根据数组的下标（index）查询某个元素&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而数组的缺点在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建时必须分配一段连续的空间&lt;/li&gt;
&lt;li&gt;查询某个元素是否存在时需要遍历整个数组，耗费 O(n) 的时间（其中，n 是元素的个数）&lt;/li&gt;
&lt;li&gt;删除和添加某个元素时，同样需要耗费 O(n) 的时间&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://yoursite.com/2020/05/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/05/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2020-06-08T00:57:51.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序算法说明"><a href="#排序算法说明" class="headerlink" title="排序算法说明"></a>排序算法说明</h2><p><strong>排序的定义</strong></p><p>对一序列对象根据某个关键字进行排序。</p><p><strong>术语说明</strong></p><ul><li>稳定 ：如果a原本在b前面，并且a=b，则排序之后a仍然在b的前面；</li><li>不稳定 ：如果a原本在b的前面，而a=b，则排序之后a可能会出现在b的后面；</li><li>内排序 ：所有排序操作都在<strong>内存中</strong>完成；</li><li>外排序 ：由于数据太大，因此把<strong>数据放在磁盘中</strong>，而排序通过磁盘和内存的数据传输才能进行；</li><li>时间复杂度 ： 一个算法执行所耗费的时间。</li><li>空间复杂度 ：运行完一个程序所需内存的大小。</li></ul><a id="more"></a><h2 id="算法复杂度总结"><a href="#算法复杂度总结" class="headerlink" title="算法复杂度总结"></a>算法复杂度总结</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf24qu4fi7j30qu0gcn1e.jpg" alt="算法复杂度"></p><p><strong>图片名词解释：</strong></p><ul><li>n: 数据规模</li><li>k: “桶”的个数</li><li>In-place: 占用常数内存，不占用额外内存</li><li>Out-place: 占用额外内存</li></ul><p><strong>比较和非比较的区别</strong></p><p>常见的<strong>快速排序、归并排序、堆排序、冒泡排序</strong> 等属于<strong>比较排序</strong> 。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。<strong>每个数都必须和其他数进行比较，才能确定自己的位置</strong> 。</p><p>在冒泡排序之类的排序中，问题规模为n，又因为需要比较<strong>n</strong>次，所以平均时间复杂度为<strong>O(n²)</strong>。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为<strong>logN</strong>次，所以时间复杂度平均<strong>O(nlogn)</strong>。</p><p>比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。</p><p><strong>计数排序、基数排序、桶排序</strong>则属于<strong>非比较排序</strong> 。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置 。</p><p>非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度<strong>O(n)</strong>。</p><p>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</p><h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p><strong>算法描述</strong></p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，<strong>除了最后一个</strong>（此时最后一个是最大的元素）；</li><li>重复步骤1~3，直到排序完成。</li></ol><p><strong>动图演示</strong></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf24r02ereg30my075wqv.gif" alt="冒泡排序"></p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一共需要array.length次循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="comment">//每次冒泡去除后面i个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - <span class="number">1</span> - i; j++)</span><br><span class="line">            <span class="comment">//如果当前元素大于下一个元素则交换</span></span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = array[j + <span class="number">1</span>];</span><br><span class="line">                array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">                array[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><p>选择排序是表现最稳定的排序算法之一 ，因为无论什么数据进去都是<strong>O(n^2^)</strong>的时间复杂度 ，所以用到它的时候，<strong>数据规模越小越好</strong>。唯一的好处就是<strong>不占用额外的内存空间</strong>。</p><p><strong>算法描述</strong></p><ol><li>在未排序序列中找到最小（大）元素，存放到排序序列的<strong>起始位置</strong></li><li>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的<strong>下一位</strong></li><li>以此类推，直到所有元素均排序完毕</li></ol><blockquote><p>  <strong>n</strong>个记录的直接选择排序可经过<strong>n-1</strong>趟直接选择排序得到有序结果。具体算法描述如下：</p><p>  初始状态：无序区为R[1…n]，有序区为空；第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1…i-1]和R(i…n）。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第i个记录R交换，使R[1…i]和R[i+1…n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。</p></blockquote><p><strong>动图演示</strong></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf24r2kkavg30mj06w7l2.gif" alt="选择排序"></p><p><strong>代码实现</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectionSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一共需要array.length次循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="comment">//记录最小值的下标</span></span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="comment">//从i开始往后为无序区</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; array.length; j++) &#123;</span><br><span class="line">            <span class="comment">//找到最小的数</span></span><br><span class="line">            <span class="keyword">if</span> (array[j] &lt; array[minIndex]) </span><br><span class="line">                <span class="comment">//将最小数的索引保存</span></span><br><span class="line">                minIndex = j; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将array[i]与array[minIndex]交换</span></span><br><span class="line">        <span class="keyword">int</span> temp = array[minIndex];</span><br><span class="line">        array[minIndex] = array[i];</span><br><span class="line">        array[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><p>插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后移，为新元素提供插入空间。</p><p><strong>算法描述</strong></p><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ol><p><strong>动图演示</strong></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf24r5crvfg30mj0e113f.gif" alt="插入排序"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertionSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录当前指针所指的位置</span></span><br><span class="line">    <span class="keyword">int</span> current;</span><br><span class="line">    <span class="comment">//从1开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="comment">//提前当前元素的值，避免被后移元素覆盖而丢失</span></span><br><span class="line">        current = array[i];</span><br><span class="line">        <span class="comment">//前一个元素</span></span><br><span class="line">        <span class="keyword">int</span> preIndex = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当存在前一个元素并且当前值小于他时不断进行元素后移</span></span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; current &lt; array[preIndex]) &#123;</span><br><span class="line">            <span class="comment">//元素后移</span></span><br><span class="line">            array[preIndex + <span class="number">1</span>] = array[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//current &gt; array[preIndex]或者preIndex == -1,则把current放在preIndex后一位</span></span><br><span class="line">        array[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h2><p>希尔排序是希尔（Donald Shell） 于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破<strong>O(n^2^)</strong>的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。</p><p>希尔排序是把记录按一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><p><strong>算法描述</strong></p><p>在此我们选择增量 <code>gap=length/2</code>，缩小增量继续以<code>gap = gap/2</code>的方式，这种增量选择我们可以用一个序列来表示，<code>{n/2,(n/2)/2…1}</code>，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ol><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1</li><li>按增量序列个数k，对序列进行k 趟排序</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度</li></ol><p><strong>过程演示</strong></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf24rcan4wj30u00vak3f.jpg" alt="希尔排序"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] ShellSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = array.length;</span><br><span class="line">    <span class="keyword">int</span> temp, gap = len / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//插入排序思想</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = array[i];</span><br><span class="line">            <span class="comment">//前一个元素</span></span><br><span class="line">            <span class="keyword">int</span> preIndex = i - gap;</span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; array[preIndex] &gt; temp) &#123;</span><br><span class="line">                array[preIndex + gap] = array[preIndex];</span><br><span class="line">                preIndex -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            array[preIndex + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h2><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是<strong>O(n log n)</strong>的时间复杂度。代价是需要额外的内存空间。</p><p>归并排序 是建立在归并操作上的一种有效的排序算法。该算法是采用<strong>分治法</strong>（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2路归并。</p><p><strong>算法描述</strong></p><ol><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ol><p><strong>动图演示</strong></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf24sx3krhg30mj0e1qcv.gif" alt="归并排序"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] MergeSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> array;</span><br><span class="line">    <span class="keyword">int</span> mid = array.length / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//分为左右两部分，左闭右开</span></span><br><span class="line">    <span class="keyword">int</span>[] left = Arrays.copyOfRange(array, <span class="number">0</span>, mid);</span><br><span class="line">    <span class="keyword">int</span>[] right = Arrays.copyOfRange(array, mid, array.length);</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">return</span> merge(MergeSort(left), MergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] left, <span class="keyword">int</span>[] right) &#123;</span><br><span class="line">    <span class="comment">//创建新数组保存合并数据</span></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[left.length + right.length];</span><br><span class="line">    <span class="comment">//用三个指针来合并数组,分别指向合并后的数组、左数组和右数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>; index &lt; result.length; index++) &#123;</span><br><span class="line">        <span class="comment">//左数组为空或者全部添加完毕，直接复制右数组</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= left.length)</span><br><span class="line">            result[index] = right[j++];</span><br><span class="line">        <span class="comment">//右数组为空或者全部添加完毕，直接复制左数组</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt;= right.length)</span><br><span class="line">            result[index] = left[i++];</span><br><span class="line">        <span class="comment">//右数组当前元素小，添加右数组元素</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (right[j] &lt; left[i])</span><br><span class="line">            result[index] = right[j++];</span><br><span class="line">        <span class="comment">//左数组当前元素小，添加左数组元素</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result[index] = left[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h2><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><p><strong>算法描述</strong></p><p>快速排序使用<strong>分治法</strong>来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><p><strong>动图演示</strong></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf24t1i4htg30mj0707d3.gif" alt="快速排序"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// 找寻基准数据的正确索引</span></span><br><span class="line">        <span class="keyword">int</span> index = getIndex(arr, low, high);</span><br><span class="line">        <span class="comment">// 进行迭代对index之前和之后的数组进行相同的操作使整个数组变成有序</span></span><br><span class="line">        quickSort(arr, low, index - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, index + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//选取基准数据进行分割，返回基准数据的正确位置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基准数据，取第一个元素</span></span><br><span class="line">    <span class="keyword">int</span> tmp = arr[low];</span><br><span class="line">    <span class="comment">//当low和high指针没有相遇时不断循环</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// 当队尾的元素大于等于基准数据时,向前挪动high指针</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= tmp) &#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果队尾元素小于tmp了,将其赋值给low</span></span><br><span class="line">        arr[low] = arr[high];</span><br><span class="line">        <span class="comment">// 当队首元素小于等于tmp时,向前挪动low指针</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= tmp) &#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当队首元素大于tmp时,将其赋值给high</span></span><br><span class="line">        arr[high] = arr[low];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跳出循环时low和high相等,此时的low或high就是tmp的正确索引位置，将tmp赋值给arr[low]</span></span><br><span class="line">    <span class="comment">//将基准数据放在正确的位置</span></span><br><span class="line">    arr[low] = tmp;</span><br><span class="line">    <span class="comment">// 返回tmp的正确位置</span></span><br><span class="line">    <span class="keyword">return</span> low; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h2><p>堆是一个树形结构，其实堆的底层是一棵完全二叉树。而完全二叉树是一层一层按照进入的顺序排成的。按照这个特性，我们可以用数组来按照完全二叉树实现堆。</p><p><strong>算法思想：</strong></p><ol><li>构建初始堆，将待排序列构成一个大顶堆(或者小顶堆)，升序大顶堆，降序小顶堆；</li><li>将堆顶元素与堆尾元素交换，并断开(从待排序列中移除)堆尾元素。</li><li>重新构建堆。</li><li>重复2~3，直到待排序列中只剩下一个元素(堆顶元素)。</li></ol><p><strong>动图演示</strong></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf24t6671fg30f70a4npd.gif" alt="堆排序"></p><p><strong>代码实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">16</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">20</span>, <span class="number">17</span>, <span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line">        heapSort(arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建堆，</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待排序列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (arr.length - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//从第一个非叶子结点从下至上，从右至左调整结构</span></span><br><span class="line">            adjustHeap(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//将堆顶元素与末尾元素进行交换</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//重新对堆进行调整</span></span><br><span class="line">            adjustHeap(arr, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整堆</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待排序列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent 父节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 待排序列尾元素索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> parent, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将temp作为父节点</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[parent];</span><br><span class="line">        <span class="comment">//左孩子</span></span><br><span class="line">        <span class="keyword">int</span> lChild = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (lChild &lt; length) &#123;</span><br><span class="line">            <span class="comment">//右孩子</span></span><br><span class="line">            <span class="keyword">int</span> rChild = lChild + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果有右孩子结点，并且右孩子结点的值大于左孩子结点，则选取右孩子结点</span></span><br><span class="line">            <span class="keyword">if</span> (rChild &lt; length &amp;&amp; arr[lChild] &lt; arr[rChild]) &#123;</span><br><span class="line">                lChild++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果父结点的值已经大于孩子结点的值，则直接结束</span></span><br><span class="line">            <span class="keyword">if</span> (temp &gt;= arr[lChild]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把孩子结点的值赋给父结点</span></span><br><span class="line">            arr[parent] = arr[lChild];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//选取孩子结点的左孩子结点,继续向下筛选</span></span><br><span class="line">            parent = lChild;</span><br><span class="line">            lChild = <span class="number">2</span> * lChild + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[parent] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;排序算法说明&quot;&gt;&lt;a href=&quot;#排序算法说明&quot; class=&quot;headerlink&quot; title=&quot;排序算法说明&quot;&gt;&lt;/a&gt;排序算法说明&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;排序的定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对一序列对象根据某个关键字进行排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;术语说明&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;稳定 ：如果a原本在b前面，并且a=b，则排序之后a仍然在b的前面；&lt;/li&gt;
&lt;li&gt;不稳定 ：如果a原本在b的前面，而a=b，则排序之后a可能会出现在b的后面；&lt;/li&gt;
&lt;li&gt;内排序 ：所有排序操作都在&lt;strong&gt;内存中&lt;/strong&gt;完成；&lt;/li&gt;
&lt;li&gt;外排序 ：由于数据太大，因此把&lt;strong&gt;数据放在磁盘中&lt;/strong&gt;，而排序通过磁盘和内存的数据传输才能进行；&lt;/li&gt;
&lt;li&gt;时间复杂度 ： 一个算法执行所耗费的时间。&lt;/li&gt;
&lt;li&gt;空间复杂度 ：运行完一个程序所需内存的大小。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="http://yoursite.com/2020/05/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/05/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2020-06-08T00:57:51.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h2><p>普通的二叉查找树在极端情况下可退化成链表，此时的增删查效率都会比较低下。为了避免这种情况，就出现了一些自平衡的查找树，比如 AVL，红黑树等。这些自平衡的查找树通过定义一些性质，将任意节点的左右子树高度差控制在规定范围内，以达到平衡状态。以红黑树为例，红黑树通过如下的性质定义实现自平衡：</p><ol><li>节点是红色或黑色。</li><li>根是黑色。</li><li>所有叶子都是黑色（叶子是NIL节点）。</li><li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li><li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（简称黑高）。</li></ol><a id="more"></a><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4plqn21hj30zw0c60u9.jpg" alt="红黑树"></p><p>有了上面的几个性质作为限制，即可避免二叉查找树退化成单链表的情况。但是，仅仅避免这种情况还不够，这里还要考虑某个节点到其每个叶子节点路径长度的问题。如果某些路径长度过长，那么，在对这些路径上的及诶单进行增删查操作时，效率也会大大降低。这个时候性质4和性质5用途就凸显了，有了这两个性质作为约束，即可保证<strong>任意节点到其每个叶子节点路径最长不会超过最短路径的2倍</strong>。原因如下：</p><p>当某条路径最短时，这条路径必然都是由黑色节点构成。当某条路径长度最长时，这条路径必然是由红色和黑色节点相间构成（性质4限定了不能出现两个连续的红色节点）。而性质5又限定了从任一节点到其每个叶子节点的所有路径必须包含相同数量的黑色节点。此时，在路径最长的情况下，路径上红色节点数量 = 黑色节点数量。该路径长度为两倍黑色节点数量，也就是最短路径长度的2倍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;红黑树的性质&quot;&gt;&lt;a href=&quot;#红黑树的性质&quot; class=&quot;headerlink&quot; title=&quot;红黑树的性质&quot;&gt;&lt;/a&gt;红黑树的性质&lt;/h2&gt;&lt;p&gt;普通的二叉查找树在极端情况下可退化成链表，此时的增删查效率都会比较低下。为了避免这种情况，就出现了一些自平衡的查找树，比如 AVL，红黑树等。这些自平衡的查找树通过定义一些性质，将任意节点的左右子树高度差控制在规定范围内，以达到平衡状态。以红黑树为例，红黑树通过如下的性质定义实现自平衡：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;节点是红色或黑色。&lt;/li&gt;
&lt;li&gt;根是黑色。&lt;/li&gt;
&lt;li&gt;所有叶子都是黑色（叶子是NIL节点）。&lt;/li&gt;
&lt;li&gt;每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）&lt;/li&gt;
&lt;li&gt;从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（简称黑高）。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>RPC框架</title>
    <link href="http://yoursite.com/2020/05/30/%E7%BD%91%E7%BB%9C/RPC%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2020/05/30/%E7%BD%91%E7%BB%9C/RPC%E6%A1%86%E6%9E%B6/</id>
    <published>2020-05-30T12:50:49.000Z</published>
    <updated>2020-06-08T00:54:04.730Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  参考文档：<a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/data-communication/why-use-rpc" target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/docs/system-design/data-communication/why-use-rpc</a></p></blockquote><h2 id="RPC简介"><a href="#RPC简介" class="headerlink" title="RPC简介"></a>RPC简介</h2><h4 id="什么是-RPC？"><a href="#什么是-RPC？" class="headerlink" title="什么是 RPC？"></a>什么是 RPC？</h4><p>RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP请求当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。</p><a id="more"></a><h2 id="RPC原理"><a href="#RPC原理" class="headerlink" title="RPC原理"></a>RPC原理</h2><p><a href="https://www.cnblogs.com/swordfall/p/8683905.html" target="_blank" rel="noopener">RPC原理解析</a></p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4olrump8j30dv08t77k.jpg" alt="RPC原理图" style="zoom:67%;" /><ol><li>服务消费方（client）调用以本地调用方式调用服务；</li><li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li><li>client stub找到服务地址，并将消息发送到服务端；</li><li>server stub收到消息后进行解码；</li><li>server stub根据解码结果调用本地的服务；</li><li>本地服务执行并将结果返回给server stub；</li><li>server stub将返回结果打包成消息并发送至消费方；</li><li>client stub接收到消息，并进行解码；</li><li>服务消费方得到最终结果。</li></ol><p>时序图：</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4ondbhbfj30gh0fsq51.jpg" alt="RPC原理时序图"  /><h2 id="RPC-解决了什么问题？"><a href="#RPC-解决了什么问题？" class="headerlink" title="RPC 解决了什么问题？"></a>RPC 解决了什么问题？</h2><p><strong>让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单。</strong></p><h2 id="常见的-RPC-框架"><a href="#常见的-RPC-框架" class="headerlink" title="常见的 RPC 框架"></a>常见的 RPC 框架</h2><ul><li><strong>RMI（JDK自带）：</strong> JDK自带的RPC，有很多局限性，不推荐使用。</li><li><strong>Dubbo:</strong> Dubbo是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。目前 Dubbo 已经成为 Spring Cloud Alibaba 中的官方组件。</li><li><strong>gRPC</strong> ：gRPC是可以在任何环境中运行的现代开源高性能RPC框架。它可以通过可插拔的支持来有效地连接数据中心内和跨数据中心的服务，以实现负载平衡，跟踪，运行状况检查和身份验证。它也适用于分布式计算的最后一英里，以将设备，移动应用程序和浏览器连接到后端服务。</li><li><strong>Hessian：</strong> Hessian是一个轻量级的remotingonhttp工具，使用简单的方法提供了RMI的功能。 相比WebService，Hessian更简单、快捷。采用的是二进制RPC协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。</li><li><strong>Thrift：</strong> Apache Thrift是Facebook开源的跨语言的RPC通信框架，目前已经捐献给Apache基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于thrift研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。</li></ul><h2 id="HTTP和RPC比较"><a href="#HTTP和RPC比较" class="headerlink" title="HTTP和RPC比较"></a>HTTP和RPC比较</h2><p>RPC 是一种概念、一种设计，就是为了解决 <strong>不同服务之间的调用问题</strong>, 它一般会包含有 <strong>传输协议</strong> 和 <strong>序列化协议</strong> 这两个。</p><p>HTTP 是一种协议，RPC框架可以使用 HTTP协议作为传输协议或者直接使用TCP作为传输协议，使用不同的协议一般也是为了适应不同的场景。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;  参考文档：&lt;a href=&quot;https://snailclimb.gitee.io/javaguide/#/docs/system-design/data-communication/why-use-rpc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://snailclimb.gitee.io/javaguide/#/docs/system-design/data-communication/why-use-rpc&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;RPC简介&quot;&gt;&lt;a href=&quot;#RPC简介&quot; class=&quot;headerlink&quot; title=&quot;RPC简介&quot;&gt;&lt;/a&gt;RPC简介&lt;/h2&gt;&lt;h4 id=&quot;什么是-RPC？&quot;&gt;&lt;a href=&quot;#什么是-RPC？&quot; class=&quot;headerlink&quot; title=&quot;什么是 RPC？&quot;&gt;&lt;/a&gt;什么是 RPC？&lt;/h4&gt;&lt;p&gt;RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP请求当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
</feed>
